# 后端笔记

## java SE

### 02：Java概述

#### Java 重要特点

1. Java 语言是面向对象的(oop)

2. Java 语言是健壮的。Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证
3. Java 语言是跨平台性的。[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台]

3) Java 语言是解释型的[了解] 。

   解释性语言：javascript,PHP, java 

   编译性语言: c / c++ 

   区别是：解释性语言，编译后的代码，不能直接被机器执行,需要解释器来执行, 编译性语言, 编译后的代码, 可以直接被机器执行, c /c+

#### 什么是 JDK，JRE，JVM

1. JDK 的全称（Java Development Kit） Java 开发工具包。JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独 安装 JRE 了。

   **JDK = JRE + java 的开发工具** [java, javac,javadoc,javap 等]

2. JRE的全称（Java Runtime Environment） Java 运行环境。包括 Java 虚拟机(**JVM** Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序， 计算机中只需要安装 JRE 即可。

   **JRE = JVM +Java 的核心类库**

####  Java 开发注意事项和细节说明

![image-20240224162718902](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240224162718902.png)

####  Java 转义字符

![image-20240224162905093](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240224162905093.png)

#### 注释(comment)

用于注解说明解释程序的文字就是注释，注释提高了代码的阅读性（可读性）；注释是一个程序员必须要具有的良 好编程习惯。将自己的思想通过注释先整理出来，再用代码去体现。

```java
//单行注释

/*
多行注释

多行注释
*/

/**
	*文档注释
	*author 陈俊宇
	*version 1.0
	*	
	*见下图
*/
```

![image-20240224163254806](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240224163254806.png)

####  Java 代码规范

![image-20240224163415535](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240224163415535.png)

#### Java编写步骤

1. 编写java的源代码

2. javac编译，得到对应的.class字节码文件

3. java运行，本质就是把.class加载到JVM运行

#### 本章作业

![image-20240224163527124](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240224163527124.png)

### 03：变量

#### 概念

变量相当于内存中一个数据存储空间的表示，你可以把变量看做是一个房间的门牌号，通过门牌号我们可以找到房间，而通过变量名可以访问到变量(值)

**变量 = 变量名 + 值 + 数据类型**

#### 程序中 +号的使用

1. 当左右两边都是数值型时，则做加法运算

2. 当左右两边有一方为字符串,则做拼接运算

![image-20240225113717741](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225113717741.png)

#### 数据类型

每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间(字节)。

![image-20240225145443035](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225145443035.png)

 基本数据类型有 8 中 数值型 byte , short , int , long , float ,double，char , boolean；引用类型有三种：类，接口， 数组。

##### 整型

Java 的整数类型就是用于存放整数值的，比如 12 , 30, 3456 等等。

![image-20240225145649044](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225145649044.png) 

![image-20240225145807635](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225145807635.png) 

**注意：byte a = 10;**

**看似是将默认的int类型转换成了更小的byte类型应该会报错，但是表达式是正确的。因为这里程序所做的事是：判断10这个值是否在-128~127之间，根据这个来看是否符合要求，注意：这里的10一定是一个具体的值，而不能是变量，或者是大于这个范围的值。short类型同样适用。**

##### 浮点型

Java 的浮点类型可以表示一个小数，比如 123.4 ，7.8 ，0.12 等等。

![image-20240225145919616](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225145919616.png) 

![image-20240225150023292](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150023292.png) 

##### 字符型

字符类型可以表示单个字符,字符类型是 char，char 是两个字节(可以存放汉字)，多个字符我们用字符串 String。

![image-20240225150238229](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150238229.png) 

![image-20240225150345863](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150345863.png) 

##### 布尔型

![image-20240225150439440](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150439440.png) 

#### 基本数据类型转换

##### 自动类型转换

![image-20240225150544626](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150544626.png) 

![image-20240225150650565](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150650565.png) 

##### 强制类型转换

自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符 ( )，但可能造成
精度降低或溢出,格外要注意。

![image-20240225150803240](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150803240.png) 

![image-20240225150850098](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150850098.png) 

#### 基本数据类型和 String 类型的转换

![image-20240225151001328](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225151001328.png) 

1. 在将 String 类型转成 基本数据类型时， 要确保String类型能够转成有效的数据，比如 我们可以把 "123" , 转成一个整数，但是不能把 "hello" 转成一个整数

2. 如果格式不正确，就会抛出异常，程序就会终止，

#### 本章作业

![image-20240225151148714](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225151148714.png)

### 04：运算符

运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等

#### 算术运算符

算术运算符是对数值类型的变量进行运算的，在 Java 程序中使用的非常多

![image-20240227145701670](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227145701670.png)

![image-20240227145728090](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227145728090.png)

![image-20240227145749356](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227145749356.png)

#### 比较运算符

关系运算符的结果都是 boolean 型，也就是要么是 true，要么是 false

![image-20240227145853553](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227145853553.png)

关系运算符组成的表达式，我们称为**关系表达式**。 a > b

#### 逻辑运算符

用于连接多个条件（多个关系表达式），最终的结果也是一个 boolean 

![image-20240227150124179](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227150124179.png)

1. **a&b** : & 叫**逻辑与**：规则：当 a 和 b 同时为 true ,则结果为 true, 否则为 false 

2. **a&&b** : && 叫**短路与**：规则：当 a 和 b 同时为 true ,则结果为 true,否则为 false 

3. **a|b** : | 叫**逻辑或**，规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false 

4. **a||b** : || 叫**短路或**，规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false

5. **!a** : 叫**取反**。当 a 为 true, 则结果为 false, 当 a 为 false 是，结果为 true 

6. **a^b**: 叫**逻辑异或**，当 a 和 b 不同时，则结果为 true, 否则为 false

**&& 和 & 使用区别（||和|同）:**

1. &&短路与：**如果第一个条件为 false，则第二个条件不会判断**，最终结果为 false，效率高 
2. & 逻辑与：**不管第一个条件是否为 false，第二个条件都要判断**，效率低

#### 赋值运算符

赋值运算符就是将某个运算后的值，赋给指定的变量。

赋值运算符分为两类：

1. 基本赋值运算符 **=** ：int a = 10
2.  复合赋值运算符**+= ，-= ，*= ， /= ，%=** ：
   a += b  ====》  等价 a = a + b; 

#### 三元运算符

条件表达式    ?     表达式 1    :     表达式2

运算规则： 

1. 如果条件表达式为 true，运算后的结果是表达式 1； 
2. 如果条件表达式为 false，运算后的结果是表达式 2

细节：

表达式 1 和表达式 2 要为可以赋给接收变量的类型(或可以自动转换)

#### 标识符的命名规则和规范

规则：

![image-20240227151129934](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227151129934.png)

规范：

1. 包名：多单词组成时所有字母都小写：aaa.bbb.ccc //比如 com.hsp.crm 
2. 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰] 比如： TankShotGame 
3. 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz [小 驼峰， 简称 驼峰法] 比如： tankShotGame 
4. 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ 比如 ：定义一个所得税率 TAX_RATE 

#### 键盘输入语句

在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。Input.java , 需要一个 扫描器(对象), 就是 Scanner

步骤：

1.  引入/导入 Scanner 类所在的包
   **import java.util.Scanner;**
2. 创建 Scanner 对象 , new 创建一个对象
   **Scanner myScanner = new Scanner(System.in)；**
3. 调用里面的功能
   **String name = myScanner.next(); //接收用户输入字符串**
   int age = myScanner.nextInt(); //接收用户输入 int
   double sal = myScanner.nextDouble(); //接收用户输入 doubl

```java
import java.util.Scanner;
public class Input {
    Scanner myScanner = new Scanner(System.in);
    String name = myScanner.next();
}
```



#### 原码、反码、补码

**进制:**

二进制：0,1 ，满 2 进 1.以 0b 或 0B 开头。 

十进制：0-9 ，满 10 进 1。 

八进制：0-7 ，满 8 进 1. 以数字 0 开头表示。 

十六进制：0-9 及 A(10)-F(15)，满 16 进 1. 以 0x 或 0X

**原码、反码、补码：**

![image-20240227152037830](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227152037830.png)

为什么计算机的计算都是采用补码的方式？

因为可以统一正数和负数的运算

#### 位运算符

java 中有 **7 个**位运算(**&、|、 ^ 、~、>>、<<和 >>>**)

![image-20240227152230556](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227152230556.png)

1. 算术右移 >>：低位溢出,符号位不变,并用符号位补溢出的高位 
2. 算术左移 <<: 符号位不变,低位补 0 
3. **>>>**逻辑右移也叫无符号右移,运算规则是: 低位溢出，高位补 0 
4. 特别说明：没有 <<< 符号

本章作业：

![image-20240227152554047](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227152554047.png)

![image-20240227152604098](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227152604098.png)

### 05：程序控制结构

在程序中，程序运行的流程控制决定程序是如何执行的，是我们必须掌握的，主要有三大流程控制语句：

1. 顺序控制
2. 分支控制 
3. 循环控制

####  顺序控制

![image-20240227184158551](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227184158551.png)

#### 分支控制 

让程序有选择的的执行,分支控制有三种 

1. 单分支 if 
2. 双分支 if-else 
3. 多分支 if-else if -....-else

##### 单分支

![image-20240227184323395](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227184323395.png)

![image-20240227190203640](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227190203640.png) 

##### 双分支

![image-20240227190255856](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227190255856.png)

![image-20240227190411393](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227190411393.png) 

##### 多分支

![image-20240227191732315](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227191732315.png) 

![image-20240227191751330](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227191751330.png) 

##### 嵌套分支

在一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支的结构称为内层分支外面的分支结构称为外 层分支。

老师建议: 不要超过 3层（可读性不好）

##### switch 分支结构

![image-20240227193344488](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227193344488.png)

![image-20240227193358043](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227193358043.png)

![image-20240227193956153](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227193956153.png)

##### switch 和 if 的比较

1. 如果判断的具体数值不多，而且符合 byte、 short 、int、 char, enum[枚举], String 这 6 种类型。虽然两个语句都可 以使用，建议使用 swtich 语句。 
2. 其他情况：对区间判断，对结果为 boolean 类型判断，使用 if，if 的使用范围更广

#### 循环控制

##### for 循环

![image-20240227194619183](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227194619183.png)

![image-20240227194634788](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227194634788.png)

1.  循环条件是返回一个布尔值的表达式 
2. for(;循环判断条件;) 中的初始化和变量迭代可以写到其它地方，但是两边的分号不能省略。 
3. 循环初始值**可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开**，循环变量迭代也可以有多条变量迭代 语句，中间用逗号隔开。

##### while 循环

![image-20240227195208401](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227195208401.png) 

![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227195217459.png) 

1. 循环条件是返回一个布尔值的表达式 
2. while 循环是先判断再执行语句

#####  do..while 循环

![image-20240227195605308](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227195605308.png) 

![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227195722863.png) 

1. 先执行，再判断，也就是说，一定会至少执行一次 
2. **最后 有一个 分号 ;** 

##### 多重循环

1. 将一个循环放在另一个循环体内，就形成了嵌套循环。其中，for ,while ,do…while 均可以作为外层循环和内层循环。 【**建议一般使用两层，最多不要超过 3 层**, 否则，代码的可读性很差】 
2. 实质上，**嵌套循环就是把内层循环当成外层循环的循环体**。当只有内层循环的循环条件为 false 时，才会完全跳出内 层循环，才可结束外层的当次循环，开始下一次的循环

3. 设外层循环次数为 m 次，内层为 n 次，则内层循环体实际上需要执行 m*n 次。

![image-20240227200302757](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227200302757.png) 

#### 跳转控制

##### break

break 语句用于终止某个语句块的执行，一般使用在 switch 或者循环[for , while , do-while]中

![image-20240227202403904](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227202403904.png) 

![image-20240227202419529](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227202419529.png)

##### continue

1. continue 语句用于结束本次循环，继续执行下一次循环。 
2. continue 语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环 , 这个和前面的标签的 使用的规则一样

![image-20240227202548239](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227202548239.png) 

##### return

return 使用在方法，表示跳出所在的方法。如果 return 写在 main 方法中，则退出程序。

![image-20240227202706376](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227202706376.png) 

#### 本章作业

![image-20240227202734212](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227202734212.png)

![image-20240227202741313](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227202741313.png) 

### 06：数组、排序和查找

数组可以存放多个同一类型的数据。数组也是一种数据类型，是引用类型。

**数(数据)组(一组)就是一组数据**

#### 数组的使用

```java
//**使用方式一：动态初始化**
int a[] = new int[3];

//**使用方式二：动态初始化**
//先申明数组、再创建数组
int a[];
a = new int[3];

//**使用方式三：静态初始化**
int a[] = {2,3,4};
```

![image-20240228162344823](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228162344823.png) 

#### 数组的细节

1. 数组是多个**相同类型数据的组合**，实现对这些数据的统一管理

2) 数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用。
3) 数组创建后，**如果没有赋值，有默认值**
   int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \u0000，boolean false，String null

4) 使用数组的步骤 
   1) 声明数组并开辟空间 
   2) 给数组各个元素赋值 
   3) 使用数组
5) 数组的**下标是从** **0** **开始的**
6) 数组下标必须在指定范围内使用，否则报错：下标越界异常
7) 数组属**引用类型**，数组型数据是对象(object)

#### 数组赋值机制

1. 基本数据类型赋值，这个值就是具体的数据，而且相互不影响。int n1 = 2; int n2 = n1;

2) 数组在**默认情况下是引用传递，赋的值是地址**。

![image-20240228162932571](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228162932571.png) 

#### 排序

排序是将多个数据，依指定的顺序进行排列的过程。

排序分为：内部排序和外部排序

1. 内部排序：指将需要处理的所有数据都加载到内部存储器中进行排序。包括(交换式排序法、选择式排序法和插入式排序法)
2. 外部排序：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括(合并排序法和直接合并排序法)

#### 冒泡排序法

冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从后向前（从下标较大的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。

**思路：**

![image-20240228163400974](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228163400974.png) 

#### 二维数组

```java
//**使用方式1：动态初始化**
int a[3][3] = new int[3][3];

//**使用方式2：动态初始化**
//先声明、再开辟空间
int a[][];
a = new int[3][3]
    
//**使用方式 3: 动态初始化-列数不确定**
/**
0
00
000
*/
int a[][] = new a[10][];//先开辟行数的空间
for(int i = 0; i < a.length; i++) {
    a[i] = new int[i+1]; //再动态开辟列数的空间
}

int a[][];
a

//**使用方式 4: 静态初始化**
int a[][] = {{1,2,3},{4,5,6},{7,8,9}};
```

**储存细节：**

![image-20240228163846781](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228163846781.png) 

#### 二维数组细节

1) 一维数组的声明方式有:
   int[] x 或者 int x[]

2) 二维数组的声明方式有:
   ![image-20240228164437857](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228164437857.png)

3. 二维数组实际上是由多个一维数组组成的，它的各个一维数组的长度可以相同，也可以不相同。
4. 还是要注意数据类型的自动转换

![image-20240228164546217](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228164546217.png) 

#### 本章作业

![image-20240228164725724](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228164725724.png) 

![image-20240228164742609](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228164742609.png) 





































# **前端笔记**

## HTML

##### 描述：

用于定义网络结构的基本技术

##### 基本语法：

<开始标签>	内容	<结束标签>

![image-20240115105017529](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115105017529.png)

##### 标签：

+ ###### **分区div**

  div是一个纯粹的容器，<div>元素在语义上不表示任何特定类型的内容。然而，其可以将内容分组，从而可以使用**class**或是**id**属性方便的定义内容的格式。

+ ###### **标题h1~h6**

  HTML `<h1>`–`<h6>` 标题 (Heading) 元素呈现了六个不同的级别的标题，`<h1>` 级别最高，而 `<h6>` 级别最低。

+ ###### **段落p**

   **`<p>`** 元素表示文本的一个段落。段落是块级元素。

+ ###### **图像img**

  <img> 元素将一张图像嵌入文档

  ![image-20240115110304202](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115110304202.png) 

  - `src` 属性是**必须的**，它包含了你想嵌入的图片的路径。
  - `alt` 属性包含一条对图像的文本描述，这不是强制性的。如果由于某种原因无法加载图像，普通浏览器也会在页面上显示 `alt` 属性中的备用文本：例如，网络错误、内容被屏蔽或链接过期。

+ ###### **列表ul/ol**

  **`<ul>`** 元素表示一系列无序的列表项目，通常渲染为项目符号列表。

  ![image-20240115110519215](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115110519215.png) 

  **`<ol>` **元素表示有序列表，通常渲染为一个带编号的列表。

  ![image-20240115110655736](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115110655736.png) 

+ ###### **超链接a**

  <a> 元素（或称锚元素）可以通过它的 href 属性创建通向其他网页、文件、电子邮件地址、同一页面内的位置或任何其他 URL 的超链接。

  <a> 中的内容应该指明链接的目标。如果存在 href 属性，当 <a> 元素聚焦时按下回车键就会激活它。

  <a>中的href属性可以使用**文本片段**链接到某一段文字：这时点击a标签会直接跳转到相应的标签

  ![image-20240115111039304](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115111039304.png) 

+ ###### **表单form**

  **`<form>` 元素**表示文档中的一个区域，此区域包含交互控件，用于向 Web 服务器提交信息。

  ```html
  action:处理表单提交的 URL。这个值可被 <button>、<input type="submit"> 或 <input type="image"> 元素上的 formaction 属性覆盖。
  method:浏览器使用这种 HTTP 方式来提交 表单。可能的值有：
  	post：指的是 HTTP POST 方法；表单数据会包含在表单体内然后发送给服务器。
      get：指的是 HTTP GET 方法；表单数据会附加在 action 属性的 URL 中，并以 '?' 作为分隔符，没有副作用 时使用这个方法。
  <form action="" method="get" class="form-example">
    <div class="form-example">
      <label for="name">Enter your name: </label>
      <input type="text" name="name" id="name" required />
    </div>
    <div class="form-example">
      <label for="email">Enter your email: </label>
      <input type="email" name="email" id="email" required />
    </div>
    <div class="form-example">
      <input type="submit" value="Subscribe!" />
    </div>
  </form>
  ```

   ![image-20240115111322271](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115111322271.png)

+ ###### **表格table**

  **table**元素表示表格数据——即在一个由包含数据的行和列组成的二维表格中呈现的信息。

  ```html
  <table>
    <thead>
      <tr>
        <th colspan="2">The table header</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>The table body</td>
        <td>with two columns</td>
      </tr>
    </tbody>
  </table>
  ```

  ![image-20240115111909442](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115111909442.png) 

+ ###### **框架iframe**

​	**HTML 内联框架元素 (`<iframe>`)** ,它能够将另一个 HTML 页面嵌入到当前页面中。目前我还没有用到这个。

##### HTML5特性：

###### 语义化标签：

当接近要使用的标记时，问问自己，“什么元素最能描述/表示我要填充的数据？”例如，它是数据列表吗？有序或无序？是否是一篇具有章节和相关信息旁注的文章？它是否列出了定义？它是需要标题的图形还是图像？除了全局网站范围的页眉和页脚之外，它还应该有页眉和页脚吗？等等。

写语义标记的一些好处如下：

- 搜索引擎将其内容视为影响页面搜索排名的重要关键字。

- 比起搜索无休止的带有或不带有语义/命名空间类的 `div`，找到有意义的代码块显然容易得多。

- 语义命名反映了正确的自定义元素/组件命名。

- 常见的语义化元素

  ```html
  <article>
  <aside>
  <detiales>
  <figcaption>
  <figure>
  <footer>
  <header>
  <main>
  <mark>
  <nav>
  <section>
  <summary>
  <time>
  ```



## 前端基础知识

##### 互联网：

互联网（[internet](https://baike.baidu.com/item/internet/272794?fromModule=lemma_inlink)），又称国际网络，指的是[网络](https://baike.baidu.com/item/网络/143243?fromModule=lemma_inlink)与网络之间所串连成的庞大网络，这些网络以一组通用的[协议](https://baike.baidu.com/item/协议/13020269?fromModule=lemma_inlink)相连，形成逻辑上的单一巨大国际网络。

互联网始于1969年[美国](https://baike.baidu.com/item/美国/125486?fromModule=lemma_inlink)的[阿帕网](https://baike.baidu.com/item/阿帕网/1950726?fromModule=lemma_inlink)。通常[internet](https://baike.baidu.com/item/internet/272794?fromModule=lemma_inlink)泛指互联网，而Internet则特指[因特网](https://baike.baidu.com/item/因特网/114119?fromModule=lemma_inlink)。这种将[计算机网络](https://baike.baidu.com/item/计算机网络/18763?fromModule=lemma_inlink)互相联接在一起的方法可称作“网络互联”，在这基础上发展出覆盖全世界的全球性互联网络称互联网，即是互相连接一起的[网络结构](https://baike.baidu.com/item/网络结构/8259917?fromModule=lemma_inlink)。

##### 域名：

域名（英语：Domain Name），又称网域，是由一串用点分隔的名字组成的[互联网](https://baike.baidu.com/item/互联网/199186?fromModule=lemma_inlink)上某一台[计算机](https://baike.baidu.com/item/计算机/140338?fromModule=lemma_inlink)或计算机组的名称，用于在[数据传输](https://baike.baidu.com/item/数据传输/2987565?fromModule=lemma_inlink)时对计算机的定位标识（有时也指地理位置）。 [1]

由于[IP地址](https://baike.baidu.com/item/IP地址/150859?fromModule=lemma_inlink)不方便记忆并且不能显示地址组织的名称和性质，人们设计出了域名，并通过[域名系统](https://baike.baidu.com/item/域名系统/2251573?fromModule=lemma_inlink)（DNS，Domain Name System）来将域名和IP地址相互[映射](https://baike.baidu.com/item/映射/20402621?fromModule=lemma_inlink)，使人更方便地访问互联网，而不用去记住能够被机器直接读取的IP地址数串。

##### DNS：

DNS（Domain Name System）域名系统，是一个层次化、分散化的互联网连接资源命名系统。DNS 维护着一个[域名](https://developer.mozilla.org/zh-CN/docs/Glossary/Domain_name)列表以及与之相关联的资源（例如 IP 地址）。

DNS 最突出的功能是将易于记忆的域名（例如 mozilla.org）翻译成为数字化的 [IP 地址](https://developer.mozilla.org/zh-CN/docs/Glossary/IP_Address)（例如 151.106.5.172）；这一从域名到 IP 地址的映射过程被称为**DNS 查询**（DNS lookup）。与之对应，**DNS 反向查询**（rDNS）用来找到与 IP 地址对应的域名。

##### 服务器：

服务器是为用户（通常称为客户端）提供服务的软件或硬件。硬件而言的服务器是互联网上的共享计算机，通常性能强劲且位于数据中心。软件而言的服务器（一般是运行在硬件服务器上）是一种向客户端程序或向[用户界面](https://developer.mozilla.org/zh-CN/docs/Glossary/UI)提供服务的程序。

我们一般在局域网或广域网（如互联网）提供服务。传统上，客户端程序和服务器程序通过 [API](https://developer.mozilla.org/zh-CN/docs/Glossary/API) 传递信息进行连接，这种信息使用[协议](https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol)编码。

举个例子：

- 连接到互联网的 Web 服务器向你的浏览器发送一个 [HTML](https://developer.mozilla.org/zh-CN/docs/Glossary/HTML) 文件，这样你就可以浏览页面。
- 用于文件、域名、邮件、打印机和传真机的局域网服务器。
- 数据中心的小型机、大型机和超算。

##### 浏览器：

**浏览器**是一种从 [Web](https://developer.mozilla.org/zh-CN/docs/Glossary/World_Wide_Web) 获取和显示页面的程序，并且让用户通过[超链接](https://developer.mozilla.org/zh-CN/docs/Glossary/Hyperlink)访问更多页面。浏览器是最常见的一种用户代理。

###### DOM事件流：

DOM(文档对象模型)结构是一个树型结构，当一个[HTML元素](https://baike.baidu.com/item/HTML元素/5983313?fromModule=lemma_inlink)产生一个事件时，该事件会在元素节点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为DOM事件流。

DOM同时支持两种事件模型：[捕获型事件](https://baike.baidu.com/item/捕获型事件/0?fromModule=lemma_inlink)和[冒泡型事件](https://baike.baidu.com/item/冒泡型事件/7508003?fromModule=lemma_inlink)，但是，捕获型事件先发生，冒泡型事件后发生。两种事件流会触发DOM中的所有对象，从[document对象](https://baike.baidu.com/item/document对象/6553996?fromModule=lemma_inlink)开始，也在document对象结束。

![image-20240225131301937](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225131301937.png) 

###### 事件委托：

当冒泡和捕获同时存在时，事件触发顺序为：捕获->目标（small就是目标）->冒泡。事件委托，也叫事件代理，一般指的是利用事件冒泡，将一个或者一组DOM的事件处理程序，委托给其父级元素或者更外层元素。**可以通过只指定一个事件处理程序，就可以管理一批同类型的事件处理程序**。

例如：如果需要给列表项添加事件，当列表项数量过多时，会存在频繁操作DOM的情况；并且函数是引用类型, 需要堆内存来存储，占用大量空间。**通过事件委托，可以将事件绑定到其父级元素ul上，这样只需要操作一次DOM，不会引起频繁的重绘。**也不会占用大量的空间。

```html
<!-- 通过事件的具体属性实现通过事件委托也和直接绑定在li上一样的效果--><!DOCTYPE html>
<html lang="en">
<body>
  <ul id='father'>
    <li id="a">A</li>
    <li id="b">B</li>
    <li id="c">C</li>
    <li id="d">D</li>
  </ul>
  <script>
  father.addEventListener('click', function(e) {
    const event = e；
    const target = event.target；
    // 根据事件属性判断当前所在的DOM节点，不同节点处理不同的程序（主要通过e.target,在父节点上定义的事件，可以处理子节点）
    switch(target.id) {
      case "a":
        console.log('a');
        break;
      case "b":
        console.log('b');
        break;
      case "c":
        console.log("c");
        break;
      case "d":
        console.log("d");
        break;
      default:
        console.log('default');
    }
  })
  </script>
</body>
</html>
```

###### 浏览器加载顺序：

1. HTML解析完毕

2. 外部脚本和样式加载完毕

3. 脚本在文档内解析并执行

4. HTML DOM完全构造起来

5. 图片个外部内容加载

6. 网页完全加载

**1-4执行是很快的，5很慢**

###### 浏览器渲染过程：

渲染流程大致可以划分为五个过程：

1. 构建DOM

   <img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240121114811031.png" alt="image-20240121114811031" style="zoom:50%;" /> 

2. 构建CSSOM

   <img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240121114842031.png" alt="image-20240121114842031" style="zoom:50%;" /> 

3. 构建渲染（render）树

   ![image-20240121114959429](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240121114959429.png) 

4. 布局

   获取渲染树的结构，节点位置和大小，然后依据盒子模型来进行布局

5. 绘制

   把渲染树以像素的形式绘制在页面上

![image-20240121114521130](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240121114521130.png) 

**（如果构建DOM的过程中，碰见js，则下载js，如果js没有额外的设置则需要等到CSSOM构建完成后才能执行js文件，js既可以对DOM做修改，也可以对CSSOM做修改）**



##### HTTP：

HTTP（Hyper Text Transformer Protocol，超文本传输协议）是一种通信协议，它允许将超文本标记语言（HTML）文档从Web服务器传送到客户端的浏览器。

它是一个应用层协议，承载于TCP协议之上。

###### HTTP1.0

HTTP/1.0是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。默认采用短连接。

HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。这种无状态性可以借助cookie/session机制来做身份认证和状态记录。

缺点，无连接的特性导致最大的性能缺陷就是无法复用连接。每次发送请求的时候，都需要进行一次TCP的连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率非常低。

###### HTTP1.1

HTTP/1.1版本，持久连接/长连接被默认采用（默认模式使用带流水线的持久连接），并能很好地配合代理服务器工作，还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。

###### HTTP请求方法

1. GET

   请求指定的页面信息，并返回实体主体。

   注：GET也可以将数据提交到服务器，不过一般都是使用POST提交数据到服务器.

2. POST

   POST请求方法的作用：向服务器发送数据。

   POST和GET请求方法的本质区别：

   ​    1、GET用于信息获取，它是安全的（这里安全的含义是指非修改信息），而POST是用于修改服务器上资源的请求；

   ​    2、GET请求的数据会附在URL之后（然后提交到服务器），而POST把提交的数据则放置在HTTP实体的主体里，所以，POST的安全性要比GET的安全性高；

   ​    3、GET方式提交数据和POST方法提交数据并没有限制数据大小。

3. HEAD

   HEAD请求方法作用：只请求头部，允许客户端在未获取资源实体的情况下，对资源的头部检查，了解资源的基本情况，比如类型，是否被修改过等。

   HEAD和GET请求方法的区别：GET请求回来的报文有实体的主体部分，而HEAD请求回来的报文没有实体的主体部分。

###### 状态码

2xx 成功

3xx 重定向

4xx 客户端报错

5xx 服务端报错

###### Cookie

是某些网站为了辨别用户身份，进行[Session](https://baike.baidu.com/item/Session/479100?fromModule=lemma_inlink)跟踪而储存在用户本地终端上的数据（通常经过加密），由用户[客户端](https://baike.baidu.com/item/客户端/101081?fromModule=lemma_inlink)计算机暂时或永久保存的[信息](https://baike.baidu.com/item/信息/111163?fromModule=lemma_inlink) 。

###### HTTPS

HTTPS （全称：Hypertext Transfer Protocol Secure [5]），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和[身份认证](https://baike.baidu.com/item/身份认证/5294713?fromModule=lemma_inlink)保证了传输过程的安全性 。HTTPS 在HTTP 的基础下加入[SSL](https://baike.baidu.com/item/SSL/320778?fromModule=lemma_inlink)，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。

## Git

#### git基础命令笔记：

git remote -v查看配置了的远程连接的名称

git remote add origin https://github.com/RJrowlling/ExerciseProject.git 配置远程连接，连接本地仓库和远程仓库

git remote rm origin 删除配置了的远程连接



git branch 查看分支名称

git branch issue1 新建分支

git branch -d issue1 删除分支

git checkout mian 切换分支



git add README.md 将READNE.md文件添加到索引暂存区

git commit -m "将暂存区里的索引同步到本地数据库上，并设置了message"

git push origin main 将本地仓库的数据推送到远程仓库的main分支中



git revert HEAD撤消上一次提交的更改。

1. 注意这里只是从本地仓库中还原了上一次提交的更改，如果你已经push到远程仓库，则远程仓库不变，除非你再次push
2. Git revert 命令将一个提交作为参数，并**创建一个新的提交来撤消该提交所做的更改**。

#### 把本地项目上传到github上出现了问题？

![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240127160257601.png) 

![image-20240127160239654](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240127160239654.png) 

##### 1. 没有在github上面关联公钥

基础的内容已经配置好了（用户名，电子邮箱，本地钥匙都有），首先进入C:\Users\cjy\\.ssh目录文件下找到id_rsa.pub公钥，打开记事本复制内容到下图（配置好后，github会给你发电子邮件）

![image-20240127160036193](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240127160036193.png) 

##### 2.网络连接问题

ping github.com时，会显示超时，这就是网络连接问题。通过ip查询https://ipaddress.com/website/github.com找到github.com的ip地址，例如（140.82.113.4）

![image-20240127160751778](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240127160751778.png)

此时修改本地 DNS 文件 C:\Windows\System32\drivers\etc 目录下的 hosts 文件，由于该文件在 C 盘中，无法直接打开进行修改，需要使用管理员权限，此处操作方式为，搜索 记事本 软件，右键以管理员身份运行，选择上述 hosts 文件打开，在文件内容最下方加入一行

```
140.82.113.4    github.com
```

## Node.js

定义：node.js是一个开源的，跨平台的JavaScript运行环境

安装：https://blog.csdn.net/zxy15974062965/article/details/121117803

### 包管理工具

包：package，代表了一组功能的源码集合

包管理工具：管理【包】的应用软件，进行下载安装、更新、删除操作

#### npm

npm全称node package Manage【node的包管理工具】

npm是node.js官方**内置的**包管理工具

##### npm 全局安装 ：

```
npm i -g <包名>

npm root -g
```

全局安装的命令不受工作目录位置的影响，**而且安装的位置不是在当前工作目录的node_module，而是在全局安装包的位置**，可以通过**npm root -g** 可以查看全局安装包的位置；而且并不是所有包都适合全局安装。

##### **windows会对全局安装的脚本进行约束，不让它运行？**

可以通过修改windows的执行策略来解决这个问题，具体：输入：set-ExecutionPolicy remoteSigned

![image-20240201094202340](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240201094202340.png)

##### **npm 安装所有依赖**：

```
npm i
npm install
```

通过该命令可以依据package.json和package-lock.json的依赖声明，安装项目所有依赖（**node-modules文件夹大多数情况是不会存入版本库的**），只有安装完所有依赖才能够正常启动项目

##### 安装指定版本的包：

```
npm i <包名@版本号>
例子：
npm i jquery@1.11.2
```

##### 删除依赖：

```
局部删除：
npm remove unip
全局删除：
npm remove -g nodemon
```

##### npm 配置命名别名：

可以通过命名别名可以更简单的执行命令，具体来说，配置package.json中的scripts属性

![image-20240201100222985](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240201100222985.png)

##### cnpm：

cnpm是淘宝构建的npmjs.com的完整镜像，也称为**淘宝镜像**，cnpm服务部署在国内阿里云服务器上，可以提高包的下载速度。

**淘宝镜像源官网：**https://www.npmmirror.com/，这里可以获得第一手的镜像网站

**官方也提供了一个全局工具包cnpm**（不是内置的），操作命令与npm大体相同。

**安装cnpm：**

```
npm install -g cnpm --registry=https://registry.npmmirror.com
```

##### npm配置淘宝镜像：

npm 也可以使用淘宝镜像源，直接配置：



```
 npm config set registry https://registry.npmmirror.com

在配置之前，先 npm config list查看，并保存一下原来的registry，方便后面改回来
"https://registry.npmjs.org/"这是npm原有的数源
```

**使用了淘宝镜像源之后，就不要搭梯子了，关掉梯子，yarn才能正常运行。**

#### Yarn

介绍：yarn是由Facebook推出的JavaScript包管理工具

特点：速度超快，会缓存包，所以下次下载无需重复下载。并行下载

安装：

```
npm i -g yarn
```

##### yarn常用命令

![image-20240201103854636](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240201103854636.png)

##### yarn全局安装

查询 yarn 安装依赖的全局路径 

```
yarn global bin
```

修改 yarn 全局 bin 位置 ，这个就是yarn之后安装全局依赖的位置，**但是注意，要修改环境变量，才能使yarn全局安装的包正常运行**

```
yarn config set prefix "D:\nodejs\node_modules\yarn\bin"
```

##### yarn配置淘宝镜像

```
yarn config set registry https://registry.npmmirror.com

在配置之前，先 yarn config list查看，并保存一下原来的registry，方便后面改回来
```

**使用了淘宝镜像源之后，就不要搭梯子了，关掉梯子，yarn才能正常运行。**

## React



## VScode使用

##### VScode怎么运行js文件？

+ **使用内置终端**

  首先，我们需要打开一个JS文件，然后按下“Ctrl+Shift+`”键，打开终端界面，可以在其中输入“**node 文件名.js**”命令来运行JS文件。

+ **使用Code Runner插件**

​	安装Code Runner插件，打开一个JS文件，然后按下**“Ctrl+Alt+N”键**，Code Runner会自动运行当前打开的JS文件，并在底部显示输出结果。

+ **使用Live Server插件**

​	在VSCode中安装Live Server插件，打开一个HTML文件，然后按下**“Alt+L”键**，此时，Live Server会自动启动一个本地服务器，并在浏览器中打开我们的HTML文件。如果HTML文件中引用了JS文件，Live Server也会自动运行这些JS文件。

##### VScode怎样调试js文件？

1. 首先要加断点

   ![image-20240117163505090](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117163505090.png) 

2. 点击JavaScript调试终端

   ![image-20240117163526777](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117163526777.png) 

3. 在终端里面输入node 文件名.js，回车

​	![image-20240117163613470](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117163613470.png) 

4. 在左侧进行调试

​	<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117163831404.png" alt="image-20240117163831404" style="zoom:50%;" /> 

## 项目笔记

### VForm表单自定义组件创建

1. **创建组件**，在src/components/form-designer/form-widget/field-widget中，注意文件名和name属性的键值相对应

![image-20240117183611890](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117183611890.png) 

```vue
<template>
	<container-wrapper :designer="designer" :widget="widget" :parent-widget="parentWidget" :parent-list="parentList"
					   :index-of-parent-list="indexOfParentList">
		<div :key="widget.id" class="tree-container"
			 :class="{'selected': selected}" @click.stop="selectWidget(widget)">
			<el-input v-if="widget.options.filter" v-model="filterText" placeholder="输入关键字进行过滤"/>
			<el-row class="padding5-top-bottom" v-if="widget.options.expandRetractAllNode || widget.options.selectClearAllNode">
				<el-col>
					<el-button-group>
						<el-button v-if="widget.options.expandRetractAllNode" type="primary" plain round @click="expandAll">展开/收缩</el-button>
						<el-button v-if="widget.options.selectClearAllNode" type="primary" plain round @click="selectAll">选中/取消选中</el-button>
					</el-button-group>
				</el-col>
			</el-row>
			<el-tree
				ref="tree"
				node-key="id"
				:props="defaultProps"
				:data="widget.options.treeData"
				:show-checkbox="widget.options.showCheckBox"
				:default-expand-all="widget.options.defaultExpandAllNode"
				:expand-on-click-node="widget.options.expandOnClickNode"
				:draggable="widget.options.draggable"
				:filter-node-method="filterNode"
				@node-click="handleTreeNodeClick"
				@check="handleTreeNodeCheck"
				@node-contextmenu="handleTreeContextmenu"
				@check-change="handleTreeCheckChange"
			>
				<template #default="{ node, data }">
					<span class="custom-tree-node">
						  <span>{{ node.label }}</span>
						  <span v-if="widget.options.nodeEdit">
							  <el-button size="small" type="primary" link @click.stop="handleAppend(data)">添加</el-button>
							  <el-button size="small" type="primary" link @click.stop="handleRemove(node, data)">删除</el-button>
						  </span>
					</span>
				</template>
			</el-tree>
		</div>
	</container-wrapper>
</template>

<script>
import i18n from "@/utils/i18n";
import containerMixin from "@/components/form-designer/form-widget/container-widget/containerMixin";
import refMixinDesign from "@/components/form-designer/refMixinDesign";
import ContainerWrapper from "@/components/form-designer/form-widget/container-widget/container-wrapper.vue";
import FieldComponents from "@/components/form-designer/form-widget/field-widget";
import {toRaw} from "vue";
import {treeToArray} from "@/utils/util";

export default {
	name: "tree-widget",
	componentName: 'ContainerWidget',
	mixins: [i18n, containerMixin, refMixinDesign],
	inject: ['refList'],
	components: {
		ContainerWrapper,
		...FieldComponents,
	},
	props: {
		widget: Object,
		parentWidget: Object,
		parentList: Array,
		indexOfParentList: Number,
		designer: Object,
	},
	data() {
		return {
			filterText: '',
			isExpanded: true,
			isChecked: false,
			defaultProps: {
				children: 'children',
				label: 'label'
			},
			id: 1000
		}
	},
	computed: {
		selected() {
			return this.widget.id === this.designer.selectedId
		},

		customClass() {
			return this.widget.options.customClass || ''
		},
	},
	watch: {
		filterText(val) {
			this.$refs.tree.filter(val)
		}
	},
	methods: {
		filterNode(value, data) {
			if (!value) return true
			return data.label.includes(value)
		},
		expandAll() {
			this.isExpanded =!this.isExpanded
			const list = treeToArray(toRaw(this.widget.options.treeData));
			list.forEach((item, index) => {
				this.$refs.tree.store.nodesMap[list[index].id].expanded = this.isExpanded;
			})
		},
		selectAll() {
			this.isChecked =!this.isChecked
			const list = toRaw(this.widget.options.treeData);
			this.$refs.tree.setCheckedNodes(this.isChecked ? list : [])
		},
		handleRemove(node, data) {
			const parent = node.parent
			const children = parent.data.children || parent.data
			const index = children.findIndex((d) => d.id === data.id)
			children.splice(index, 1)
			this.widget.options.treeData = [...this.widget.options.treeData]
		},
		handleAppend(data) {
			const newChild = { id: this.id++, label: 'testNode', children: [] }
			if (!data.children) {
				data.children = []
			}
			data.children.push(newChild)
			this.widget.options.treeData = [...this.widget.options.treeData]
		}
	}
}
</script>

<style lang="scss" scoped>
div.tree-container {
	padding: 5px;
	border: 1px dashed #336699;
	box-sizing: border-box;
}

.tree-container.selected {
	outline: 2px solid $--color-primary !important;
}
.custom-tree-node {
	flex: 1;
	display: flex;
	align-items: center;
	justify-content: space-between;
	font-size: 14px;
	padding-right: 8px;
}
</style>

```

2. **配置组件参数**，在src/components/form-designer/widget-panel/widgetsConfig.js中，主要有三个基础的数组（containers，basicFields，advancedFields），我们的组件参数放到basicFields中

![image-20240117184232396](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117184232396.png) 

```js
{
        type: "tree",
        icon: "tree",
        category: "container",
        widgetList: [],
        options: {
            name: "tree42275",
            label: "tree",
            size: "default",
            disabled: false,
            hidden: false,
            parentChildLinkAble: true,
            customClass: [],
            dsEnabled: false,
            dsName: "",
            dataSetName: "",
            showCheckBox: true,
            filter: true,
            defaultExpandAllNode: true,
            expandRetractAllNode: true,
            selectClearAllNode: true,
            expandOnClickNode: true,
            nodeEdit: true,
            draggable: false,
            lazy: false,
            treeDataEdit: true,
            onCreated: "",
            onMounted: "",
            onNodeClick: "",
            onNodeCheck: "",
            onNodeContextmenu: "",
            onCheckChange: "",
            treeData: [
                {
                    id: 1,
                    label: "一级 1",
                    children: [
                        {
                            id: 2,
                            label: "二级 1-1",
                            children: [
                                {
                                    id: 3,
                                    label: "三级 1-1-1"
                                }
                            ]
                        }
                    ]
                },
                {
                    id: 4,
                    label: "一级 2",
                    children: [
                        {
                            id: 5,
                            label: "二级 2-1",
                            children: [
                                {
                                    id: 6,
                                    label: "三级 2-1-1"
                                }
                            ]
                        },
                        {
                            id: 7,
                            label: "二级 2-2",
                            children: [
                                {
                                    id: 8,
                                    label: "三级 2-2-1"
                                }
                            ]
                        }
                    ]
                },
                {
                    id: 9,
                    label: "一级 3",
                    children: [
                        {
                            id: 10,
                            label: "二级 3-1",
                            children: [
                                {
                                    id: 11,
                                    label: "三级 3-1-1"
                                }
                            ]
                        },
                        {
                            id: 12,
                            label: "二级 3-2",
                            children: [
                                {
                                    id: '3-2-1',
                                    label: "三级 3-2-1"
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    }

```

3. 设置中文映射，目的是把名称添加到组件上去，在src/lang/zh-CN.js中，**designer——>widgetLabel——>tree:           '树',**这里的tree要与第一步中的name属性值相对应（tree-widget——>tree）

![image-20240117185905735](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117185905735.png)

经过以上三步就可以简单创建一个VForm的自定义属性“树”，组件的样式基于第二步配置的组件参数

![image-20240117190327017](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117190327017.png) 

### 留言板项目：

![image-20240126133325443](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240126133325443.png)

1、在设置点赞的时候，你要用到<button onclick="点赞函数（this）">，这里面的this就是button按钮本身，通过**this.parentNode**,来访问到父级的容器节点，通过在**父级的容器节点.querySelect("点赞数")**，来获取到点赞按钮对应的点赞数。

2、设置了每一次在刷新或是发布评论时，随机更换头像。

### todolist项目：

要求：用前端三件套去实现todolist的基本功能，并结合git实现版本管理

成果图：

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E6%88%90%E6%9E%9C1.png" alt="image-20240128113121971" style="zoom: 80%;" /> 

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E6%88%90%E6%9E%9C2.png" alt="image-20240128113225760" style="zoom:80%;" /> 

心得：

1. 对于每一项任务的删除或完成操作，借鉴了留言板项目的点赞功能，通过this.parentNode找到父级容器，然后运用node.remove()操作进行删除操作
2. 批量操作师根据复选框的checked属性进行if判断的，勾选则checked属性为true，用forEach进行批量操作
3. 不完善的点，每一次计算待办任务和已完成任务的数量，都要重新计算类数组的长度，我觉得可以用监听来实现这一点，只要类数组的长度有变化，就会立即更新待办任务和已完成任务的数量，而不用在每一个需要删除和完成操作的函数最后面进行更新

### 用户中心项目：

完整了解做项目的思路，接触一些企业级的开发技术（尽量少写代码）

#### 企业做项目流程

需求分析=>设计（概要设计，详细设计）=> 技术选型=>初始化项目/引入需要的技术=>写Demo=>写代码（实现业务逻辑）=>测试（单元测试）=>代码提交/代码评审=>部署=>发布

#### 需求分析

1. 登录/注册

2. 数据库设计：

   id（主键）bigint

   username 昵称 varchar

   userAccount 登录账号 

   avatarUrl 头像 varchar

   gender 性别 tinyint

   userPassword 密码 varchar

   phone 电话 varchar

   email 邮箱 varchar

   isValid 是否有效 (比如被封号)tinyint 0 1

   ------

   createTime 创建时间（数据插入时间）datetime

   updateTime 更新时间（数据更新时间）datetime

   isDelete 是否删除0 1（逻辑删除）tinyint

3. 用户管理（仅管理员可见）对用户的查询、修改

4. 用户校验（仅星球用户）

   

   

#### 技术选型

前端：三件套+React+组件库Ant Design+Umi+Ant Design Pro（现成的管理系统）

后端：java + spring + springmvc + mybatis + mybatis-plus+springboot+mysql

部署：服务器+容器（平台）

#### 计划

1. 初始化项目
   1. 前端初始化
      1. 初始化项目
      2. 引入一些组件
      3. 框架介绍/项目瘦身
   2. 后端初始化
      1. 准备环境（MySql之类的）
      2. 引入框架（整合框架）
2. 登录/注册
   1. 前端
   2. 后端
3. 用户管理（仅管理员可见）
   1. 前端
   2. 后端

#### 注册逻辑

1. 用户在前端输入账号和密码，以及校验码
2. 校验用户的账户、密码、验证密码是否符合要求
   1. 非空
   2. 账户的话**不小于**4位
   3. 密码**不小于**8位
   4. 账户不能重复
   5. 账户不包含特殊字符
   6. 密码和验证密码相同
3. 对密码进行加密（密码千万不能直接以明文储存到数据库中）
4. 向数据库插入用户数据

#### 登录接口

接受参数： 用户账户、密码

请求类型：POST

请求体：JSON格式的数据

> 请求参数很长时，不建议用get

返回值：用户信息（**脱敏**） 

#### 登录逻辑

1. 校验用户账户密码是否合法 
   1. 非空
   2. 账户的话**不小于**4位
   3. 密码**不小于**8位
   4. 账户不包含特殊字符
2. 校验密码是否输入正确，要和数据库中的密文密码去比对
3. 返回用户信息（脱敏），隐藏敏感信息，防止数据库中的字段泄露
4. 记录用户的登录态（session），将其存到服务器上（用后端springboot框架封装的服务器tomcat去记录）
5. 返回脱敏后的用户信息

#### 用户管理接口

！！！必须鉴权

1. 查询用户
   1. 允许根据用户名查询
2. 删除用户

#### 如何知道那个用户登录了？（javaweb）

1. 连接服务器端后，得到一个session状态（匿名会话），返回给前端

2. 登陆成功后，得到一个登录成功的session，并给该session设置一些值，比如说用户信息，返回给前端一个设置cookie的命令。

   **session => cookie **

3. 前端接受到后端命令后，奢姿cookie，保存到浏览器内

4. 前端再次请求后端的时候（相同的域名），在请求头带上cookie去请求

5. 后端拿到前端传来的cookie，找到对应的session

6. 后端从session中可以取出基于该session存储的变量（用户的登录信息、登录名）


#### 前后端交互

前端需要向后端发送请求

前端ajax来请求后端

axious封装了ajax

request是ant design项目有封装了一次

#### 代理

正向代理：替客户端向服务器发送请求，

反向代理：替服务器接受请求，

怎么搞代理？

Nginx服务器

node.js服务器

![image-20240207144306714](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240207144306714.png)

#### 问题解决：

1. 前端初始化，在使用官网命令时，没有umi3选项？

   在cmd输入yarn global add create-umi@0.27.0，建个myapp文件夹，在这个文件夹的cmd下输入create-umi。如果在输入create-umi显示是外部命令（这是yarn的小毛病，yarn全局安装的包确实用不了），需要先**yarn global bin**找到yarn的bin目录，然后再把此目录添加进环境变量。

   总结：没有使用官方的命令，而是通过全局下载的create-umi



2. 前端初始化，yarn global add create-umi@0.27.0网络一直ping不通报？

   yarn和npm一样都可以配置淘宝镜像源，配置之后可以通过yarn config list检查。配置成功之后要关掉梯子。



3. 后端初始化，在配置java版本时，最低也只能到java17版本，需要java8？

   原因是springboot官方停止了对springboot2的维护，解决办法就是在IDEA里更改Server URL即可，用阿里云的镜像。

![image-20240202090502436](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240202090502436.png)

4. 连接数据库时，mysql连接不了，经过查找发现是Mysql服务无法启动的问题？

![image-20240202094357389](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240202094357389.png)

![image-20240202100104008](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240202100104008.png) 

直接专业卸载

5. 打开金师播放器后，复制粘连键用不了了？

   win + r 打开命令框，输入 cmd.exe /c echo off | clip （每次打开播放器观看都需要输入）

#### 
