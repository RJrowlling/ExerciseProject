# 后端笔记

## Java SE



## Java并发编程



## JVM



## Java EE



## Spring Framework



## SpringMVC



## SpringBoot



## MyBatis



## MySql原理

### 逻辑架构

#### 一条SQL语句的执行过程

学习 SQL 的时候，第一个先学到的就是 select 查询语句了，比如下面这句查询语句：

```sql
// 在 product 表中，查询 id = 1 的记录
select * from product where id = 1;
```

但是有没有想过，**MySQL 执行一条 select 查询语句，在 MySQL 中期间发生了什么？**

带着这个问题，我们可以很好的了解 MySQL 内部的架构

##### MySQL 执行流程

先来一个上帝视角图，下面就是 MySQL 执行一条 SQL 查询语句的流程，也从图中可以看到 MySQL 内部架构里的各个功能模块。

![image-20240430175100538](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240430175100538.png) 

可以看到， MySQL 的架构共分为两层：**Server 层和存储引擎层**，

- **Server 层负责建立连接、分析和执行 SQL**。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。另外，所有的内置函数（如日期、时间、数学和加密函数等）和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。
- **存储引擎层负责数据的存储和提取**。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从  MySQL 5.5 版本开始， InnoDB 成为了 MySQL  的默认存储引擎。我们常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。

##### 第一步：连接器

如果你在 Linux 操作系统里要使用 MySQL，那你第一步肯定是要先连接 MySQL 服务，然后才能执行 SQL 语句，普遍我们都是使用下面这条命令进行连接：

```shell
# -h 指定 MySQL 服务得 IP 地址，如果是连接本地的 MySQL服务，可以不用这个参数；
# -u 指定用户名，管理员角色名为 root；
# -p 指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里面输入密码
mysql -h$ip -u$user -p
```

连接的过程需要先经过 TCP 三次握手，因为 MySQL 是基于 TCP 协议进行传输的，如果 MySQL 服务并没有启动，则会收到如下的报错：

![image-20240430175432200](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240430175432200.png) 

如果  MySQL 服务正常运行，完成 TCP 连接的建立后，连接器就要开始验证你的用户名和密码，如果用户名或密码不对，就收到一个"Access denied for user"的错误，然后客户端程序结束执行。

![image-20240430175444120](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240430175444120.png)

如果用户密码都没有问题，连接器就会获取该用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断。

所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。

**简单总结一下：**

- 与客户端进行 TCP 三次握手建立连接；
- 校验客户端的用户名和密码，如果用户名或密码不对，则会报错；
- 如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；

**如何查看 MySQL 服务被多少个客户端连接了？**

如果你想知道当前  MySQL 服务被多少个客户端连接了，你可以执行 `show processlist` 命令进行查看。

![image-20240430175618144](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240430175618144.png) 

比如上图的显示结果，共有两个用户名为 root 的用户连接了 MySQL 服务，其中 id 为 6 的用户的 Command 列的状态为 `Sleep` ，这意味着该用户连接完 MySQL 服务就没有再执行过任何命令，也就是说这是一个空闲的连接，并且空闲的时长是 736 秒（ Time 列）。

**空闲连接会一直占用着吗？**

当然不是了，MySQL 定义了空闲连接的最大空闲时长，由 `wait_timeout` 参数控制的，默认值是 8 小时（28880秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。

```sql
ysql> show variables like 'wait_timeout';
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| wait_timeout  | 28800 |
+---------------+-------+
1 row in set (0.00 sec)
```

当然，我们自己也可以手动断开空闲的连接，使用的是 kill connection + id 的命令。

```sql
mysql> kill connection +6;
Query OK, 0 rows affected (0.00 sec)
```

一个处于空闲状态的连接被服务端主动断开后，这个客户端并不会马上知道，等到客户端在发起下一个请求的时候，才会收到这样的报错“ERROR 2013 (HY000): Lost connection to MySQL server during query”。

**MySQL 的连接数有限制吗？**

MySQL 服务支持的最大连接数由 max_connections 参数控制，比如我的 MySQL 服务默认是 151 个,超过这个值，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。

```sql
mysql> show variables like 'max_connections';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| max_connections | 151   |
+-----------------+-------+
1 row in set (0.00 sec)
```

**短连接和长连接：**

MySQL 的连接也跟 HTTP 一样，有短连接和长连接的概念，它们的区别如下：

```c
// 短连接
连接 mysql 服务（TCP 三次握手）
执行sql
断开 mysql 服务（TCP 四次挥手）

// 长连接
连接 mysql 服务（TCP 三次握手）
执行sql
执行sql
执行sql
....
断开 mysql 服务（TCP 四次挥手）
```

可以看到，使用长连接的好处就是可以减少建立连接和断开连接的过程，所以一般是推荐使用长连接。

但是，使用长连接后可能会占用内存增多，因为 MySQL  在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。如果长连接累计很多，将导致 MySQL  服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象。

**怎么解决长连接占用内存的问题？**

有两种解决方式。

第一种，**定期断开长连接**。既然断开连接后就会释放连接占用的内存资源，那么我们可以定期断开长连接。

第二种，**客户端主动重置连接**。MySQL 5.7 版本实现了 `mysql_reset_connection()` 函数的接口，注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。

##### 第二步：查询缓存

连接器得工作完成后，客户端就可以向 MySQL 服务发送 SQL 语句了，MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段，看看是什么类型的语句。

如果 SQL 是查询语句（select 语句），MySQL 就会先去查询缓存（ Query Cache  ）里查找缓存数据，看看之前有没有执行过这一条命令，**这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL  查询语句，value 为 SQL 语句查询的结果**。

如果查询的语句命中查询缓存，那么就会直接返回 value 给客户端。如果查询的语句没有命中查询缓存中，那么就要往下继续执行，等执行完后，查询的结果就会被存入查询缓存中。

这么看，查询缓存还挺有用，但是其实**查询缓存挺鸡肋**的。

对于更新比较频繁的表，查询缓存的命中率很低的，**因为只要一个表有更新操作，那么这个表的查询缓存就会被清空**。如果刚缓存了一个查询结果很大的数据，还没被使用的时候，刚好这个表有更新操作，查询缓冲就被清空了，相当于缓存了个寂寞。

所以，MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了。

对于 MySQL 8.0 之前的版本，如果想关闭查询缓存，我们可以通过将参数 query_cache_type 设置成 DEMAND。

##### 第三步：解析 SQL

在正式执行 SQL 查询语句之前， MySQL 会先对 SQL 语句做解析，这个工作交由「解析器」来完成。

解析器会做如下两件事情。

第一件事情，**词法分析**。MySQL 会**根据你输入的字符串识别出关键字出来**，例如，SQL语句 select username from userinfo，在分析之后，会得到4个Token，其中有2个Keyword，分别为select和from：

| 关键字 | 非关键字 | 关键字 | 非关键字 |
| ------ | -------- | ------ | -------- |
| select | username | from   | userinfo |

第二件事情，**语法分析**。根据词法分析的结果，语法解析器会**根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法**，如果没问题就会构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。

![image-20240430192221292](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240430192221292.png) 

如果我们输入的 SQL 语句语法不对，就会在解析器这个阶段报错。比如，我下面这条查询语句，把 from 写成了 form，这时 MySQL 解析器就会给报错。

![image-20240430192303201](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240430192303201.png) 

**但是注意，表不存在或者字段不存在，并不是在解析器里做的，《MySQL 45 讲》说是在解析器做的，但是经过我和朋友看 MySQL 源码（5.7和8.0）得出结论是解析器只负责检查语法和构建语法树，但是不会去查表或者字段存不存在。**

那到底谁来做检测表和字段是否存在的工作呢？别急，接下来就是了。

##### 第四步：执行 SQL

经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条`SELECT` 查询语句流程主要可以分为下面这三个阶段：

- prepare 阶段，也就是**预处理阶段；**
- optimize 阶段，也就是**优化阶段；**
- execute 阶段，也就是**执行阶段；**

###### 预处理器

我们先来说说预处理阶段做了什么事情。

- 检查 SQL 查询语句中的表或者字段是否存在；
- 将 `select *` 中的 `*` 符号，扩展为表上的所有列；

我下面这条查询语句，test 这张表是不存在的，这时 MySQL 就会在执行 SQL 查询语句的 prepare 阶段中报错。

```sql
mysql> select * from test;
ERROR 1146 (42S02): Table 'mysql.test' doesn't exist
```

###### 优化器

经过预处理阶段后，还需要为 SQL 查询语句先制定一个执行计划，这个工作交由「优化器」来完成的。

**优化器主要负责将 SQL 查询语句的执行方案确定下来**，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。

当然，我们本次的查询语句（select * from product where id = 1）很简单，就是选择使用**主键索引。**

要想知道优化器选择了哪个索引，我们可以在查询语句最前面加个 `explain` 命令，这样就会输出这条 SQL 语句的执行计划，然后执行计划中的 key 就表示执行过程中使用了哪个索引，比如下图的 key 为 `PRIMARY` 就是使用了主键索引。

![image-20240430192706920](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240430192706920.png) 

如果查询语句的执行计划里的 key 为 null 说明没有使用索引，那就会全表扫描（type = ALL），这种查询扫描的方式是效率最低档次的，如下图：

![image-20240430192727139](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240430192727139.png) 

这张 product 表只有一个索引就是主键，现在我在表中将 name 设置为普通索引（二级索引）。

![image-20240430192815458](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240430192815458.png) 

这时 product 表就有主键索引（id）和普通索引（name）。假设执行了这条查询语句：

```sql
select id from product where id > 1  and name like 'i%';
```

**这条查询语句的结果既可以使用主键索引，也可以使用普通索引，但是执行的效率会不同。这时，就需要优化器来决定使用哪个索引了**。

很显然这条查询语句是**覆盖索引**，直接在二级索引就能查找到结果（因为二级索引的 B+ 树的叶子节点的数据存储的是主键值），就没必要在主键索引查找了，因为查询主键索引的 B+ 树的成本会比查询二级索引的 B+ 的成本大，优化器基于查询成本的考虑，会选择查询代价小的普通索引。

在下图中执行计划，我们可以看到，执行过程中使用了普通索引（name），Exta 为 Using index，这就是表明使用了覆盖索引优化。

![image-20240430193010010](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240430193010010.png)

###### 执行器

经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。

接下来，用三种方式执行过程，跟大家说一下执行器和存储引擎的交互过程。

- 主键索引查询
- 全表扫描
- 索引下推

**主键索引查询**：

以本文开头查询语句为例，看看执行器是怎么工作的。

```sql
select * from product where id = 1;
```

这条查询语句的查询条件用到了主键索引，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，**所以优化器决定选用访问类型为 const 进行查询**，也就是使用主键索引查询一条记录，那么执行器与存储引擎的执行流程是这样的：

- 执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 `id = 1` 交给存储引擎，**让存储引擎定位符合条件的第一条记录**。
- 存储引擎通过主键索引的 B+ 树结构定位到 id = 1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；
- 执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。
- 执行器查询的过程是一个 while 循环，所以还会再查一次，**但是这次因为不是第一次查询了，所以会调用 read_record  函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1  的函数**，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。

至此，这个语句就执行完成了。

**全表扫描：**

举个全表扫描的例子：

```text
select * from product where name = 'iphone';
```

这条查询语句的查询条件没有用到索引，所以优化器决定选用**访问类型为 ALL** 进行查询，也就是全表扫描的方式查询，那么这时执行器与存储引擎的执行流程是这样的：

- 执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，**让存储引擎读取表中的第一条记录**；
- 执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；如果是则将记录发给客户的（是的没错，Server  层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）。
- 执行器查询的过程是一个 while 循环，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为  all，read_record 函数指针指向的还是 InnoDB  引擎全扫描的接口，所以接着向存储引擎层要求继续读刚才那条记录的下一条记录，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；
- 一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server层） 返回了读取完毕的信息；
- 执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。

至此，这个语句就执行完成了。

**索引下推：**

在这部分非常适合讲索引下推（MySQL 5.6 推出的查询优化策略），这样大家能清楚的知道，「下推」这个动作，下推到了哪里。

索引下推能够减少**二级索引**在查询时的回表操作，提高查询的效率，因为它将 Server 层部分负责的事情，交给存储引擎层去处理了。

举一个具体的例子，方便大家理解，这里一张用户表如下，我对 age 和 reward 字段建立了**联合索引**（age，reward）：

![image-20240430193813305](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240430193813305.png) 

现在有下面这条查询语句：

```sql
select * from t_user  where age > 20 and reward = 100000;
```

联合索引当遇到范围查询 (>、<) 就会停止匹配，也就是 **age 字段能用到联合索引，但是 reward 字段则无法利用到索引**。

那么，不使用索引下推（MySQL 5.6 之前的版本）时，执行器与存储引擎的执行流程是这样的：

- Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age > 20 的第一条记录；
- 存储引擎根据二级索引的 B+ 树快速定位到这条记录后，获取主键值，然后**进行回表操作**，将完整的记录返回给 Server 层；
- Server 层在判断该记录的 reward 是否等于 100000，如果成立则将其发送给客户端；否则跳过该记录；
- 接着，继续向存储引擎索要下一条记录，存储引擎在二级索引定位到记录后，获取主键值，然后回表操作，将完整的记录返回给 Server 层；
- 如此往复，直到存储引擎把表中的所有记录读完。

可以看到，没有索引下推的时候，每查询到一条二级索引记录，都要进行回表操作，然后将记录返回给 Server，接着 Server 再判断该记录的 reward 是否等于 100000。

而使用索引下推后，判断记录的 reward 是否等于 100000 的工作交给了存储引擎层，过程如下 ：

- Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age > 20 的第一条记录；
- 存储引擎定位到二级索引后，**先不执行回表**操作，而是先判断一下该索引中包含的列（reward列）的条件（reward 是否等于 100000）是否成立。如果**条件不成立**，则直接**跳过该二级索引**。如果**成立**，则**执行回表**操作，将完成记录返回给 Server 层。
- Server 层在判断其他的查询条件（本次查询没有其他条件）是否成立，如果成立则将其发送给客户端；否则跳过该记录，然后向存储引擎索要下一条记录。
- 如此往复，直到存储引擎把表中的所有记录读完。

可以看到，使用了索引下推后，虽然 reward  列无法使用到联合索引，但是因为它包含在联合索引（age，reward）里，所以直接在存储引擎过滤出满足  reward = 100000  的记录后，才去执行回表操作获取整个记录。相比于没有使用索引下推，节省了很多回表操作。

当你发现执行计划里的 Extr 部分显示了 “Using index condition”，说明使用了索引下推。

![image-20240430194035466](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240430194035466.png)

##### 总结

执行一条 SQL 查询语句，期间发生了什么？

- 连接器：建立连接，管理连接、校验用户身份；
- 查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；
- 解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；
- 执行 SQL：执行 SQL 共有三个阶段：
  - 预处理阶段：检查表或字段是否存在；将 `select *` 中的 `*` 符号扩展为表上的所有列。
  - 优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；
  - 执行阶段：根据执行计划执行  SQL 查询语句，从存储引擎读取记录，返回给客户端；

#### 引擎分类

MySQL是一款支持拔插式引擎的数据库，在开发过程中你可以根据业务特性，从支持的诸多引擎中选择一款适合的，例如MyISAM、InnoDB、Merge、Memory(HEAP)、BDB(BerkeleyDB)、Example、Federated、Archive、CSV、Blackhole.....

![image-20240430194655276](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240430194655276.png)

不过虽然各款引擎都各有千秋，但其中最为常用的就只有`MyISAM、InnoDB`这两款引擎。

##### MyISAM引擎的背景

MyISAM引擎是MySQL官方基于早期的ISAM引擎改良而来的，它是一款“**苗根正红**”的引擎，由于其不错的性能表现，再加上丰富的特性支持（全文索引、压缩机制、空间索引/函数等），在MySQL5.5版本之前，也一直是MySQL默认的存储引擎。

MyISAM引擎整个实现都由官方一点点开发，甚至`MySQL-Server`中的不少功能都是为`MyISAM`而量身定制，其地位在MySQL体系中可以看成是“亲儿子”

##### InnoDB引擎的背景

`InnoDB`由`Innobase Oy`公司所开发，其创始人是`Heikki Tuuri`，提这个名字大家估计不太熟，但提另外一个名字大家绝对知道，也就是`Linux`操作系统之父`Linus`，`InnoDB`的创始人和他正是校友关系，总之最终在`2006.05`月也被甲骨文公司并购。

随着时间慢慢推移，`MySQL`官方渐渐有了“新欢”，开始主推使用`InnoDB`作为表的引擎，甚至到了`MySQL5.6`及以后版本中，直接用`InnoDB`代替了`MyISAM`

##### 磁盘文件的对比

`MyISAM、InnoDB`创建了两张表`zz_innodb_index、zz_myisam_index`，并且也从本地观察了两张表的磁盘文件，如下：

![image-20240430195244488](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240430195244488.png) 

其中使用`MyISAM`引擎的表：`zz_myisam_index`，会在本地生成三个磁盘文件：

- `zz_myisam_index.frm`：该文件中存储表的结构信息。
- `zz_myisam_index.MYD`：该文件中存储表的行数据。
- `zz_myisam_index.MYI`：该文件中存储表的索引数据。

从这里可得知一点：`MyISAM`引擎的表数据和索引数据，会分别放在两个不同的文件中存储。

而反观使用`InnoDB`引擎的表：`zz_innodb_index`，在磁盘中仅有两个文件：

- `zz_innodb_index.frm`：该文件中存储表的结构信息。
- `zz_innodb_index.ibd`：该文件中存储表的行数据和索引数据。

为啥要对比磁盘文件的区别呢？因为这点关乎着后续索引的支持性，咱们接着往下聊。

##### 索引支持的对比

因为`MyISAM`引擎在设计之初，会将表分为`.frm、.MYD、.MYI`三个文件放在磁盘存储，表数据和索引数据是分别放在`.MYD、.MYI`文件中，所以注定了`MyISAM`引擎只支持**非聚簇索引**。而`InnoDB`引擎的表数据、索引数据都放在`.ibd`文件中存储，因此`InnoDB`是支持**聚簇索引**的。

![image-20240430195456304](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240430195456304.png) 

聚簇索引的要求是：索引键和行数据必须在物理空间上也是连续的，而`MyISAM`表数据和索引数据，分别位于两个磁盘文件中，这也就注定了它无法满足聚簇索引的要求。

**一种引擎支不支持聚簇索引很重要，这涉及到了后面的很多技术实现，而`MyISAM`把表数据和索引数据分开存了，也就意味着`MyISAM`相较于`InnoDB`来说，这小子天生就带有缺陷~**

但不支持聚簇索引也有好处，也就是无论走任何索引，都只需要一遍查询即可获得数据，而`InnoDB`引擎的表中，如果不走聚簇（主键）索引查询数据，走其他索引的情况下，都需要经过两遍（回表）查询才能获得数据。

但这也不意味着`MyISAM`引擎查数据就比`InnoDB`快，如果看过《高性能MySQL》这本书的小伙伴，应该会知道在其中有一句话：“**不要轻易相信「MyISAM比InnoDB快」之类的经验之谈，这个结论往往不是绝对的**”。

##### 事务机制的对比

`InnoDB`引擎中有两个自己专享的日志，即`undo-log、redo-log`，先来说说`undo-log`日志，`InnoDB`在`MySQL`启动后，会在内存中构建一个`undo_log_buffer`缓冲区，同时在磁盘中也有相应的`undo-log`日志文件。

一条写入类型的`SQL`语句，在正式执行前都会先记录`redo-log、undo-log`日志，`undo-log`中会记录变更前的旧数据，当一个事务提交时，`MySQL`会正常的将数据落盘，而当一个事务碰到`rollback`命令需要回滚时，就会找到`undo-log`中记录的旧数据，接着用来覆盖变更过的新数据，以此做到将数据回滚到变更前的“样貌”。

一个引擎是否支持事务，这点尤为重要，因为业务开发过程中，咱们需要关注数据的安全性，拿最为经典的下单为例，用户把钱都付了，总不能由于程序`Bug`，然后不给用户新增订单、物流信息吧？再不济至少也要把钱退回给用户，因此就需要用到事务机制来保证原子性。

而`MyISAM`不支持事务，也就意味着当用户付钱之后，如果程序出现了异常，就会导致用户付的钱不会退回，订单信息也不会生成，因为程序都抛异常了，自然不会继续往下执行增加订单、物流信息的`SQL`语句。

##### 故障恢复的对比

前面简单的聊了`undo-log`日志，`InnoDB`借助它保证了事务的原子性，接着再来看看`redo-log`日志，`InnoDB`在启动时，同样会在内存中构建一个`redo_log_buffer`缓冲区，在磁盘中也会有相应的`redo-log`日志文件，所以当一条或多条`SQL`语句执行成功后，不论`MySQL`在何时宕机，只要这个事务提交了，`InnoDB`引擎都能确保该事务的数据不会丢失，也就以此保障了事务的持久性。

`InnoDB`引擎由于`redo-log`日志的存在，因此只要事务提交，机器断电、程序宕机等各种灾难情况，都可以用`redo-log`日志来恢复数据。但`MyISAM`引擎同样没有`redo-log`日志，所以并不支持数据的故障恢复，如果表是使用`MyISAM`引擎创建的，当一条`SQL`将数据写入到了缓冲区后，`SQL`还未被写到`bin-log`日志，此时机器断电、`DB`宕机了，重启之后由于数据在宕机前还未落盘，所以丢了也就无法找回。

从这一点来说，`MyISAM`并没有`InnoDB`引擎可靠，在`InnoDB`中只要事务提交，它就能确保数据永远不丢失，但`MyISAM`不行。这就好比咱们去银行存钱，去`InnoDB`银行存，你只需要把钱送到它那里，它就能确保你的财产安全，但如若去`MyISAM`银行存钱，你必须要把钱送到银行的保险库中才行，否则有可能会因为在送往保险库的过程中“丢失”财产。

##### 锁粒度的对比

锁的实现粒度其实跟索引有关，大家应该都知道，`MySQL`的存储引擎中，`MyISAM`仅支持表锁，而`InnoDB`同时支持表锁、行锁，但为啥`MyISAM`引擎不支持行锁呢？不是不想，而是做不到！还记得前面聊索引的那个对比项嘛？我说过：“`MyISAM`由于不支持聚簇索引，因此对比`InnoDB`来说，这小子天生存在缺陷”！为啥这样说呢，接着来展开聊一聊。

![image-20240430200130981](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240430200130981.png) 

上述这张学生表中，假设使用的是`MyISAM`引擎，同时对`student_id`字段建立了主键索引，`name`字段建立了普通索引，`sex、height`字段建立了联合索引，此时先不管索引合不合理，以目前情况为例，来推导一下`MyISAM`表为啥无法实现行锁。

这张表中存在三个索引，那在本地的`.MYI`索引文件中，肯定存在三颗`B+`树，同时由于`MyISAM`不支持聚簇索引，所以这三个索引是平级的，每棵`B+`树的索引键，都直接指向`.MYD`数据文件中的行数据地址。

**假设`MyISAM`要实现行锁，当要对一行数据加锁时，可以锁定一棵树中某一个数据，但无法锁定其他树的行数据**，啥意思呢？举个例子：

```sql
select * from zz_students where student_id = 1 for update;
```

这条`SQL`必然会走主键索引命中数据，那假设此时对主键索引树上，`ID=1`的数据加锁，接着再来看一种情况：

```sql
select * from zz_students where name = "竹子" for update;
```

此时这条`SQL`又会走`name`字段的普通索引查询数据，那此时又对普通索引树上的「竹子」数据加锁。

到这里，发现问题没有？上面的案例中，`MyISAM`如果想要实现行锁，就会遇到这个问题，基于不同索引查询数据时，可能会导致一行数据上加多个锁！这样又会导致多条线程同时操作一个数据，所以又会因为多线程并发执行的原因，造成脏读、幻读、不可重复读这系列问题出现。

但`InnoDB`引擎呢？因为支持聚簇索引，表中就算没有显式定义主键，内部依旧会用一个隐藏列来作为聚簇索引的索引字段，所以`InnoDB`表中的索引，是有主次之分的，所有的次级索引，其索引值都存储聚簇索引的索引键，因此想要对一行数据加锁时，只需要锁定聚簇索引的数据即可。

```sql
-- 通过主键索引查询数据
select * from zz_students where student_id = 1 for update;
-- 通过普通索引查询数据
select * from zz_students where name = "竹子" for update;
```

依旧是前面的这个例子，**通过主键索引查询的`SQL`语句，会直接定位到聚簇索引的数据**，然后对`ID=1`的数据加锁。**而第二条通过普通索引查询数据的`SQL`语句，经过查询后会得到一个值：`ID=1`，然后会拿着这个`ID=1`的值再去回表**，在聚簇索引中再次查询`ID=1`的数据，找到之后发现上面已经有线程加锁了，当前线程就会阻塞等待上一个线程释放锁。

因为`MyISAM`引擎不支持聚簇索引，所以无法实现行锁，出现多条线程同时读写数据时，只能锁住整张表。而`InnoDB`由于支持聚簇索引，每个索引最终都会指向聚簇索引中的索引键，因此出现并发事务时，`InnoDB`只需要锁住聚簇索引的数据即可，而不需要锁住整张表，因此并发性能更高。

##### 并发性能对比

`MyISAM`仅支持表锁，`InnoDB`同时支持表锁、行锁，由于这点原因，其实`InnoDB`引擎的并发支持性早已远超`MyISAM`了，毕竟锁的粒度越小，并发冲突的概率也就越低，因此并发支撑就越高。

但是`InnoDB`不仅仅只满足于此，为了提升读-写并存场景下的并发度，`InnoDB`引擎又基于`undo-log`日志的版本链+事务快照，又推出了`MVCC`多版本并发控制技术，因此对于读-写共存的场景支持并发执行。

但`MyISAM`只支持表锁，因此当一条`SQL`在写数据时，其他`SQL`就算是来读数据的，也需要阻塞等待，为啥呢？因为写数据时需要加排他锁，这是一种独占类型的锁，会排斥一切尝试获取锁的线程，反过来也是同理，当一条线程在读数据时，另一条线程来写数据，依旧会陷入阻塞等待，毕竟写数据要获取排他锁，也就意味着整张表只允许这一个线程操作。

##### 总结

经过上述的一系列对比后，对于为何使用`InnoDB`替换了`MyISAM`引擎的原因，相信各位小伙伴也能感受出来，这里就等价于稍微做个总结：

①存储方式：`MyISAM`引擎会将表数据和索引数据分成两个文件存储。

②索引支持：因为`MyISAM`引擎的表数据和索引数据是分开的，因此不支持聚簇索引。

③事务支持：由于`MyISAM`引擎没有`undo-log`日志，所以不支持多条`SQL`组成事务并回滚。

④故障恢复：`MyISAM`引擎依靠`bin-log`日志实现，`bin-log`中未写入的数据会永久丢失。

⑤锁粒度支持：因为`MyISAM`不支持聚簇索引，因此无法实现行锁，所有并发操作只能加表锁。

⑥并发性能：`MyISAM`引擎仅支持表锁，所以多条线程出现读-写并发场景时会阻塞。

⑦内存利用度：`MyISAM`引擎过于依赖`MySQL Server`，对缓冲池、异步`IO`技术开发度不够。

上述这些`MyISAM`不支持的，`InnoDB`引擎全都支持，也正由于这方方面面的原因，`InnoDB`引擎开始崭露锋芒，而作为`MySQL`亲生子的`MyISAM`自此之后跌落神坛，最终到了`MySQL5.6`版本时，`MyISAM`彻底让出了`MySQL`默认存储引擎的宝座。

最后，虽然`MySQL`的一个数据库中支持使用多种存储引擎，但也不要盲目使用，毕竟使用的存储引擎越多，对于每个引擎可分配的资源也就越少，拿典型的内存资源为例，如果一个库中使用了七八种引擎，那内存资源需要划分给这七八个引擎，这必然会导致各引擎之间相互影响，从而降低`MySQL`的整体吞吐量。

### InnoDB的存储引擎

#### 一行记录的存储过程

##### MySql数据的存放文件

大家都知道 MySQL 的数据都是保存在磁盘的，那具体是保存在哪个文件呢？

MySQL 存储的行为是由存储引擎实现的，MySQL 支持多种存储引擎，不同的存储引擎保存的文件自然也不同。

**InnoDB 是我们常用的存储引擎，也是 MySQL 默认的存储引擎**。所以，本文主要以 InnoDB 存储引擎展开讨论。

先来看看 MySQL 数据库的文件存放在哪个目录？

```sql
mysql> SHOW VARIABLES LIKE 'datadir';
```

![image-20240504133335852](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504133335852.png) 

比如，我这里有一个名为cjy 的 database，该 database 里有很多的 数据库表。

![image-20240504133441219](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504133441219.png) 

然后，我们进入这个目录，看看里面有什么文件？

![image-20240504133520009](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504133520009.png) 

- t_order.frm ，t_order 的**表结构**会保存在这个文件。在 MySQL 中建立一张表都会生成一个.frm 文件，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。
- **t_order.ibd**，t_order 的**表数据**会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以**存放在独占表空间文件**（文件名：表名字.ibd）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为  1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，**因此从这个版本之后，  MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件**。好了，现在我们知道了一张数据库表的数据是保存在「 表名字.ibd 」的文件里的，这个文件也称为独占表空间文件

##### 表空间文件的结构

**表空间由段（segment）、区（extent）、页（page）、行（row）组成**，InnoDB存储引擎的逻辑存储结构大致如下图：

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504133905244.png" alt="image-20240504133905244" style="zoom:80%;" /> 

###### 行（row）

数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。

###### 页（page）

记录是按照行来存储的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I/O 操作）只能处理一行数据，效率会非常低。

因此，**InnoDB 的数据是按「页」为单位来读写的**，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。

**默认每个页的大小为 16KB**，也就是最多能保证 16KB 的连续存储空间。

页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。

页的类型有很多，常见的有数据页、undo 日志页、溢出页等等。数据表中的行记录是用「数据页」来管理的，总之知道表中的记录存储在「数据页」里面就行。

###### 区（extent）

我们知道 InnoDB 存储引擎是用 **B+ 树**来组织数据的。

B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I/O，随机 I/O 是非常慢的。

解决这个问题也很简单，就是让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I/O 了，那么在范围查询（扫描叶子节点）的时候性能就会很高。

那具体怎么解决呢？

**在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是按照区（extent）为单位分配。每个区的大小为 1MB，对于  16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了**

###### 段（segment）

表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。

- 索引段：存放 B + 树的非叶子节点的区的集合；
- 数据段：存放 B + 树的叶子节点的区的集合；
- 回滚段：存放的是回滚数据的区的集合；

##### InnoDB 的行格式分类

行格式（row_format），就是一条记录的存储结构。

InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic和 Compressed 行格式。

- Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。
- 由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 Compact 行记录存储方式，Compact  是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 **MySQL 5.1 版本之后，行格式默认设置成 Compact**。
- Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 **MySQL5.7 版本之后，默认使用 Dynamic 行格式**。

Redundant 行格式我这里就不讲了，因为现在基本没人用了，这次**重点介绍 Compact 行格式**，因为 Dynamic 和 Compressed 这两个行格式跟 Compact 非常像。

##### Compact 行格式

![image-20240504134851874](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504134851874.png) 

可以看到，一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分。

**记录的额外信息**包含 3 个部分：**变长字段长度列表**、**NULL 值列表**、**记录头信息**。

###### 变长字段长度列表

varchar(n) 和 char(n) 的区别是什么，相信大家都非常清楚，char 是定长的，varchar 是变长的，变长字段实际存储的数据的长度（大小）不固定的。

所以，在存储数据的时候，也要把数据占用的大小存起来，存到「变长字段长度列表」里面，**读取数据的时候才能根据这个「变长字段长度列表」去读取对应长度的数据**。其他 TEXT、BLOB 等变长字段也是这么实现的。

为了展示「变长字段长度列表」具体是怎么保存「变长字段的真实数据占用的字节数」，我们先创建这样一张表，字符集是 ascii（所以每一个字符占用的 1 字节），行格式是 Compact，t_user 表中 name 和 phone 字段都是变长字段：

```sql
CREATE TABLE `t_user` (
  `id` int(11) NOT NULL,
  `name` VARCHAR(20) DEFAULT NULL,
  `phone` VARCHAR(20) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW_FORMAT = COMPACT;
```

![image-20240504135249077](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504135249077.png) 

接下来，我们看看看看这三条记录的行格式中的 「变长字段长度列表」是怎样存储的。

先来看第一条记录：

- name 列的值为 a，真实数据占用的字节数是 1 字节，十六进制 0x01；
- phone 列的值为 123，真实数据占用的字节数是 3 字节，十六进制 0x03；
- age 列和 id 列不是变长字段，所以这里不用管。

这些变长字段的真实数据占用的字节数会按照列的顺序**逆序存放**（等下会说为什么要这么设计），所以「变长字段长度列表」里的内容**是「 03 01」，而不是 「01 03」**。

![image-20240504135431106](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504135431106.png) 

同样的道理，我们也可以得出**第二条记录**的行格式中，「变长字段长度列表」里的内容是「 04 02」，如下图：

![image-20240504135459000](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504135459000.png) 

**第三条记录**中 phone 列的值是 NULL，**NULL 是不会存放在行格式中记录的真实数据部分里的**，所以「变长字段长度列表」里不需要保存值为  NULL 的变长字段的长度。

![image-20240504135518635](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504135518635.png) 

> 为什么「变长字段长度列表」的信息要按照逆序存放？
>
> 这个设计是有想法的，主要是因为「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。
>
> 「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以**使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率**。

> 每个数据库表的行格式都有「变长字段字节数列表」吗？
>
> 其实变长字段字节数列表不是必须的。
>
> **当数据表没有变长字段的时候，比如全部都是 int 类型的字段，这时候表里的行格式就不会有「变长字段长度列表」了**，因为没必要，不如去掉以节省空间。
>
> 所以「变长字段长度列表」只出现在数据表有变长字段的时候

###### NULL 值列表

表中的某些列可能会存储 NULL 值，如果把这些 NULL 值都放到记录的真实数据中会比较浪费空间，所以 Compact 行格式把这些值为 NULL 的列存储到 NULL值列表中。

如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。

- 二进制位的值为`1`时，代表该列的值为NULL。
- 二进制位的值为`0`时，代表该列的值不为NULL。

**另外，NULL 值列表必须用整数个字节的位表示（1字节8位），如果使用的二进制位个数不足整数个字节，则在字节的高位补 `0`。**

![image-20240504140054036](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504140054036.png) 

接下来，我们看看看看这三条记录的行格式中的 NULL 值列表是怎样存储的。

先来看**第一条记录**，第一条记录所有列都有值，不存在 NULL 值，所以用二进制来表示是酱紫的：

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504140121692.png" alt="image-20240504140121692" style="zoom:50%;" /> 

但是 InnoDB 是用整数字节的二进制位来表示 NULL 值列表的，现在不足 8 位，所以要在高位补 0，最终用二进制来表示是酱紫的：

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504140147691.png" alt="image-20240504140147691" style="zoom:50%;" /> 

所以，对于第一条数据，NULL 值列表用十六进制表示是 0x00。

接下来看**第二条记录**，第二条记录 age 列是 NULL 值，所以，对于第二条数据，NULL值列表用十六进制表示是 0x04。

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504140222203.png" alt="image-20240504140222203" style="zoom:50%;" /> 

最后**第三条记录**，第三条记录 phone 列 和 age 列是 NULL 值，所以，对于第三条数据，NULL 值列表用十六进制表示是 0x06。

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504140246052.png" alt="image-20240504140246052" style="zoom:50%;" /> 

我们把三条记录的 NULL 值列表都填充完毕后，它们的行格式是这样的：

![image-20240504140330562](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504140330562.png) 

> 每个数据库表的行格式都有「NULL 值列表」吗？
>
> NULL 值列表也不是必须的。
>
> **当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了**。
>
> 所以在设计数据库表的时候，通常都是建议将字段设置为  NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）。

> 「NULL 值列表」是固定 1 字节空间吗？如果这样的话，一条记录有 9 个字段值都是 NULL，这时候怎么表示？
>
> 「NULL 值列表」的空间不是固定 1 字节的。
>
> 当一条记录有 9 个字段值都是 NULL，那么就会创建 2 字节空间的「NULL 值列表」，以此类推

###### 记录头信息

记录头信息中包含的内容很多，我就不一一列举了，这里说几个比较重要的：

- delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。
- next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。
- record_type：表示当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录

###### 记录真实数据

**记录真实数据部分**除了我们定义的字段，还有三个隐藏字段，分别为：**row_id**、**trx_id**、**roll_pointe**r，我们来看下这三个字段是什么。

- row_id

如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段。row_id不是必需的，占用 6 个字节。

- trx_id

事务id，表示这个数据是由哪个事务生成的。 trx_id是必需的，占用 6 个字节。

- roll_pointer

这条记录上一个版本的指针。roll_pointer 是必需的，占用 7 个字节。

##### varchar(n)中n最大值

我们要清楚一点，**MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节**。

也就是说，一行记录除了 TEXT、BLOBs 类型的列，**限制最大为 65535 字节，注意是一行的总长度，不是一列**。

知道了这个前提之后，我们再来看看这个问题：「varchar(n) 中 n 最大取值为多少？」

varchar(n) 字段类型的 n 代表的是最多存储的字符数量，并不是字节大小哦。

要算 varchar(n) 最大能允许存储的字节数，还要看数据库表的字符集，因为字符集代表着，1个字符要占用多少字节，比如 ascii 字符集， 1 个字符占用 1 字节，那么  varchar(100) 意味着最大能允许存储 100 字节的数据

###### 单字段的情况

前面我们知道了，一行记录最大只能存储 65535 字节的数据。

那假设数据库表只有一个 varchar(n) 类型的列且字符集是 ascii，在这种情况下， varchar(n) 中 n 最大取值是 65535 吗？

不着急说结论，我们先来做个实验验证一下。

我们定义一个 varchar(65535) 类型的字段，字符集为 ascii 的数据库表。

```sql
CREATE TABLE test ( 
`name` VARCHAR(65535)  NULL
) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW_FORMAT = COMPACT;
```

看能不能成功创建一张表：

![image-20240504141249895](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504141249895.png) 

可以看到，创建失败了。

从报错信息就可以知道**一行数据的最大字节数是 65535（不包含 TEXT、BLOBs 这种大对象类型），其中包含了 storage overhead**。

问题来了，这个 storage overhead 是什么呢？其实就是「变长字段长度列表」和 「NULL 值列表」，也就是说**一行数据的最大字节数 65535，其实是包含「变长字段长度列表」和 「NULL 值列表」所占用的字节数的**。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去 storage overhead  占用的字节数。

这是因为我们存储字段类型为 varchar(n)  的数据时，其实分成了三个部分来存储：

- 真实数据
- 真实数据占用的字节数
- NULL 标识，如果不允许为NULL，这部分不需要

> 本次案例中，「NULL 值列表」所占用的字节数是多少？
>
> 前面我创建表的时候，字段是允许为 NULL 的，所以**会用 1 字节来表示「NULL 值列表」**。

> 本次案例中，「变长字段长度列表」所占用的字节数是多少？
>
> 「变长字段长度列表」所占用的字节数 = 所有「变长字段长度」占用的字节数之和。
>
> 所以，我们要先知道每个变长字段的「变长字段长度」需要用多少字节表示？具体情况分为：
>
> - 条件一：如果变长字段允许存储的最大字节数小于等于 255 字节，就会用 1 字节表示「变长字段长度」；
> - 条件二：如果变长字段允许存储的最大字节数大于 255 字节，就会用 2 字节表示「变长字段长度」；
>
> 我们这里字段类型是 varchar(65535) ，字符集是 ascii，所以代表着变长字段允许存储的最大字节数是 65535，符合条件二，所以会用 2 字节来表示「变长字段长度」。
>
> **因为我们这个案例是只有 1 个变长字段，所以「变长字段长度列表」= 1 个「变长字段长度」占用的字节数，也就是 2 字节**。

因为我们在算 varchar(n) 中 n 最大值时，需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。所以，**在数据库表只有一个 varchar(n)  字段且字符集是 ascii 的情况下，varchar(n) 中 n 最大值 =  65535 - 2 - 1 = 65532**。

我们先来测试看看  varchar(65532)  是否可行？

![image-20240504141845862](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504141845862.png))

可以看到，创建成功了。说明我们的推论是正确的，在算 varchar(n) 中 n 最大值时，需要减去 「变长字段长度列表」和 「NULL 值列表」所占用的字节数的。

当然，我上面这个例子是针对字符集为 ascii 情况，如果采用的是 UTF-8，varchar(n)  最多能存储的数据计算方式就不一样了：

- 在 UTF-8 字符集下，一个字符最多需要三个字节，varchar(n) 的 n 最大取值就是 65532/3 = 21844。

上面所说的只是针对于一个字段的计算方式

###### 多字段的情况

**如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 <= 65535**。

##### Compact行溢出

MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 `16KB`，也就是 `16384字节`，而一个 varchar(n)  类型的列最多可以存储 `65532字节`，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会**发生行溢出，多的数据就会存到另外的「溢出页」中**。

如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。在一般情况下，InnoDB 的数据都是存放在 「数据页」中。但是当发生行溢出时，溢出的数据会存放到「溢出页」中。

当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。大致如下图所示。

![image-20240504142104970](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504142104970.png) 

上面这个是 Compact 行格式在发生行溢出后的处理。

**Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时有些区别。**

这两种格式采用完全的行溢出方式，**记录的真实数据处不会存储该列的一部分数据**，**只存储 20 个字节的指针来指向溢出页**。而实际的数据都存储在溢出页中，看起来就像下面这样：

![image-20240504142140105](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504142140105.png) 

##### 总结

> MySQL 的 NULL 值是怎么存放的？

MySQL 的 Compact 行格式中会用「NULL值列表」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。

NULL值列表会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。

> MySQL 怎么知道 varchar(n) 实际占用数据的大小？

MySQL 的 Compact 行格式中会用「变长字段长度列表」存储变长字段实际占用的数据大小。

> varchar(n) 中 n 最大取值为多少？

一行记录最大能存储 65535 字节的数据，但是这个是包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数」。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去这两个列表所占用的字节数。

如果一张表只有一个 varchar(n)  字段，且允许为 NULL，字符集为 ascii。varchar(n) 中 n 最大取值为 65532。

计算公式：65535 - 变长字段字节数列表所占用的字节数 - NULL值列表所占用的字节数 = 65535 - 2 - 1 = 65532。

如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 <= 65535。

> 行溢出后，MySQL 是怎么处理的？

如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。

Compact 行格式针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。

Compressed 和 Dynamic 这两种格式采用完全的行溢出方式，记录的真实数据处不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页。而实际的数据都存储在溢出页中。

### 索引

#### 索引数据结构

##### 索引数据结构的选择

MySQL 的数据是持久化的，意味着数据（索引+记录）是保存到磁盘上的，因为这样即使设备断电了，数据也不会丢失

磁盘是一个慢的离谱的存储设备，有多离谱呢？

人家内存的访问速度是纳秒级别的，而磁盘访问的速度是毫秒级别的，也就是说读取同样大小的数据，磁盘中读取的速度比从内存中读取的速度要慢上万倍，甚至几十万倍。

磁盘读写的最小单位是**扇区**，扇区的大小只有 `512B` 大小，操作系统一次会读写多个扇区，所以**操作系统的最小读写单位是块（Block）。Linux 中的块大小为 `4KB`**，也就是一次磁盘  I/O 操作会直接读写 8 个扇区。

**由于数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I/O，而磁盘 I/O 次数越多，所消耗的时间也就越大。**

所以，我们希望索引的数据结构能在尽可能少的磁盘的 I/O 操作中完成查询工作，因为磁盘  I/O 操作越少，所消耗的时间也就越小。

另外，MySQL 是支持范围查找的，所以索引的数据结构不仅要能高效地查询某一个记录，而且也要能高效地执行范围查找。

所以，要设计一个适合 MySQL 索引的数据结构，至少满足以下要求：

- 能在尽可能少的磁盘的 I/O 操作中完成查询工作；
- 要能高效地查询某一个记录，也要能高效地执行范围查找；

分析完要求后，我们针对每一个数据结构分析一下。

##### 二分查找

索引数据最好能按顺序排列，这样可以使用「二分查找法」高效定位数据。

假设我们现在用数组来存储索引，比如下面有一个排序的数组，如果要从中找出数字 3，最简单办法就是从头依次遍历查询，这种方法的时间复杂度是 O(n)，查询效率并不高。因为该数组是有序的，所以我们可以采用二分查找法，比如下面这张采用二分法的查询过程图：

![image-20240504153645441](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504153645441.png) 

可以看到，**二分查找法每次都把查询的范围减半，这样时间复杂度就降到了 O(logn)**，**但是每次查找都需要不断计算中间位置**。

##### 二分查找树

用数组来实现线性排序的数据虽然简单好用，但是插入新元素的时候性能太低。

因为插入一个元素，需要将这个元素之后的所有元素后移一位，如果这个操作发生在磁盘中呢？这必然是灾难性的。因为磁盘的速度比内存慢几十万倍，所以我们不能用一种线性结构将磁盘排序。

其次，有序的数组在使用二分查找的时候，每次查找都要不断计算中间的位置。

那我们能不能设计一个非线形且天然适合二分查找的数据结构呢？

有的，请看下图这个神奇的操作，找到所有二分查找中用到的所有中间节点，把他们用指针连起来，并将最中间的节点作为根节点。

![49cb4df3fb7d4accbc75f6970ff1d0ea](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/49cb4df3fb7d4accbc75f6970ff1d0ea.webp) 

怎么样？是不是变成了二叉树，不过它不是普通的二叉树，它是一个**二叉查找树**。

**二叉查找树的特点是一个节点的左子树的所有节点都小于这个节点，右子树的所有节点都大于这个节点**，这样我们在查询数据时，不需要计算中间节点的位置了，只需将查找的数据与节点的数据进行比较。

假设，我们查找索引值为 key 的节点：

1. 如果 key 大于根节点，则在右子树中进行查找；
2. 如果 key 小于根节点，则在左子树中进行查找；
3. 如果 key 等于根节点，也就是找到了这个节点，返回根节点即可。

二叉查找树查找某个节点的动图演示如下，比如要查找节点 3 ：

![f3089bdfe1a795a8142d4442bdb1e9a7](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/f3089bdfe1a795a8142d4442bdb1e9a7.webp) 

另外，二叉查找树解决了插入新节点的问题，因为二叉查找树是一个跳跃结构，不必连续排列。这样在插入的时候，新节点可以放在任何位置，不会像线性结构那样插入一个元素，所有元素都需要向后排列。

下面是二叉查找树插入某个节点的动图演示：

![be13777664584209826f90d5d4128b7f](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/be13777664584209826f90d5d4128b7f.gif) 



因此，二叉查找树解决了连续结构插入新元素开销很大的问题，同时又保持着天然的二分结构。

那是不是二叉查找树就可以作为索引的数据结构了呢？

不行不行，二叉查找树存在一个极端情况，会导致它变成一个瘸子！

**当每次插入的元素都是二叉查找树中最大的元素，二叉查找树就会退化成了一条链表，查找数据的时间复杂度变成了 O(n)**，如下动图演示：

![320c5c2653e74f9e9ebfcd8ca9681905](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/320c5c2653e74f9e9ebfcd8ca9681905.webp) 

由于树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作（*假设一个节点的大小「小于」操作系统的最小读写单位块的大小*），也就是说**树的高度就等于每次查询数据时磁盘 IO 操作的次数**，所以树的高度越高，就会影响查询性能。

二叉查找树由于存在退化成链表的可能性，会使得查询操作的时间复杂度从 O(logn) 升为 O(n)。

而且会随着插入的元素越多，树的高度也变高，意味着需要磁盘 IO 操作的次数就越多，这样导致查询性能严重下降，再加上不能范围查询，所以不适合作为数据库的索引结构。

##### 平衡二叉树

为了解决二叉查找树会在极端情况下退化成链表的问题，后面就有人提出**平衡二叉查找树（AVL 树）**。

主要是在二叉查找树的基础上增加了一些条件约束：**每个节点的左子树和右子树的高度差不能超过 1**。也就是说节点的左子树和右子树仍然为平衡二叉树，这样查询操作的时间复杂度就会一直维持在 O(logn) 。

下图是每次插入的元素都是平衡二叉查找树中最大的元素，可以看到，它会维持自平衡：

![8d5da86f2e41a0b641dbf45b23f7b7dd](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/8d5da86f2e41a0b641dbf45b23f7b7dd.webp) 

除了平衡二叉查找树，还有很多自平衡的二叉树，比如红黑树，它也是通过一些约束条件来达到自平衡，不过红黑树的约束条件比较复杂，不是本篇的重点重点

**不管平衡二叉查找树还是红黑树，都会随着插入的元素增多，而导致树的高度变高，这就意味着磁盘 I/O 操作次数多，会影响整体数据查询的效率**。

比如，下面这个平衡二叉查找树的高度为 5，那么在访问最底部的节点时，就需要磁盘 5 次 I/O 操作。

![image-20240504154311329](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504154311329.png) 

根本原因是因为它们都是二叉树，也就是每个节点只能保存 2 个子节点 ，如果我们把二叉树改成 M 叉树（M>2）呢？

比如，当 M=3 时，在同样的节点个数情况下，三叉树比二叉树的树高要矮。

![image-20240504154326627](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504154326627.png) 

因此，**当树的节点越多的时候，并且树的分叉数 M 越大的时候，M 叉树的高度会远小于二叉树的高度**。

##### B 树

平衡二叉树虽然能保持查询操作的时间复杂度在O(logn)，但是因为它本质上是一个二叉树，每个节点只能有 2 个子节点，那么当节点个数越多的时候，树的高度也会相应变高，这样就会增加磁盘的 I/O 次数，从而影响数据查询的效率。

为了解决降低树的高度的问题，后面就出来了 **B 树，它不再限制一个节点就只能有 2 个子节点，而是允许 M 个子节点 (M>2)**，从而降低树的高度。

B 树的每一个节点最多可以包括 M 个子节点，**M 称为 B 树的阶**，所以 B 树就是一个多叉树。

假设 M = 3，那么就是一棵 3 阶的 B 树，特点就是**每个节点最多有 2 个（M-1个）数据**和**最多有 3 个（M个）子节点**，超过这些要求的话，就会分裂节点，比如下面的的动图：

![9a96956de3be0614f7ec2344741b4dcc](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/9a96956de3be0614f7ec2344741b4dcc.gif) 

我们来看看一棵 3 阶的 B 树的查询过程是怎样的？

![341cedca6863fcd0624febd835165ae2](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/341cedca6863fcd0624febd835165ae2.webp) 

假设我们在上图一棵 3 阶的 B 树中要查找的索引值是 9 的记录那么步骤可以分为以下几步：

1. 与根节点的索引(4，8）进行比较，9 大于 8，那么往右边的子节点走；
2. 然后该子节点的索引为（10，12），因为 9 小于 10，所以会往该节点的左边子节点走；
3. 走到索引为9的节点，然后我们找到了索引值 9 的节点。

可以看到，一棵 3 阶的 B 树在查询叶子节点中的数据时，由于树的高度是 3 ，所以在查询过程中会发生 3 次磁盘 I/O 操作。

而如果同样的节点数量在平衡二叉树的场景下，树的高度就会很高，意味着磁盘 I/O 操作会更多。所以，B 树在数据查询中比平衡二叉树效率要高。

**但是 B 树的每个节点都包含数据（索引+记录）**，而用户的记录数据的大小很有可能远远超过了索引数据，这就需要花费更多的磁盘 I/O 操作次数来读到「有用的索引数据」。

而且，在我们查询位于底层的某个节点（比如 A 记录）过程中，「非 A  记录节点」里的记录数据会从磁盘加载到内存，但是这些记录数据是没用的，我们只是想读取这些节点的索引数据来做比较查询，而「非 A  记录节点」里的记录数据对我们是没用的，这样不仅增多磁盘 I/O 操作次数，也占用内存资源。

另外，如果使用 B 树来做范围查询的话，需要使用中序遍历，这会涉及多个节点的磁盘 I/O  问题，从而导致整体速度下降

##### B+ 树

B+ 树就是对 B 树做了一个升级，MySQL 中索引的数据结构就是采用了 B+ 树，B+ 树结构如下图：

![image-20240504154718315](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504154718315.png) 

B+ 树与 B 树差异的点，主要是以下这几点：

- 叶子节点（最底部的节点）才会存放实际数据（索引+记录），非叶子节点只会存放索引；
- 所有索引都会在叶子节点出现，叶子节点之间构成一个有序链表；
- 非叶子节点的索引也会同时存在在子节点中，并且是在子节点中所有索引的最大（或最小）。
- 非叶子节点中有多少个子节点，就有多少个索引；

##### B树 VS B+树

###### 单点查询

B 树进行单个索引查询时，最快可以在 O(1) 的时间代价内就查到，而从平均时间代价来看，会比 B+ 树稍快一些。

但是 B 树的查询波动会比较大，因为每个节点即存索引又存记录，所以有时候访问到了非叶子节点就可以找到索引，而有时需要访问到叶子节点才能找到索引。

**B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少**

###### 插入和删除效率

B+ 树有大量的冗余节点，这样使得删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，这样删除非常快，

比如下面这个动图是删除 B+ 树 0004 节点的过程，因为非叶子节点有 0004 的冗余节点，所以在删除的时候，树形结构变化很小：

![25508b0cd9c44ef6937fdd737020a7f1](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/25508b0cd9c44ef6937fdd737020a7f1.webp) 

> 注意：B+ 树对于非叶子节点的子节点和索引的个数，定义方式可能会有不同，有的是说非叶子节点的子节点的个数为 M 阶，而索引的个数为  M-1（这个是维基百科里的定义），因此我本文关于 B+ 树的动图都是基于这个。但是我在前面介绍 B树与 B+  树的差异时，说的是「非叶子节点中有多少个子节点，就有多少个索引」，主要是 MySQL 用到的 B+ 树就是这个特性。

下面这个动图是删除 B 树 0008 节点的过程，可能会导致树的复杂变化：

![2be62679487640bbaac663fa96c7f35f](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/2be62679487640bbaac663fa96c7f35f.webp) 

但是，B+ 树在删除根节点的时候，由于存在冗余的节点，所以不会发生复杂的树的变形，比如下面这个动图是删除 B+ 树根节点的过程：

![23730b5af987480fabff0f1d142a2b6c](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/23730b5af987480fabff0f1d142a2b6c.webp) 

B+ 树的插入也是一样，有冗余节点，插入可能存在节点的分裂（如果节点饱和），但是最多只涉及树的一条路径。而且 B树会自动平衡，不需要像更多复杂的算法，类似红黑树的旋转操作等。

因此，**B+ 树的插入和删除效率更高**

###### 范围查询

B 树和 B+ 树等值查询原理基本一致，先从根节点查找，然后对比目标数据的范围，最后递归的进入子节点查找。

因为 **B+ 树所有叶子节点间还有一个链表进行连接，这种设计对范围查找非常有帮助**，比如说我们想知道 12 月 1 日和 12 月 12 日之间的订单，这个时候可以先查找到 12 月 1 日所在的叶子节点，然后利用链表向右遍历，直到找到 12 月12 日的节点，这样就不需要从根节点查询了，进一步节省查询需要的时间。

而 B 树没有将所有叶子节点用链表串联起来的结构，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。

因此，存在大量范围检索的场景，适合使用 B+树，比如数据库。而对于大量的单个索引查询的场景，可以考虑 B 树，比如 nosql 的MongoDB。

##### MySQL 中的 B+ 树

MySQL 的存储方式根据存储引擎的不同而不同，我们最常用的就是 Innodb 存储引擎，它就是采用了 B+ 树作为了索引的数据结构。

下图就是 Innodb 里的 B+ 树：

![image-20240504155429560](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504155429560.png) 

但是 Innodb 使用的  B+ 树有一些特别的点，比如：

- B+ 树的叶子节点之间是用「双向链表」进行连接，这样的好处是既能向右遍历，也能向左遍历。
- B+ 树点节点内容是数据页，数据页里存放了用户的记录以及各种信息，每个数据页默认大小是 16 KB。

Innodb 根据索引类型不同，分为聚集和二级索引。他们区别在于，聚集索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚集索引的叶子节点，而二级索引的叶子节点存放的是主键值，而不是实际数据。

因为表的数据都是存放在聚集索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚集索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个，而二级索引可以创建多个。

##### 总结

MySQL 是会将数据持久化在硬盘，而存储功能是由 MySQL 存储引擎实现的，所以讨论 MySQL  使用哪种数据结构作为索引，实际上是在讨论存储引使用哪种数据结构作为索引，InnoDB 是 MySQL 默认的存储引擎，它就是采用了 B+  树作为索引的数据结构

要设计一个 MySQL 的索引数据结构，不仅仅考虑数据结构增删改的时间复杂度，更重要的是要考虑磁盘 I/0 的操作次数。因为索引和记录都是存放在硬盘，硬盘是一个非常慢的存储设备，我们在查询数据的时候，最好能在尽可能少的磁盘 I/0 的操作次数内完成。

二分查找树虽然是一个天然的二分结构，能很好的利用二分查找快速定位数据，但是它存在一种极端的情况，每当插入的元素都是树内最大的元素，就会导致二分查找树退化成一个链表，此时查询复杂度就会从 O(logn)降低为 O(n)。

为了解决二分查找树退化成链表的问题，就出现了自平衡二叉树，保证了查询操作的时间复杂度就会一直维持在 O(logn) 。但是它本质上还是一个二叉树，每个节点只能有 2 个子节点，随着元素的增多，树的高度会越来越高。而树的高度决定于磁盘  I/O 操作的次数，因为树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作，也就是说树的高度就等于每次查询数据时磁盘 IO 操作的次数，所以树的高度越高，就会影响查询性能。

B 树和 B+ 都是通过多叉树的方式，会将树的高度变矮，所以这两个数据结构非常适合检索存于磁盘中的数据。

但是 MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：

- B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，B+树的非叶子节点可以存放更多的索引，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。
- B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 B+ 树在插入、删除的效率都更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；
- B+ 树叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。

#### 索引存储

InnoDB 存储引擎是 MySQL 数据库中使用最为广泛的引擎，在海量大并发的 OLTP 业务中，InnoDB 必选。它在数据存储方面有一个非常大的特点：索引组织表（Index Organized Table）。**数据（索引+记录）**存储有**堆表和索引组织表**两种方式，**堆表是一种过时的索引存储方式，而索引组织表包括主键索引和二级索引**。

##### 堆表

**堆表中的数据无序存放，** 数据的排序完全依赖于索引（Oracle、Microsoft SQL Server、PostgreSQL 早期默认支持的数据存储都是堆表结构）。

![image-20240504175741674](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504175741674.png) 

从图中你能看到，**堆表的组织结构中，数据和索引分开存储**。索引是排序后的数据，**而堆表中的数据是无序的**，索引的叶子节点存放了数据在堆表中的地址，当堆表的数据发生改变，且位置发生了变更，所有索引中的地址都要更新，这非常影响性能，特别是对于 OLTP 业务。

##### 聚集索引

**在索引组织表中，数据根据主键排序存放在索引中**，**主键索引也叫聚集索引**（Clustered Index）。**在索引组织表中，数据即索引，索引即数据**。

MySQL InnoDB 存储引擎就是这样的数据组织方式；Oracle、Microsoft SQL Server 后期也推出了支持索引组织表的存储方式。

> 注意：一个表只有一个聚集索引，这是唯一的，聚集索引的表现形式是一颗B+树，也就是说这颗B+树是唯一的，是按照主键索引进行排序的（例如：主键id），而且这颗B+树的叶子结点包含了这张表的所有数据，包括索引。

例如：User 表

![image-20240504180402682](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504180402682.png) 

表 User 的**主键是 id**，所以**表中的数据根据 id 排序存储**，**叶子节点存放了表中完整的记录**，**可以看到表中的数据存放在索引中**，**即表就是索引，索引就是表**。

##### 二级索引

InnoDB 存储引擎的数据是根据主键索引排序存储的，除了主键索引外，**其他的索引都称之为二级索引（Secondeary Index），** 或非聚集索引（None Clustered Index）。

二级索引也是一颗 B+ 树索引，**但它和主键索引不同的是叶子节点存放的是索引键值、主键值**。假设在列 name 上还创建了索引 idx_name，该索引就是二级索引：

> 主键索引B+树的叶子节点是存储了所有的数据，二级索引B+树的叶子节点只存储了二级索引和对应的主键索引

```sql
CREATE TABLE User (

    id BIGINT AUTO_INCREMENT,

    name VARCHAR(128) NOT NULL,

    sex CHAR(6) NOT NULL,

    registerDate DATETIME NOT NULL,

    ...

    PRIMARY KEY(id), -- 主键索引

    KEY idx_name(name) -- 二级索引

)
```

如果用户通过列 name 进行查询，比如下面的 SQL：

```sql
SELECT * FROM User WHERE name = 'David'，
```

* 先**通过二级索引 idx_name 可以定位到主键索引**，
* **然后额外再通过主键索引进行查询，得到最终的结果**。

**这种“二级索引通过主键索引进行再一次查询”的操作叫作“回表”**，你可以通过下图理解二级索引的查询：

![image-20240504181338926](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240504181338926.png) 

索引组织表这样的二级索引设计有一个非常大的好处：若记录发生了修改，则其他索引无须进行维护，除非记录的主键发生了修改。

##### 总结

1. 索引组织表主键是聚集索引，索引的叶子节点存放表中一整行完整记录；

2. 除主键索引外的索引都是二级索引，索引的叶子节点存放的是（索引键值，主键值）；

3. 由于二级索引不存放完整记录，因此需要通过主键值再进行一次回表才能定位到完整数据；

4. 索引组织表对比堆表，在海量并发的OLTP业务中能有更好的性能表现；

#### 联合索引

前面讲的主键索引和二级索引都是基于一个列进行索引排序和使用，比较简单。在实际业务中，我们会遇到很多复杂的场景，比如**对多个列进行查询**。这时，可能会要求用户创建多个列组成的索引，如列 a 和 b 创建的组合索引，但究竟是创建（a，b）的索引，还是（b，a）的索引，结果却是完全不同的。

##### 基本介绍

联合索引（Compound Index）是指由多个列所组合而成的 B+树索引，这和我们之前介绍的B+ 树索引的原理完全一样，只是之前是对一个列排序，现在是对多个列排序。

**联合索引既可以是主键索引**，**也可以是二级索引**，下图显示的是一个二级组合索引：

![image-20240505092025386](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505092025386.png) 

从上图可以看到，组合索引只是排序的键值从 1 个变成了多个，本质还是一颗 B+ 树索引。但是你一定要意识到（a，b）和（b，a）这样的组合索引，其排序结果是完全不一样的。而索引的字段变多了，设计上更容易出问题，如：

![image-20240505092116730](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505092116730.png) 

##### 联合索引的优化

对联合索引（a，b）来说，因为其对列 a、b 做了排序，所以它可以对下面三个查询进行优化：

```sql
SELECT * FROM table WHERE a = ?

SELECT * FROM table WHERE a = ？ AND b = ？

SELECT * FROM table WHERE b = ？ AND a = ？
```

上述 SQL 查询中，WHERE 后查询列 a 和 b 的顺序无关，即使先写 b = ? AND a = ？依然可以使用组合索引（a，b）。

但是下面的 SQL 无法使用组合索引（a，b），因为（a，b）排序并不能推出（b，a）排序，所以不能对下列查询做优化：

```sql
SELECT * FROM table WHERE b = ?
```

此外，同样由于索引（a，b）已排序，因此下面这条 SQL 依然可以使用组合索引（a，b），以此提升查询的效率：

```sql
SELECT * FROM table WHERE a = ？ ORDER BY b DESC
```

同样的原因，索引（a，b）排序不能得出（b，a）排序，因此下面的 SQL 无法使用组合索引（a，b）：

```sql
SELECT * FROM table WHERE b = ？ ORDER BY a DESC
```

##### 业务索引设计实战

我们用 TPC-H 定义的一组测试表，来展示索引相关示例的展示。TPC-H 是美国交易处理效能委员会( TPC：Transaction Processing Performance Council )  组织制定的，用来模拟决策支持类应用的一个测试集的规范定义，其模拟的就是一个类似电商业务，看一下其对核心业务表 rders 的设计：

```r
CREATE TABLE `orders` (
  `O_ORDERKEY` int NOT NULL, //INT 类型的主键
  `O_CUSTKEY` int NOT NULL, //关联表 customer
  `O_ORDERSTATUS` char(1) NOT NULL, //当前订单的状态
  `O_TOTALPRICE` decimal(15,2) NOT NULL, //订单的总价
  `O_ORDERDATE` date NOT NULL, //下单的时间
  `O_ORDERPRIORITY` char(15) NOT NULL, //订单的优先级
  `O_CLERK` char(15) NOT NULL,
  `O_SHIPPRIORITY` int NOT NULL,
  `O_COMMENT` varchar(79) NOT NULL,

  PRIMARY KEY (`O_ORDERKEY`), // 定义主键索引

  KEY `ORDERS_FK1` (`O_CUSTKEY`), // 定义二级索引

  CONSTRAINT `orders_ibfk_1` FOREIGN KEY (`O_CUSTKEY`) REFERENCES `customer` (`C_CUSTKEY`)

) ENGINE=InnoDB DEFAULT
```

其中：

- 字段 o_orderkey 是 INT 类型的主键；
- 字段 o_custkey 是一个关联字段，关联表 customer；
- 字段 o_orderdate、o_orderstatus、o_totalprice、o_orderpriority 用于描述订单的基本详情，分别表示下单的时间、当前订单的状态、订单的总价、订单的优先级。

###### 避免额外排序

在有了上述订单表后，当用户查看自己的订单信息，并且需要根据订单时间排序查询时，可通过下面的 SQL：

```sql
select * from orders 
where o_custkey = 147601 order by o_orderdate desc;
```

但由于上述表结构的索引设计时，索引 ORDERS_FK1 仅对列 O_CUSTKEY 排序，因此在取出用户 147601 的数据后，还需要一次额外的排序才能得到结果，可通过命令EXPLAIN验证：

![image-20240505135333155](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505135333155.png) 

在上面的命令 EXPLAIN 输出结果中可以看到，**SQL 语句的确可以使用索引 ORDERS_FK1**，**但在 Extra 列中显示的 Using filesort**，**表示还需要一次额外的排序才能得到最终的结果**。

由于已对列 o_custky 创建索引，因此上述 SQL 语句并不会执行得特别慢，但是在海量的并发业务访问下，每次 SQL 执行都需要排序就会对业务的性能产生非常明显的影响，比如 CPU 负载变高，QPS 降低。

为此，我们在表 orders 上创建新的组合索引 idx_custkey_orderdate，对字段（o_custkey，o_orderdate）进行索引：

```sql
ALTER TABLE orders ADD INDEX 
idx_custkey_orderdate(o_custkey,o_orderdate);
```

这时再进行之前的 SQL，根据时间展示用户的订单信息，其执行计划为：

![image-20240505135900999](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505135900999.png) 

可以看到，这时**优化器使用了我们新建的索引 idx_custkey_orderdate**，而且没有了 Sort 排序第二个过程。

###### 索引覆盖

回表的概念：即 SQL 需要通过二级索引查询得到主键值，然后再根据主键值搜索主键索引，最后定位到完整的数据。

但是由于二级组合索引的叶子节点，包含索引键值和主键值，若查询的字段在二级索引的叶子节点中，则可直接返回结果，无需回表。这种**通过组合索引避免回表的优化技术也称为索引覆盖（Covering Index）**。

```sql
EXPLAIN 

SELECT o_custkey,o_orderdate,o_totalprice 

FROM orders WHERE o_custkey = 147601
```

执行计划显示上述SQL会使用到之前新创建的组合索引  idx_custkey_orderdate，但是，由于组合索引的叶子节点只包含（o_custkey，o_orderdate，_orderid），没有字段 o_totalprice 的值，所以需要通过 o_orderkey 回表找到对应的 o_totalprice。

如果想要避免回表，可以通过索引覆盖技术，创建(o_custkey，o_orderdate，o_totalprice）的组合索引，如：

```sql
ALTER TABLE `orders` ADD INDEX

idx_custkey_orderdate_totalprice(o_custkey,o_orderdate,o_totalprice);
```

再次观察 SQL 的执行成本，可以看到 cost 有明显的下降，从 6.65 下降为了 2.94,在使用索引覆盖技术后，无需回表，减少了 19 次的回表开销

这就是索引覆盖技术的威力，而且这还只是基于 orders 表总共 600 万条记录。若表 orders 的记录数越多，需要回表的次数也就越多，通过索引覆盖技术性能的提升也就越明显。

##### 总结

联合索引也是一颗 B+ 树，只是索引的列由多个组成，组合索引既可以是主键索引，也可以是二级索引。通过今天的学习，我们可以归纳组合索引的三大优势：

1. 覆盖多个查询条件，如（a，b）索引可以覆盖查询 a = ? 或者 a = ? and b = ?；
2. 避免 SQL 的额外排序，提升 SQL 性能，如 WHERE a = ? ORDER BY b 这样的查询条件；
3. 利用组合索引包含多个列的特性，可以实现索引覆盖技术，提升 SQL 的查询性能，用好索引覆盖技术，性能提升 10 倍不是难事。

#### 索引失效

在工作中，如果我们想提高一条语句查询速度，通常都会想对字段建立索引。但是索引并不是万能的。建立了索引，并不意味着任何查询语句都能走索引扫描。稍不注意，可能你写的查询语句是会导致索引失效，从而走了全表扫描，虽然查询的结果没问题，但是查询的性能大大降低。

今天就来跟大家盘一盘，常见的 6 种会发生索引失效的场景。

t_user表，其中id为主键。索引包括：id的主键索引（默认的）、index_name的二级索引（name,id）

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505113858484.png" alt="image-20240505113858484" style="zoom:67%;" /> 

##### 索引用左或左右模糊匹配

当我们使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%` 这两种方式都会造成索引失效。

比如下面的 like 语句，查询 name 后缀为「林」的用户，执行计划中的 type=ALL 就代表了全表扫描，而没有走索引。

```sql
// name 字段为二级索引
select * from t_user where name like '%林';
```

![image-20240505111626482](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505111626482.png) 

如果是查询 name 前缀为林的用户，那么就会走索引扫描，执行计划中的 type=range 表示走索引扫描，key=index_name 看到实际走了 index_name 索引：

```sql
// name 字段为二级索引
select * from t_user where name like '林%';
```

![image-20240505111657782](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505111657782.png) 

> 为什么 like 关键字左或者左右模糊匹配无法走索引呢？
>
> **因为索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。**
>
> 如果使用 `name like '%林'` 方式来查询，因为查询的结果可能是「陈林、张林、周林」等之类的，所以不知道从哪个索引值开始比较，于是就只能通过全表扫描的方式来查询。

##### 对索引使用函数

有时候我们会用一些 MySQL 自带的函数来得到我们想要的结果，这时候要注意了，如果查询条件中对索引字段使用函数，就会导致索引失效。

比如下面这条语句查询条件中对 name 字段使用了 LENGTH 函数，执行计划中的 type=ALL，代表了全表扫描：

```sql
// name 为二级索引
select * from t_user where length(name)=6;
```

![image-20240505112109767](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505112109767.png) 

> 为什么对索引使用函数，就无法走索引了呢？
>
> 因为索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。

不过，从 MySQL 8.0 开始，索引特性增加了**函数索引**，即可以针对函数计算后的值建立一个索引，也就是说该索引的值是函数计算后的值，所以就可以通过扫描索引来查询数据。

举个例子，我通过下面这条语句，对 length(name) 的计算结果建立一个名为 idx_name_length 的索引。

```sql
alter table t_user add key idx_name_length ((length(name)));
```

然后我再用下面这条查询语句，这时候就会走索引了。

![image-20240505112825221](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505112825221.png) 

##### 对索引进行表达式计算

在查询条件中对索引进行表达式计算，也是无法走索引的。

比如，下面这条查询语句，执行计划中 type = ALL，说明是通过全表扫描的方式查询数据的：

```sql
explain select * from t_user where id + 1 = 10;
```

![image-20240505113454147](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505113454147.png) 

但是，如果把查询语句的条件改成 where id  = 10 - 1，这样就不是在索引字段进行表达式计算了，于是就可以走索引查询了。

![image-20240505113536060](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505113536060.png) 

> 为什么对索引进行表达式计算，就无法走索引了呢？
>
> 原因跟对索引使用函数差不多。
>
> **因为索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值**，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。

有的同学可能会说，这种对索引进行简单的表达式计算，在代码特殊处理下，应该是可以做到索引扫描的，比方将  id + 1 = 10 变成 id  = 10 - 1。

是的，是能够实现，但是 MySQL 还是偷了这个懒，没有实现。

我的想法是，可能也是因为，表达式计算的情况多种多样，每种都要考虑的话，代码可能会很臃肿，所以干脆将这种索引失效的场景告诉程序员，让程序员自己保证在查询条件中不要对索引进行表达式计算

##### 对索引隐式类型转换

如果索引字段是字符串类型，但是在条件查询中，输入的参数是整型的话，你会在执行计划的结果发现这条语句会走全表扫描。

我在原本的 t_user 表增加了 phone 字段，是二级索引且类型是 varchar。

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505131535363.png" alt="image-20240505131535363" style="zoom:80%;" /> 

然后我在条件查询中，用整型作为输入参数，此时执行计划中 type = ALL，所以是通过全表扫描来查询数据的。

```sql
select * from t_user where phone = 1300000001;
```

![image-20240505131701130](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505131701130.png) 

但是如果索引字段是整型类型，查询条件中的输入参数即使字符串，是不会导致索引失效，还是可以走索引扫描。

我们再看第二个例子，id 是整型，但是下面这条语句还是走了索引扫描的。

```sql
select * from t_user where id = '1';
```

![image-20240505131821052](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505131821052.png) 

> 为什么第一个例子会导致索引失效，而第二例子不会呢？
>
> 要明白这个原因，首先我们要知道 **MySQL 的数据类型转换规则**是什么？就是看 MySQL 是会将字符串转成数字处理，还是将数字转换成字符串处理。
>
> **MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较**。

前面的例子一中的查询语句，我也跟大家说了是会走全表扫描：

```sql
//例子一的查询语句
select * from t_user where phone = 1300000001;
//这是因为 phone 字段为字符串，所以 MySQL 要会自动把字符串转为数字，所以这条语句相当于：
//等价于
select * from t_user where CAST(phone AS signed int) = 1300000001;
```

可以看到，**CAST 函数是作用在了 phone 字段，而 phone 字段是索引，也就是对索引使用了函数！而前面我们也说了，对索引使用函数是会导致索引失效的**。

例子二中的查询语句，我跟大家说了是会走索引扫描：

```sql
//例子二的查询语句
select * from t_user where id = "1";
//这时因为字符串部分是输入参数，也就需要将字符串转为数字，所以这条语句相当于：
select * from t_user where id = CAST("1" AS signed int);
```

可以看到，**索引字段并没有用任何函数**，**CAST 函数是用在了输入参数**，因此是可以走索引扫描的

##### 联合索引非最左匹配

对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。那么**多个普通字段组合在一起创建的索引就叫做联合索引**，也叫组合索引。

创建联合索引时，我们需要注意创建时的顺序问题，因为联合索引 (a, b, c) 和 (c, b, a) 在使用的时候会存在差别。联合索引要能正确使用需要遵循**最左匹配原则**，也就是按照最左优先的方式进行索引的匹配。

比如，如果创建了一个 `(a, b, c)` 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：

- where a=1；
- where a=1 and b=2 and c=3；
- where a=1 and b=2；

**需要注意的是，因为有查询优化器，所以 a 字段在 where 子句的顺序并不重要。**

但是，如果查询条件是以下这几种，因为**不符合最左匹配原则**，所以就无法匹配上联合索引，联合索引就会失效:

- where b=2；
- where c=3；
- where b=2 and c=3；

> 有一个比较特殊的查询条件：where a = 1 and c = 3 ，符合最左匹配吗？
>
> 这种其实严格意义上来说是属于索引截断，不同版本处理方式也不一样。

MySQL 5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始回表，到主键索引读取数据行，Server 层从存储引擎层获取到数据行后，然后在 Server 层再比对 c 字段的值。

从 MySQL 5.6 之后，有一个**索引下推功能**，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。

> 为什么联合索引不遵循最左匹配原则就会失效？
>
> 原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。
>
> 也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引

##### WHERE 子句中的 OR

在 WHERE 子句中，如果在 **OR 前的条件列是索引列**，而在 **OR 后的条件列不是索引列**，那么**第一个索引会失效。**

举个例子，比如下面的查询语句，id 是主键，age 是普通列，从执行计划的结果看，**虽然用到了主键,但还是走了全表扫描**。

```text
select * from t_user where id = 1 or age = 18;
```

![image-20240505132926266](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505132926266.png)  

要解决办法很简单，将 age 字段设置为索引即可。

![image-20240505133148125](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505133148125.png)  

可以看到 **type=index merge**， **index merge 的意思就是对 id 和 age 分别进行了扫描**，**然后将这两个结果集进行了合并**，**这样做的好处就是避免了全表扫描**

##### 总结

- 当我们使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；
- 当我们在查询条件中对索引列使用函数，就会导致索引失效。
- 当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。
- MySQL  在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生隐式类型转换，由于隐式类型转换是通过 CAST 函数实现的，等同于对索引列使用了函数，所以就会导致索引失效。
- 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
- 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么前一个索引会失效。

#### 索引选择

在实际工作中，我也经常会遇到一些同学提出这样的问题：MySQL 并没有按照自己的预想来选择索引，比如创建了索引但是选择了全表扫描，这肯定是 MySQL 数据库的 Bug，或者是索引出错了。

**当然不是！** 这主要因为索引中的数据犯了错。

为什么这么说呢？要理解该问题，要理解 MySQL 数据库中的优化器是怎么执行的，然后才能明白为什么最终优化器没有选择你预想的索引。

##### MySQL 的成本计算

在前面的表 orders 中，对于字段 o_custkey 已经创建了相关的 3 个索引，所以现在表 orders 的情况如下所示：

```r
CREATE TABLE `orders` (
  `O_ORDERKEY` int NOT NULL,
  `O_CUSTKEY` int NOT NULL,
  `O_ORDERSTATUS` char(1) NOT NULL,
  `O_TOTALPRICE` decimal(15,2) NOT NULL,
  `O_ORDERDATE` date NOT NULL,
  `O_ORDERPRIORITY` char(15) NOT NULL,
  `O_CLERK` char(15) NOT NULL,
  `O_SHIPPRIORITY` int NOT NULL,
  `O_COMMENT` varchar(79) NOT NULL,

  PRIMARY KEY (`O_ORDERKEY`),

  KEY `idx_custkey_orderdate` (`O_CUSTKEY`,`O_ORDERDATE`),

  KEY `ORDERS_FK1` (`O_CUSTKEY`),

  KEY `idx_custkey_orderdate_totalprice` (`O_CUSTKEY`,`O_ORDERDATE`,`O_TOTALPRICE`),

  CONSTRAINT `orders_ibfk_1` FOREIGN KEY (`O_CUSTKEY`) REFERENCES `customer` (`C_CUSTKEY`)

) ENGINE=InnoDB
```

在查询字段 o_custkey 时，理论上可以使用三个相关的索引：**ORDERS_FK1**、**idx_custkey_orderdate**、**idx_custkey_orderdate_totalprice**。**那 MySQL 优化器是怎么从这三个索引中进行选择的呢？**

**在关系型数据库中，B+ 树索引只是存储的一种数据结构，具体怎么使用，还要依赖数据库的优化器**，优化器决定了具体某一索引的选择，也就是常说的执行计划。

==**而优化器的选择是基于成本（cost），哪个索引的成本越低，优先使用哪个索引。**== 



<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505150744711.png" alt="image-20240505150744711" style="zoom:50%;" /> 

如上图所示，MySQL 数据库由 Server 层和 Engine 层组成：

- Server 层有 SQL 分析器、SQL优化器、SQL 执行器，用于负责 SQL 语句的具体执行过程；
- Engine 层负责存储具体的数据，如最常使用的 InnoDB 存储引擎，还有用于在内存中存储临时结果集的 TempTable 引擎。

**SQL 优化器会分析所有可能的执行计划，选择成本最低的执行，这种优化器称之为：CBO（Cost-based Optimizer，基于成本的优化器）。**

而在 MySQL中，**一条 SQL 的计算成本计算如下所示：**

```java
Cost  = Server Cost + Engine Cost

      = CPU Cost + IO Cost
```

其中，CPU Cost 表示计算的开销，比如**索引键值的比较**、**记录值的比较**、**结果集的排序**……**这些操作都在 Server 层完成；**

IO Cost 表示引擎层 IO 的开销，MySQL 8.0 可以通过区分一张表的数据是否在内存中，分别计算**读取内存 IO 开销**以及**读取磁盘 IO 的开销**。

数据库 mysql 下的表 **server_cost**、**engine_cost** 则记录了对于各种成本的计算，如：

![image-20240505151126548](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505151126548.png) 

**表 server_cost 记录了 Server 层优化器各种操作的成本**，**这里面包括了所有 CPU Cost**，其具体含义如下。

- disk_temptable_create_cost：创建磁盘临时表的成本，默认为20。
- disk_temptable_row_cost：磁盘临时表中每条记录的成本，默认为0.5。
- key_compare_cost：索引键值比较的成本，默认为0.05，成本最小。
- memory_temptable_create_cost：创建内存临时表的成本：默认为1。
- memory_temptable_row_cost：内存临时表中每条记录的成本，默认为0.1。
- row_evaluate_cost：记录间的比较成本，默认为0.1。

**可以看到，** MySQL 优化器认为如果一条 SQL 需要创建基于磁盘的临时表，则这时的成本是最大的，其成本是基于内存临时表的 20 倍。而索引键值的比较、记录之间的比较，其实开销是非常低的，但如果要比较的记录数非常多，则成本会变得非常大。

**而表 engine_cost 记录了存储引擎层各种操作的成本，这里包含了所有的 IO Cost**，具体含义如下。

- io_block_read_cost：从磁盘读取一个页的成本，默认值为1。
- memory_block_read_cost：从内存读取一个页的成本，默认值为0.25。

**也就是说，** MySQL 优化器认为从磁盘读取的开销是内存开销的 4 倍。

不过，上述所有的成本都是可以修改的，比如如果数据库使用是传统的 HDD 盘，性能较差，其随机读取性能要比内存读取慢 50 倍

##### MySQL索引出错案例

###### 未能使用创建的索引

经常听到有同学反馈 MySQL 优化器不准，不稳定，一直在变。

但是，我想告诉你的是，MySQL 优化器永远是根据成本，选择出最优的执行计划。哪怕是同一条 SQL 语句，只要范围不同，优化器的选择也可能不同。

如下面这两条 SQL：

```sql
SELECT * FROM orders

WHERE o_orderdate > '1994-01-01' and o_orderdate < '1994-12-31';

SELECT * FROM orders 

WHERE o_orderdate > '1994-12-01' and o_orderdate < '1994-12-31';
```

上面这两条 SQL 都是通过索引字段 o_orderdate 进行查询，**然而第一条 SQL 语句的执行计划并未使用索引 idx_orderdate**，而是使用了如下的执行计划：

~~~sql
explain select * from orders
where o_orderdate > '1994-01-01' and o_orderdate < '1994-12-31';
~~~

![image-20240505152014425](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505152014425.png) 

从上述执行计划中可以发现，优化器已经通过 possible_keys 识别出可以使用索引 idx_orderdate，**但最终却使用全表扫描的方式取出结果。** 最为根本的原因在于：**优化器认为使用通过主键进行全表扫描的成本比通过二级索引 idx_orderdate 的成本要低**

默认优化器是不会选择二级索引的：

~~~sql
explain format=tree 
select * from orders
where o_orderdate > '1994-01-01' and o_orderdate < '1994-12-31';
*************************** 1. row ***************************
-> Filter: ((orders.O_ORDERDATE > DATE'1994-01-01') and (orders.O_ORDERDATE < DATE'1994-12-31'))  (cost=591064.90 rows=1876082)
    -> Table scan on orders  (cost=591064.90 rows=5465494)

~~~

强制使用二级索引：

~~~sql
explain format=tree 
select * from orders force index(idx_orderdate)
where o_orderdate > '1994-01-01' and o_orderdate < '1994-12-31'
*************************** 1. row ***************************
-> Index range scan on orders using idx_orderdate over ('1994-01-01' < O_ORDERDATE < '1994-12-31'), with index condition: ((orders.O_ORDERDATE > DATE'1994-01-01') and (orders.O_ORDERDATE < DATE'1994-12-31'))  (cost=1899844.40 rows=1876082)
~~~

可以看到，MySQL 认为全表扫描，然后再通过 WHERE 条件过滤的成本为591064.90，对比强制使用二级索引 idx_orderdate 的成本为 1899844.40。

**成本上看，全表扫描低于使用二级索引。故，MySQL 优化器没有使用二级索引 idx_orderdate。**

> 为什么全表扫描比二级索引查询快呢？
>
> 因为二级索引需要回表，当回表的记录数非常大时，成本就会比直接扫描要慢，因此这取决于回表的记录数。

所以，**第二条 SQL 语句，只是时间范围发生了变化**，**但是 MySQL 优化器就会自动使用二级索引 idx_orderdate了**，这时我们再观察执行计划：

~~~sql
explain
select * from orders 
where o_orderdate > '1994-12-01' and o_orderdate < '1994-12-31';
~~~

![ ](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505153645115.png)

再次强调，并不是 MySQL 选择索引出错，**而是 MySQL 会根据成本计算得到最优的执行计划，** 根据不同条件选择最优执行计划，而不是同一类型一成不变的执行过程，这才是优秀的优化器该有的样子。

###### 索引建在有限状态上

B+ 树索引通常要建立在高选择性的字段或字段组合上，如姓名、订单 ID、日期等，因为这样每个字段值大多并不相同。

但是对于性别这样的字段，其值只有男和女两种，哪怕记录数再多，也只有两种值，这是低选择性的字段，因此无须在性别字段上创建索引。

**但在有些低选择性的列上，是有必要创建索引的**。比如电商的核心业务表 orders，其有字段 o_orderstatus，表示当前的状态。

在电商业务中会有一个这样的逻辑：即会定期扫描字段 o_orderstatus 为支付中的订单，然后强制让其关闭，从而释放库存，给其他有需求的买家进行购买。

但字段 o_orderstatus 的状态是有限的，一般仅为已完成、支付中、超时已关闭这几种。

通常订单状态绝大部分都是已完成，只有绝少部分因为系统故障原因，会在 15 分钟后还没有完成订单，**因此订单状态是存在数据倾斜的。**

这时，虽然订单状态是低选择性的，但是由于其有数据倾斜，且我们只是从索引查询少量数据，因此可以对订单状态创建索引：

```sql
ALTER TABLE orders 

ADD INDEX idx_orderstatus(o_orderstatus)
```

但这时根据下面的这条 SQL，优化器的选择==**可能**==如下：（全表搜索）

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505154137067.png" alt="image-20240505154137067" style="zoom:50%;" /> 

由于字段 o_orderstatus 仅有三个值，分别为 ‘O’、’P’、’F’。但 MySQL 并不知道这三个列的分布情况，认为这三个值是平均分布的，但其实是这三个值存在严重倾斜：

```sql
select o_orderstatus,count(1) 
from orders group by o_orderstatus;

+---------------+----------+

| o_orderstatus | count(1) |

+---------------+----------+

| F             |  2923619 |

| O             |  2923597 |

| P             |   152784 |

+---------------+----------+
```

因此，**优化器会认为订单状态为 P 的订单占用 1⁄3 的数据，使用全表扫描，避免二级索引回表的效率会更高**。**然而，由于数据倾斜，订单状态为 P 的数据非常少，根据索引 idx_orderstatus 查询的效率会更高。**

但是，我的电脑是直接使用的二级索引，我猜测我的电脑应该是自动识别了订单状态的分布情况

![image-20240505154649641](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505154649641.png)

##### 总结

这一讲，我们知道了 MySQL 优化器是 CBO，即一种**基于成本的优化器**。其会判断每个索引的执行成本，从中选择出最优的执行计划。总结来说：

- MySQL 优化器是 CBO 的；
- MySQL 会选择成本最低的执行计划，你可以通过 EXPLAIN 命令查看每个 SQL 的成本；
- 一般只对高选择度的字段和字段组合创建索引，低选择度的字段如性别，不创建索引；
- 低选择性，但是数据存在倾斜，通过索引找出少部分数据，可以考虑创建索引；
- 若数据存在倾斜，可以创建直方图，让优化器知道索引中数据的分布，进一步校准执行计划。

#### 索引应用

下述一些关于索引的问题：

- 索引虽然能给`MySQL`检索数据的效率带来质的飞跃，但加入索引没有带来新问题吗？
- 既然索引能够提升查询性能，那是不是为表中每个字段建立索引，性能会更好？
- 一张数据表中，哪些类型的字段不适合建立索引呢？又是因为什么原因呢？
- 表中会存在大量的字段，但其中哪些字段建立索引才能够最大的性能收益呢？
- `MySQL`提供的索引种类也不少，一个字段上建立什么类型的索引才最好呢？
- 当表中存在多个索引时，一条查询`SQL`有多条路径可走，此时走哪条索引最好？

##### MySQL各索引的优劣

首先来聊聊索引机制带来的利害关系，有句古话曾说过：**“凡事有利必有弊”**，而`MySQL`的索引机制也不例外，引入索引机制后，能够给数据库带来的优势很明显：

①整个数据库中，数据表的查询速度直线提升，数据量越大时效果越明显。

②通过创建唯一索引，可以确保数据表中的数据唯一性，无需额外建立唯一约束。

③在使用分组和排序时，同样可以显著减少`SQL`查询的分组和排序的时间。

④连表查询时，基于主外键字段上建立索引，可以带来十分明显的性能提升。

⑤索引默认是`B+Tree`有序结构，基于索引字段做范围查询时，效率会明显提高。

⑥从`MySQL`整体架构而言，减少了查询`SQL`的执行时间，提高了数据库整体吞吐量。

看着上面一条又一条的好处，似乎感觉索引好处很大啊，对于这点确实毋庸置疑，但只有好处吗？`No`，同时也会带来一系列弊端，如：

①建立索引会生成本地磁盘文件，需要额外的空间存储索引数据，磁盘占用率会变高。

②写入数据时，需要额外维护索引结构，增、删、改数据时，都需要额外操作索引。

③写入数据时维护索引需要额外的时间开销，执行写`SQL`时效率会降低，性能会下降。

当然，但对数据库整体来说，索引带来的优势会大于劣势。不过也正由于索引存在弊端，**因此索引不是越多越好**，合理建立索引才是最佳选择。

`MySQL`的索引也会分为多种类型，每个类型的索引多多少少都存在一些弊端，接下来聊聊其他类型的索引

###### 主键索引的问题

信大家数据库的表中，主键一般都是使用自增`ID`，但这是为什么呢？有人可能会回答自增`ID`不会重复，确保了主键唯一性。这样也确实没错，但不会重复的又不仅仅只有自增`ID`，**比如我使用随机的`UUID`也不会重复，为何不使用`UUID`呢**？这是由于索引存在一个陷阱！

> `InnoDB`默认的索引结构是`B+Tree`，也就代表着索引节点的数据是有序的

此时结合上面给出的一些信息，**主键索引是聚簇索引，表数据和索引数据在一块、索引结构是有序的**，**而`UUID`是无序的**，如果使用`UUID`作为主键，那么每当插入一条新数据，会破坏原本的树结构。

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505180313481.png" alt="image-20240505180313481" style="zoom:67%;" /> 

但使用自增`ID`就不会有这个问题，**所有新插入的数据都会放到最后**。

**因此大家数据表的主键，最好选用带顺序性的值，否则有可能掉入主键索引的“陷阱”中。**

###### 联合索引的问题

为了多条件查询时的效率更高，一般都会同时对多个字段建立联合索引，但之前也聊到过，联合索引存在一个致命的问题，比如在用户表中，通过`id、name、age`三个字段建立一个联合索引，此时来了一条查询`SQL`，如下：

```sql
SELECT * FROM `zz_user` WHERE name = "竹子" AND age = "18";
```

而这条`SQL`语句是无法使用联合索引的，为什么呢？因为查询条件中，未包含联合索引的第一个字段，想要使用联合索引，那么查询条件中必须包含索引的第一个字段，必须满足**最左原则**，如下：

```sql
SELECT * FROM `zz_user` WHERE name = "竹子" AND id = 6;
```

###### 前缀索引的问题

 前缀索引的特点是短小精悍，我们可以利用一个字段的前`N`个字符创建索引，以这种形式创建的索引也被称之为前缀索引，相较于使用一个完整字段创建索引，前缀索引能够更加节省存储空间，当数据越多时，带来的优势越明显。

不过前缀索引虽然带来了节省空间的好处，但也正由于其索引节点中，未存储一个字段的完整值，所以`MySQL`也无法通过前缀索引来完成`ORDER BY、GROUP BY`等分组排序工作，同时也无法完成覆盖扫描等操作。

###### 唯一索引的问题

唯一索引有个很大的好处，就是查询数据时会比普通索引效率更高，因为基于普通索引的字段查询数据，例如：

```sql
SELECT * FROM TABLE_XX WHERE COLUMN_XX = "XX";
```

假设`COLUMN_XX`字段上建立了一个普通索引，此时基于这个字段查询数据时，当查询到一条`COLUMN_XX = "XX"`的数据后，此时会继续走完整个索引树，**因为可能会存在多条字段值相同的数据**。

> 但如果`COLUMN_XX`字段上建立的是唯一索引，当找到一条数据后就会立马停下检索，因此本身建立唯一索引的字段值就具备唯一性。

因此唯一索引查询数据时，会比普通索引快上一截，**但插入数据时就不同了**，因为要确保数据不重复，所以插入前会检查一遍表中是否存在相同的数据。但普通索引则不需要考虑这个问题，因此普通索引的数据插入会快一些。

###### 哈希索引的问题

 哈希索引，也就是数据结构为`Hash`类型的索引，不过估计大家接触的比较少，毕竟创建索引时都默认用的`B+`树结构。但要比起**查询速度，哈希索引绝对是`MySQL`中当之无愧的魁首**！因为采用哈希结构的索引，会以哈希表的形式存储索引字段值，当基于该字段查询数据时，只需要经过一次哈希计算就可获取到数据

> 但哈希结构的致命问题在于无序，也就是无法基于哈希索引的字段做排序、分组等工作。

因此如果你确定一个表中，不会做排序这类的工作，那可以适当选用哈希结构作为索引的数据结构，它会给你带来意想不到的性能收益~

##### 建立合理的索引

经过上述一系列分析后，简单讲明了每种索引类型存在的缺陷问题，但这跟我们本篇有啥关系呢？其实关系很大，因为只有当你了解了每种索引存在的劣势，才能更好的考虑并设计出合理的索引，而不是一股脑的盲目创建索引。

###### 回表问题

 什么叫做回表呢？意思就是指一条`SQL`语句在`MySQL`内部，要经过两次查询过程才能获取到数据。这是跟索引机制有关的，先来看看索引在`MySQL`内部真正的面貌：

**基于`ID`字段先建立了一个主键索引**，然后**又基于`name`字段建立了一个普通索引**，此时`MySQL`默认会选用主键索引作为聚簇索引，将表数据和主键索引存在同一个文件中，也就是主键索引的每个索引节点，都直接对应着行数据。而基于`name`字段建立的索引，其索引节点存放的则是指向聚簇索引的`ID`值。

在这种情况下，假设有一条下述`SQL`，其内部查询过程是啥样的呢？

```sql
SELECT * FROM `zz_user` WHERE name = "子竹";
```

首先会走`name`字段的索引，然后找到对应的`ID`值，然后再基于查询到的`ID`值，再走`ID`字段的主键索引，最终得到一整条行数据并返回。

> 在这个案例中，**一条查询`SQL`经历了两次查询才获取到数据，这个过程则被称之为回表**。

回表动作会导致额外的查询开销，因此尽量可以基于主键做查询，如果实在需要使用非主键字段查询，那么尽量要写明查询的结果字段，而并非使用`*`。

###### 建立索引的原则

当建立索引仅考虑一个字段是否被经常用于查询是不够的，往往一个合适的索引需要更为细致与长远的思考，例如使用多个字段建立是否会更好？创建其他类型的索引性能是否会更佳？下面我们就一起来看看建立索引时，需要遵守的一些==原则==：

①**经常频繁用作查询条件**的字段应酌情考虑为其创建索引。

②表的**主外键或连表字段**，必须建立索引，因为能很大程度提升连表查询的性能。

③建立索引的字段，一般**值的区分性要足够高**，这样才能提高索引的检索效率。

④建立索引的字段，值不应该过长**，如果较长的字段要建立索引，可以选择前缀索引**。

⑤建立联合索引，应当遵循**最左前缀原则**，将多个字段之间按优先级顺序组合。

⑥经常根据**范围取值、排序、分组的字段**应建立索引，因为索引有序，能加快排序时间。

⑦对于唯一索引，如果确认不会利用该字段排序，那可以将结构改为**`Hash`结构**。

⑧**尽量使用联合索引代替单值索引**，联合索引比多个单值索引查询效率要高。

同时，除开上述一些建立索引的原则外，在建立索引时还需有些==注意点==：

- ❶值**经常会增删改**的字段，不合适建立索引，因为每次改变后需维护索引结构。
- ❷一个字段存在**大量的重复值**时，不适合建立索引，比如之前举例的性别字段。
- ❸**索引不能参与计算**，因此经常带函数查询的字段，并不适合建立索引。
- ❹一张表中的**索引数量并不是越多越好**，一般控制在`3`，最多不能超过`5`。
- ❺建立联合索引时，一定要考虑优先级，**查询频率最高的字段应当放首位**。
- ❻当**表的数据较少，不应当建立索引**，因为数据量不大时，维护索引反而开销更大。
- ❼索引的字段值**无序时，不推荐建立索引**，因为会造成页分裂，尤其是主键索引。

对于索引机制，在建立时应当参考上述给出的意见，这每一条原则都是从实际经验中总结出来的，前面八条不一定要全面思考，但后面七条注意点，一定要牢记，如若你的索引符合后面七条中的描述，那一定要更改索引。

###### 最左原则

首先在讲最左前缀原则之前，先看看上述给出的一条原则：

- ⑧尽量使用联合索引代替单值索引，联合索引比多个单值索引查询效率要高。

对于这一点是为什么呢？举个栗子理解，比如此时基于`X、Y、Z`字段建立了一个联合索引，实际上也相当于建立了三个索引：`X`、`X、Y`、`X、Y、Z`，因此只要查询中使用了这三组字段，都可以让联合索引生效。

> 但如若查询中这三个字段不以`AND`形式出现，而是单独作为查询条件出现，那单值索引性能会好一些，但三个不同的索引，维护的代价也会高一些。

其实联合索引的**最左前缀原则，道理很简单的，就是组成联合索引的多个列，越靠左边优先级越高**，同时也只有`SQL`查询条件中，**包含了最左的字段，才能使用联合索引**

同时，`MySQL`的最左前缀原则，在**匹配到范围查询时会停止匹配**，比如`>、<、between、like`这类范围条件，并不会继续使用联合索引

```sql
SELECT * FROM tb WHERE X="..." AND Y > "..." AND Z="...";
```

当执行时，虽然上述`SQL`使用到`X、Y、Z`作为查询条件，但由于`Y`字段是`>`范围查询，因此这里只能使用`X`索引，而不能完全匹配使用`X、Y、Z`索引。

`SQL`是否走索引查询跟`where`后的条件顺序无关，因为`MySQL`优化器会优化，**对`SQL`查询条件进行重排序:**

```sql
select * from user where name = '竹子' and age = 18;
select * from user where  age = 18 and name = '竹子';
```

##### 使用索引

索引是`MySQL`执行`SQL`时自动选择，我们只能建立索引，其实这里是指我们编写`SQL`时，要注意的点，毕竟`MySQL`查询时到底使不使用索引，这完全取决于你编写的`SQL`

其实索引本身是一把双刃剑，用的好能够给我们带来异乎寻常的查询效率，用的不好则反而会带来额外的磁盘占用及写入操作时的维护开销。因此大家一定要切记，既然选择建了索引，那一定要利用它，否则还不如干脆别建，既能节省磁盘空间，又能提升写入效率。

###### ExPlain

这里就对`explain`工具做一个简单介绍，先来看看这个工具/命令的作用，当在一条`SQL`前加上`explain`命令，执行这条`SQL`后会列出所有的执行方案：

![image-20240505191321288](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505191321288.png) 

`id`：这是执行计划的`ID`值，这个值越大，表示执行的优先级越高。

`select_type`：当前查询语句的类型，有如下几个值：

- `simple`：简单查询。
- `primary`：复杂查询的外层查询。
- `subquery`：包含在查询语句中的子查询。
- `derived`：包含在`FROM`中的子查询。

`table`：表示当前这个执行计划是基于那张表执行的。

**`type`：当前执行计划查询的类型，有几种情况：**

- `all`：表示走了全表查询，未命中索引或索引失效。
- `system`：表示要查询的表中仅有一条数据。
- `const`：表示当前`SQL`语句的查询条件中，可以命中索引查询。
- `range`：表示当前查询操作是查某个区间。
- `eq_ref`：表示目前在做多表关联查询。
- `ref`：表示目前使用了普通索引查询。
- `index`：表示目前`SQL`使用了辅助索引查询。

**`possible_keys`：执行`SQL`时，优化器可能会选择的索引（最后执行不一定用）。**

**`key`：查询语句执行时，用到的索引名字。**

`key_len`：这里表示索引字段使用的字节数。

`ref`：这里显示使用了那种查询的类型。

`rows`：当前查询语句可能会扫描多少行数据才能检索出结果。

**`Extra`：这里是记录着额外的一些索引使用信息，有几种状态：**

- `using index`：表示目前使用了覆盖索引查询（稍后讲）。
- `using where`：表示使用了`where`子句查询，通常表示没使用索引。
- `using index condition`：表示查询条件使用到了联合索引的前面几个字段。
- `using temporary`：表示使用了临时表处理查询结果。
- `using filesort`：表示以索引字段之外的方式进行排序，效率较低。
- `select tables optimized away`：表示在索引字段上使用了聚合函数。

对于上述这么多的字段，其实目前不需要完全弄懂，本文只需要记住里面的`type`字段即可，`all`表示走全表扫描，`const、ref...`表示通过索引查询。

###### 正确使用索引

这里可以参考上两节索引失效的内容：

- ①查询`SQL`中尽量不要使用`OR`关键字，可以使用多`SQL`或子查询代替。
- ②模糊查询尽量不要以`%`开头，如果实在要实现这个功能可以建立全文索引。
- ③编写`SQL`时一定要注意字段的数据类型，否则`MySQL`的隐式转换会导致索引失效。
- ④一定不要在编写`SQL`时让索引字段执行计算工作，尽量将计算工作放在客户端中完成。
- ⑤对于索引字段尽量不要使用计算类函数，一定要使用时请记得将函数计算放在`=`后面。
- ⑥多条件的查询`SQL`一定要使用联合索引中的第一个字段，否则会打破最左匹配原则。
- ⑦对于需要对比多个字段的查询业务时，可以拆分为连表查询，使用临时表代替。

###### 索引下推

索引下推是`MySQL5.6`版本以后引入的一种优化机制，还是以之前的用户表为例，先来看一条`SQL`语句：

~~~sql
INSERT INTO `zz_users` VALUES(5,"竹竹","女","8888","2022-09-20 22:17:21");

SELECT * FROM `zz_users` WHERE `user_name` LIKE "竹%" AND `user_sex`="男";
~~~

首先为了更加直观的讲清楚索引下推，因此先再向用户表中增加一条数据。然后再来看看后面的查询`SQL`，这条`SQL`会使用联合索引吗？答案是会的，但只能部分使用，因为联合索引的每个节点信息大致如下：

~~~json
{
    ["熊猫","女","6666"] : 1,
    ["竹子","男","1234"] : 2,
    ["子竹","男","4321"] : 3,
    ["1111","男","4321"] : 4,
    ["竹竹","女","8888"] : 5
}
~~~

由于前面使用的是模糊查询，但`%`在结尾，因此可以使用`竹`这个字作为条件在联合索引中查询，整个查询过程如下：

- ①利用联合索引中的`user_name`字段找出「竹子、竹竹」两个索引节点。
- ②返回索引节点存储的值「`2、5`」给`Server`层，然后去逐一做回表扫描。
- ③在`Server`层中根据`user_sex="男"`这个条件逐条判断，最终筛选到「竹子」这条数据。

有人或许会疑惑，为什么`user_sex="男"`这个条件不在联合索引中处理呢？因为前面是模糊查询，所以拼接起来是这样的：`竹x男`，由于这个`x`是未知的，因此无法根据最左前缀原则去匹配数据，最终这里只能使用联合索引中`user_name`字段的一部分，后续的`user_sex="男"`还需要回到`Server`层处理。

> 那什么又叫做索引下推呢？也就是将`Server`层筛选数据的工作，下推到引擎层处理。

以前面的案例来讲解，`MySQL5.6`加入索引下推机制后，其执行过程是什么样子的呢？

- ①利用联合索引中的`user_name`字段找出「竹子、竹竹」两个索引节点。
- ②根据`user_sex="男"`这个条件在索引节点中逐个判断，从而得到「竹子」这个节点。
- ③最终将「竹子」这个节点对应的「`2`」返回给`Server`层，然后聚簇索引中回表拿数据。

相较于没有索引下推之前，原本需要做「`2、5`」两次回表查询，但在拥有索引下推之后，仅需做「`2`」一次回表查询。

> 引下推在`MySQL5.6`版本之后是默认开启的，可以通过命令`set optimizer_switch='index_condition_pushdown=off|on';`命令来手动管理。

























## IDE（集成开发环境）—IDEA

1. IDEA 全称 IntelliJ IDEA 
2. 在业界被公认为最好的 Java 开发工具 
3. IDEA 是 JetBrains 公司的产品，总部位于捷克的首都布拉格 
4. 除了支持 Java 开发，还支持 HTML，CSS，PHP，MySQL，Python 等

![image-20240301181316349](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301181316349.png) 

**版本：**IDEA 2020.2

### IDEA 常用快捷键

1. 删除当前行：默认是Ctrl + Y，改为**Ctrl + D**（）
2. 复制当前行：（搜索duplicate），改为**Ctrl + Alt + 向下箭头**（）
3. 代码补全：**Alt + /**
4. 添加注释和取消注释： **Ctrl + /** 
5. 导入该行需要的类：**Alt+Enter** 
6. 快速格式化代码： **Ctrl + Alt + L**
7. 快速运行程序：默认是Shift + F10 ，改为**Alt + R**（）
8. 生成构造器等：**Alt + Insert**
9. 查看一个类的层级关系： **Ctrl + H**
10. 将光标放在一个方法上，输入 **Ctrl + B** （或者**Ctrl + 鼠标左键**）, 可以定位到方法 
11. **ctrl + alt + <**-- (左）；回到上一个方法；**ctrl + alt + -->** (右）；回到下一个方法。搭配上一步使用
12. **ctrl + alt + 左方向键**-- (左）；回到上一个光标；**ctrl + alt + 右方向键** (右）；回到下一个光标。搭配上一步使用
13. 自动的分配变量名 , 通过 在后面加 **.var** ；自动生成增强for循环，通过 在后面加**.for**
14. 自动的填写输出函数，通过后面加**.sout**
15. 查看快捷键的快捷键：**Ctrl + J**
16. 快速生成迭代器的while：**i t i t**
17. 增强for循环： **I（大写）**
18. 异常处理、同步代码块快捷键：**Ctrl + Alt + T**
19. **按住Alt键，然后拖动鼠标**，实现多行代码的同时修改；**Alt + Shift 点击鼠标**，实现特定位置的同时修改
20. 按住**Shift + Enter**可以实现**直接换行**的操作
21. Alt+Shift+上下键，可以实现**上下移动行**
22. **ctrl + w**，关闭当前页
    File—>settings—>keymap—>main menu—>Edit—>Extend Selection—>取消原有快捷键
    然后再File—>settings—>keymap—>main menu—>window—>editor [tabs](https://so.csdn.net/so/search?q=tabs&spm=1001.2101.3001.7020)—>close Tab—>设置ctrl + w快捷键

### 自定义模板

![image-20240301183836222](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301183836222.png) 

### 自动添加注释

![image-20240326170931531](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240326170931531.png)

### 断点调试

**断点调试介绍：**

![image-20240303090429018](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303090429018.png) 

**断点调试的快捷键：**

**F7(跳入)** 

**F8(跳过)** 

**shift+F8(跳出)** 

**F9(resume,执行到下一个断点)**

（断点可以在 debug 过程中，动态的下断点）

### 获得CPU的内核数

~~~java
System.out.println(Runtime.getRuntime().availableProcessors());
~~~

### 获得当前系统时间

~~~java
System.currentTimeMills()
~~~

### 查看系统的环境变量

~~~java
public static void main(String[] args) throws Exception{
    Map<String, String> env = System.getenv();
    System.out.println(env);
}
~~~



### 创建普通maven工程项目

**在已有项目中创建普通maven工程：**

1. 右键项目选择 new -> Module
   ![image-20240411092247988](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240411092247988.png) 

2. 选择 new Module , build system 选择maven
   ![image-20240411092452805](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240411092452805.png) 

3. **问题：**在idea2023中，**不能通过Maven Archetype创建普通的Maven项目**
   ![image-20240411092809515](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240411092809515.png) 

### 创建Archetype的Meaven项目

1. 创建带WebApp骨架的Meaven项目，这个带SpringMVC框架的依赖
   ![image-20240416135050731](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240416135050731.png) 

2. 等待Meaven初始化，然后完善项目结构
   ![image-20240416135221360](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240416135221360.png) 

   ![image-20240416135449310](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240416135449310.png) 

### 创建数据库表

1. 创建Mysql数据源
   ![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240416133749482.png) 

2. 填写连接名、主机、端口号、数据库用户名、密码，并测试连接
   ![image-20240416134020221](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240416134020221.png)

3. 勾选你需要的schemas，在你的schemas中创建数据表
   ![image-20240416134238274](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240416134238274.png)  
4. 打开专属于cjy这个scheam的控制台
   ![image-20240416134655750](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240416134655750.png) 

5. 直接在控制器中通过Sql语句创建数据库表
   ![image-20240416134757297](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240416134757297.png) 

## Navicat(数据库管理工具)

### Navicat快捷键

1. **ctrl+q** ：打开查询窗口 
2. **ctrl+/** ：注释
3. **ctrl+r** ：运行查询窗口的sql语句 
4. **ctrl+shift+r** ：只运行选中的sql语句 
5. **ctrl+u** ：转换为小写
6. **ctrl+shift+u** ：转换为大写
7. **ctrl+w** ：关闭当前窗口

### Navicat中执行sql语句

1、打开Navicat后双击查询

![image-20240505104304535](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505104304535.png) 

2、点击新建查询

![image-20240505104336025](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505104336025.png) 

3、选择需要操作的数据库，然后编写sql语句，编写完成后点击运行即可，运行后下方会弹出运行结果

![image-20240505104434575](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505104434575.png) 

### 图形化创建二级索引

1. **打开数据库 --> 找到对应的表 --> 右键 --> 设计表 --> 点击索引**

   ![image-20240505110801812](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505110801812.png) 

2. **输入二级索引名称（自定义）**

   ![image-20240505111105175](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505111105175.png) 

3. **选择要添加的字段(比如：我现在要把name作为二级索引，它会自动关联到主键id)**

​	<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505111140724.png" alt="image-20240505111140724" style="zoom: 80%;" /> 

4. **选择索引类型(有四种)**

​	![image-20240505111215893](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505111215893.png) 

> 1. Normal（普通索引）：
>    - 普通索引是最常见的索引类型。
>    - 它用于加速查询操作，提高查询性能。
>    - 允许重复值，可以在一个字段上创建多个普通索引。
> 2. Unique（唯一索引）：
>    - 唯一索引要求索引列的值是唯一的，不允许重复值。
>    - 它用于保证数据的唯一性约束。
>    - 唯一索引可以加速唯一性检查和查找操作。
>
> 3. Fulltext（全文索引）：
>       \- 全文索引用于支持全文搜索功能。
>       \- 它可以在文本数据中快速搜索关键词，支持模糊搜索、分词和关键词匹配等操作。
>       \- 全文索引适用于文本处理和搜索引擎等应用场景。

5. **选择索引的数据方法（B树，哈希)，通常选用B树方法**

​	![image-20240505111340935](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505111340935.png)

6. **ctrl+s保存**

   ![image-20240505111415640](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505111415640.png) 

进过这样6步，就在navicat中定义好了一个二级索引

### 命令行创建二级索引

~~~sql
alter table t_user add key idx_name_length ((length(name)));
~~~

给t_user表中新增了一个名为idx_name_length的二级索引，这个索引关联的是name属性的长度，length是mysql内置的函数。

等同于：

![image-20240505113311704](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240505113311704.png) 







# **前端笔记**

## HTML

##### 描述：

用于定义网络结构的基本技术

##### 基本语法：

<开始标签>	内容	<结束标签>

![image-20240115105017529](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115105017529.png)

##### 标签：

+ ###### **分区div**

  div是一个纯粹的容器，<div>元素在语义上不表示任何特定类型的内容。然而，其可以将内容分组，从而可以使用**class**或是**id**属性方便的定义内容的格式。

+ ###### **标题h1~h6**

  HTML `<h1>`–`<h6>` 标题 (Heading) 元素呈现了六个不同的级别的标题，`<h1>` 级别最高，而 `<h6>` 级别最低。

+ ###### **段落p**

   **`<p>`** 元素表示文本的一个段落。段落是块级元素。

+ ###### **图像img**

  <img> 元素将一张图像嵌入文档

  ![image-20240115110304202](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115110304202.png) 

  - `src` 属性是**必须的**，它包含了你想嵌入的图片的路径。
  - `alt` 属性包含一条对图像的文本描述，这不是强制性的。如果由于某种原因无法加载图像，普通浏览器也会在页面上显示 `alt` 属性中的备用文本：例如，网络错误、内容被屏蔽或链接过期。

+ ###### **列表ul/ol**

  **`<ul>`** 元素表示一系列无序的列表项目，通常渲染为项目符号列表。

  ![image-20240115110519215](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115110519215.png) 

  **`<ol>` **元素表示有序列表，通常渲染为一个带编号的列表。

  ![image-20240115110655736](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115110655736.png) 

+ ###### **超链接a**

  <a> 元素（或称锚元素）可以通过它的 href 属性创建通向其他网页、文件、电子邮件地址、同一页面内的位置或任何其他 URL 的超链接。

  <a> 中的内容应该指明链接的目标。如果存在 href 属性，当 <a> 元素聚焦时按下回车键就会激活它。

  <a>中的href属性可以使用**文本片段**链接到某一段文字：这时点击a标签会直接跳转到相应的标签

  ![image-20240115111039304](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115111039304.png) 

+ ###### **表单form**

  **`<form>` 元素**表示文档中的一个区域，此区域包含交互控件，用于向 Web 服务器提交信息。

  ```html
  action:处理表单提交的 URL。这个值可被 <button>、<input type="submit"> 或 <input type="image"> 元素上的 formaction 属性覆盖。
  method:浏览器使用这种 HTTP 方式来提交 表单。可能的值有：
  	post：指的是 HTTP POST 方法；表单数据会包含在表单体内然后发送给服务器。
      get：指的是 HTTP GET 方法；表单数据会附加在 action 属性的 URL 中，并以 '?' 作为分隔符，没有副作用 时使用这个方法。
  <form action="" method="get" class="form-example">
    <div class="form-example">
      <label for="name">Enter your name: </label>
      <input type="text" name="name" id="name" required />
    </div>
    <div class="form-example">
      <label for="email">Enter your email: </label>
      <input type="email" name="email" id="email" required />
    </div>
    <div class="form-example">
      <input type="submit" value="Subscribe!" />
    </div>
  </form>
  ```

   ![image-20240115111322271](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115111322271.png)

+ ###### **表格table**

  **table**元素表示表格数据——即在一个由包含数据的行和列组成的二维表格中呈现的信息。

  ```html
  <table>
    <thead>
      <tr>
        <th colspan="2">The table header</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>The table body</td>
        <td>with two columns</td>
      </tr>
    </tbody>
  </table>
  ```

  ![image-20240115111909442](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115111909442.png) 

+ ###### **框架iframe**

​	**HTML 内联框架元素 (`<iframe>`)** ,它能够将另一个 HTML 页面嵌入到当前页面中。目前我还没有用到这个。

##### HTML5特性：

###### 语义化标签：

当接近要使用的标记时，问问自己，“什么元素最能描述/表示我要填充的数据？”例如，它是数据列表吗？有序或无序？是否是一篇具有章节和相关信息旁注的文章？它是否列出了定义？它是需要标题的图形还是图像？除了全局网站范围的页眉和页脚之外，它还应该有页眉和页脚吗？等等。

写语义标记的一些好处如下：

- 搜索引擎将其内容视为影响页面搜索排名的重要关键字。

- 比起搜索无休止的带有或不带有语义/命名空间类的 `div`，找到有意义的代码块显然容易得多。

- 语义命名反映了正确的自定义元素/组件命名。

- 常见的语义化元素

  ```html
  <article>
  <aside>
  <detiales>
  <figcaption>
  <figure>
  <footer>
  <header>
  <main>
  <mark>
  <nav>
  <section>
  <summary>
  <time>
  ```



## 前端基础知识

##### 互联网：

互联网（[internet](https://baike.baidu.com/item/internet/272794?fromModule=lemma_inlink)），又称国际网络，指的是[网络](https://baike.baidu.com/item/网络/143243?fromModule=lemma_inlink)与网络之间所串连成的庞大网络，这些网络以一组通用的[协议](https://baike.baidu.com/item/协议/13020269?fromModule=lemma_inlink)相连，形成逻辑上的单一巨大国际网络。

互联网始于1969年[美国](https://baike.baidu.com/item/美国/125486?fromModule=lemma_inlink)的[阿帕网](https://baike.baidu.com/item/阿帕网/1950726?fromModule=lemma_inlink)。通常[internet](https://baike.baidu.com/item/internet/272794?fromModule=lemma_inlink)泛指互联网，而Internet则特指[因特网](https://baike.baidu.com/item/因特网/114119?fromModule=lemma_inlink)。这种将[计算机网络](https://baike.baidu.com/item/计算机网络/18763?fromModule=lemma_inlink)互相联接在一起的方法可称作“网络互联”，在这基础上发展出覆盖全世界的全球性互联网络称互联网，即是互相连接一起的[网络结构](https://baike.baidu.com/item/网络结构/8259917?fromModule=lemma_inlink)。

##### 域名：

域名（英语：Domain Name），又称网域，是由一串用点分隔的名字组成的[互联网](https://baike.baidu.com/item/互联网/199186?fromModule=lemma_inlink)上某一台[计算机](https://baike.baidu.com/item/计算机/140338?fromModule=lemma_inlink)或计算机组的名称，用于在[数据传输](https://baike.baidu.com/item/数据传输/2987565?fromModule=lemma_inlink)时对计算机的定位标识（有时也指地理位置）。 [1]

由于[IP地址](https://baike.baidu.com/item/IP地址/150859?fromModule=lemma_inlink)不方便记忆并且不能显示地址组织的名称和性质，人们设计出了域名，并通过[域名系统](https://baike.baidu.com/item/域名系统/2251573?fromModule=lemma_inlink)（DNS，Domain Name System）来将域名和IP地址相互[映射](https://baike.baidu.com/item/映射/20402621?fromModule=lemma_inlink)，使人更方便地访问互联网，而不用去记住能够被机器直接读取的IP地址数串。

##### DNS：

DNS（Domain Name System）域名系统，是一个层次化、分散化的互联网连接资源命名系统。DNS 维护着一个[域名](https://developer.mozilla.org/zh-CN/docs/Glossary/Domain_name)列表以及与之相关联的资源（例如 IP 地址）。

DNS 最突出的功能是将易于记忆的域名（例如 mozilla.org）翻译成为数字化的 [IP 地址](https://developer.mozilla.org/zh-CN/docs/Glossary/IP_Address)（例如 151.106.5.172）；这一从域名到 IP 地址的映射过程被称为**DNS 查询**（DNS lookup）。与之对应，**DNS 反向查询**（rDNS）用来找到与 IP 地址对应的域名。

##### 服务器：

服务器是为用户（通常称为客户端）提供服务的软件或硬件。硬件而言的服务器是互联网上的共享计算机，通常性能强劲且位于数据中心。软件而言的服务器（一般是运行在硬件服务器上）是一种向客户端程序或向[用户界面](https://developer.mozilla.org/zh-CN/docs/Glossary/UI)提供服务的程序。

我们一般在局域网或广域网（如互联网）提供服务。传统上，客户端程序和服务器程序通过 [API](https://developer.mozilla.org/zh-CN/docs/Glossary/API) 传递信息进行连接，这种信息使用[协议](https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol)编码。

举个例子：

- 连接到互联网的 Web 服务器向你的浏览器发送一个 [HTML](https://developer.mozilla.org/zh-CN/docs/Glossary/HTML) 文件，这样你就可以浏览页面。
- 用于文件、域名、邮件、打印机和传真机的局域网服务器。
- 数据中心的小型机、大型机和超算。

##### 浏览器：

**浏览器**是一种从 [Web](https://developer.mozilla.org/zh-CN/docs/Glossary/World_Wide_Web) 获取和显示页面的程序，并且让用户通过[超链接](https://developer.mozilla.org/zh-CN/docs/Glossary/Hyperlink)访问更多页面。浏览器是最常见的一种用户代理。

###### DOM事件流：

DOM(文档对象模型)结构是一个树型结构，当一个[HTML元素](https://baike.baidu.com/item/HTML元素/5983313?fromModule=lemma_inlink)产生一个事件时，该事件会在元素节点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为DOM事件流。

DOM同时支持两种事件模型：[捕获型事件](https://baike.baidu.com/item/捕获型事件/0?fromModule=lemma_inlink)和[冒泡型事件](https://baike.baidu.com/item/冒泡型事件/7508003?fromModule=lemma_inlink)，但是，捕获型事件先发生，冒泡型事件后发生。两种事件流会触发DOM中的所有对象，从[document对象](https://baike.baidu.com/item/document对象/6553996?fromModule=lemma_inlink)开始，也在document对象结束。

![image-20240225131301937](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225131301937.png) 

###### 事件委托：

当冒泡和捕获同时存在时，事件触发顺序为：捕获->目标（small就是目标）->冒泡。事件委托，也叫事件代理，一般指的是利用事件冒泡，将一个或者一组DOM的事件处理程序，委托给其父级元素或者更外层元素。**可以通过只指定一个事件处理程序，就可以管理一批同类型的事件处理程序**。

例如：如果需要给列表项添加事件，当列表项数量过多时，会存在频繁操作DOM的情况；并且函数是引用类型, 需要堆内存来存储，占用大量空间。**通过事件委托，可以将事件绑定到其父级元素ul上，这样只需要操作一次DOM，不会引起频繁的重绘。**也不会占用大量的空间。

```html
<!-- 通过事件的具体属性实现通过事件委托也和直接绑定在li上一样的效果--><!DOCTYPE html>
<html lang="en">
<body>
  <ul id='father'>
    <li id="a">A</li>
    <li id="b">B</li>
    <li id="c">C</li>
    <li id="d">D</li>
  </ul>
  <script>
  father.addEventListener('click', function(e) {
    const event = e；
    const target = event.target；
    // 根据事件属性判断当前所在的DOM节点，不同节点处理不同的程序（主要通过e.target,在父节点上定义的事件，可以处理子节点）
    switch(target.id) {
      case "a":
        console.log('a');
        break;
      case "b":
        console.log('b');
        break;
      case "c":
        console.log("c");
        break;
      case "d":
        console.log("d");
        break;
      default:
        console.log('default');
    }
  })
  </script>
</body>
</html>
```

###### 浏览器加载顺序：

1. HTML解析完毕

2. 外部脚本和样式加载完毕

3. 脚本在文档内解析并执行

4. HTML DOM完全构造起来

5. 图片个外部内容加载

6. 网页完全加载

**1-4执行是很快的，5很慢**

###### 浏览器渲染过程：

渲染流程大致可以划分为五个过程：

1. 构建DOM

   <img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240121114811031.png" alt="image-20240121114811031" style="zoom:50%;" /> 

2. 构建CSSOM

   <img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240121114842031.png" alt="image-20240121114842031" style="zoom:50%;" /> 

3. 构建渲染（render）树

   ![image-20240121114959429](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240121114959429.png) 

4. 布局

   获取渲染树的结构，节点位置和大小，然后依据盒子模型来进行布局

5. 绘制

   把渲染树以像素的形式绘制在页面上

![image-20240121114521130](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240121114521130.png) 

**（如果构建DOM的过程中，碰见js，则下载js，如果js没有额外的设置则需要等到CSSOM构建完成后才能执行js文件，js既可以对DOM做修改，也可以对CSSOM做修改）**



##### HTTP：

HTTP（Hyper Text Transformer Protocol，超文本传输协议）是一种通信协议，它允许将超文本标记语言（HTML）文档从Web服务器传送到客户端的浏览器。

它是一个应用层协议，承载于TCP协议之上。

###### HTTP1.0

HTTP/1.0是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。默认采用短连接。

HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。这种无状态性可以借助cookie/session机制来做身份认证和状态记录。

缺点，无连接的特性导致最大的性能缺陷就是无法复用连接。每次发送请求的时候，都需要进行一次TCP的连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率非常低。

###### HTTP1.1

HTTP/1.1版本，持久连接/长连接被默认采用（默认模式使用带流水线的持久连接），并能很好地配合代理服务器工作，还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。

###### HTTP请求方法

1. GET

   请求指定的页面信息，并返回实体主体。

   注：GET也可以将数据提交到服务器，不过一般都是使用POST提交数据到服务器.

2. POST

   POST请求方法的作用：向服务器发送数据。

   POST和GET请求方法的本质区别：

   ​    1、GET用于信息获取，它是安全的（这里安全的含义是指非修改信息），而POST是用于修改服务器上资源的请求；

   ​    2、GET请求的数据会附在URL之后（然后提交到服务器），而POST把提交的数据则放置在HTTP实体的主体里，所以，POST的安全性要比GET的安全性高；

   ​    3、GET方式提交数据和POST方法提交数据并没有限制数据大小。

3. HEAD

   HEAD请求方法作用：只请求头部，允许客户端在未获取资源实体的情况下，对资源的头部检查，了解资源的基本情况，比如类型，是否被修改过等。

   HEAD和GET请求方法的区别：GET请求回来的报文有实体的主体部分，而HEAD请求回来的报文没有实体的主体部分。

###### 状态码

2xx 成功

3xx 重定向

4xx 客户端报错

5xx 服务端报错

###### Cookie

是某些网站为了辨别用户身份，进行[Session](https://baike.baidu.com/item/Session/479100?fromModule=lemma_inlink)跟踪而储存在用户本地终端上的数据（通常经过加密），由用户[客户端](https://baike.baidu.com/item/客户端/101081?fromModule=lemma_inlink)计算机暂时或永久保存的[信息](https://baike.baidu.com/item/信息/111163?fromModule=lemma_inlink) 。

###### HTTPS

HTTPS （全称：Hypertext Transfer Protocol Secure [5]），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和[身份认证](https://baike.baidu.com/item/身份认证/5294713?fromModule=lemma_inlink)保证了传输过程的安全性 。HTTPS 在HTTP 的基础下加入[SSL](https://baike.baidu.com/item/SSL/320778?fromModule=lemma_inlink)，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。

## Git

#### git基础命令笔记：

git remote -v查看配置了的远程连接的名称

git remote add origin https://github.com/RJrowlling/ExerciseProject.git 配置远程连接，连接本地仓库和远程仓库

git remote rm origin 删除配置了的远程连接



git branch 查看分支名称

git branch issue1 新建分支

git branch -d issue1 删除分支

git checkout mian 切换分支



git add README.md 将READNE.md文件添加到索引暂存区

git commit -m "将暂存区里的索引同步到本地数据库上，并设置了message"

git push origin main 将本地仓库的数据推送到远程仓库的main分支中



git revert HEAD撤消上一次提交的更改。

1. 注意这里只是从本地仓库中还原了上一次提交的更改，如果你已经push到远程仓库，则远程仓库不变，除非你再次push
2. Git revert 命令将一个提交作为参数，并**创建一个新的提交来撤消该提交所做的更改**。

#### 把本地项目上传到github上出现了问题？

![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240127160257601.png) 

![image-20240127160239654](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240127160239654.png) 

##### 1. 没有在github上面关联公钥

基础的内容已经配置好了（用户名，电子邮箱，本地钥匙都有），首先进入C:\Users\cjy\\.ssh目录文件下找到id_rsa.pub公钥，打开记事本复制内容到下图（配置好后，github会给你发电子邮件）

![image-20240127160036193](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240127160036193.png) 

##### 2.网络连接问题

ping github.com时，会显示超时，这就是网络连接问题。通过ip查询https://ipaddress.com/website/github.com找到github.com的ip地址，例如（140.82.113.4）

![image-20240127160751778](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240127160751778.png)

此时修改本地 DNS 文件 C:\Windows\System32\drivers\etc 目录下的 hosts 文件，由于该文件在 C 盘中，无法直接打开进行修改，需要使用管理员权限，此处操作方式为，搜索 记事本 软件，右键以管理员身份运行，选择上述 hosts 文件打开，在文件内容最下方加入一行

```
140.82.113.4    github.com
```

## Node.js

定义：node.js是一个开源的，跨平台的JavaScript运行环境

安装：https://blog.csdn.net/zxy15974062965/article/details/121117803

### 包管理工具

包：package，代表了一组功能的源码集合

包管理工具：管理【包】的应用软件，进行下载安装、更新、删除操作

#### npm

npm全称node package Manage【node的包管理工具】

npm是node.js官方**内置的**包管理工具

##### npm 全局安装 ：

```
npm i -g <包名>

npm root -g
```

全局安装的命令不受工作目录位置的影响，**而且安装的位置不是在当前工作目录的node_module，而是在全局安装包的位置**，可以通过**npm root -g** 可以查看全局安装包的位置；而且并不是所有包都适合全局安装。

##### **windows会对全局安装的脚本进行约束，不让它运行？**

可以通过修改windows的执行策略来解决这个问题，具体：输入：set-ExecutionPolicy remoteSigned

![image-20240201094202340](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240201094202340.png)

##### **npm 安装所有依赖**：

```
npm i
npm install
```

通过该命令可以依据package.json和package-lock.json的依赖声明，安装项目所有依赖（**node-modules文件夹大多数情况是不会存入版本库的**），只有安装完所有依赖才能够正常启动项目

##### 安装指定版本的包：

```
npm i <包名@版本号>
例子：
npm i jquery@1.11.2
```

##### 删除依赖：

```
局部删除：
npm remove unip
全局删除：
npm remove -g nodemon
```

##### npm 配置命名别名：

可以通过命名别名可以更简单的执行命令，具体来说，配置package.json中的scripts属性

![image-20240201100222985](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240201100222985.png)

##### cnpm：

cnpm是淘宝构建的npmjs.com的完整镜像，也称为**淘宝镜像**，cnpm服务部署在国内阿里云服务器上，可以提高包的下载速度。

**淘宝镜像源官网：**https://www.npmmirror.com/，这里可以获得第一手的镜像网站

**官方也提供了一个全局工具包cnpm**（不是内置的），操作命令与npm大体相同。

**安装cnpm：**

```
npm install -g cnpm --registry=https://registry.npmmirror.com
```

##### npm配置淘宝镜像：

npm 也可以使用淘宝镜像源，直接配置：



```
 npm config set registry https://registry.npmmirror.com

在配置之前，先 npm config list查看，并保存一下原来的registry，方便后面改回来
"https://registry.npmjs.org/"这是npm原有的数源
```

**使用了淘宝镜像源之后，就不要搭梯子了，关掉梯子，yarn才能正常运行。**

#### Yarn

介绍：yarn是由Facebook推出的JavaScript包管理工具

特点：速度超快，会缓存包，所以下次下载无需重复下载。并行下载

安装：

```
npm i -g yarn
```

##### yarn常用命令

![image-20240201103854636](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240201103854636.png)

##### yarn全局安装

查询 yarn 安装依赖的全局路径 

```
yarn global bin
```

修改 yarn 全局 bin 位置 ，这个就是yarn之后安装全局依赖的位置，**但是注意，要修改环境变量，才能使yarn全局安装的包正常运行**

```
yarn config set prefix "D:\nodejs\node_modules\yarn\bin"
```

##### yarn配置淘宝镜像

```
yarn config set registry https://registry.npmmirror.com

在配置之前，先 yarn config list查看，并保存一下原来的registry，方便后面改回来
```

**使用了淘宝镜像源之后，就不要搭梯子了，关掉梯子，yarn才能正常运行。**

## React



## VScode使用

##### VScode怎么运行js文件？

+ **使用内置终端**

  首先，我们需要打开一个JS文件，然后按下“Ctrl+Shift+`”键，打开终端界面，可以在其中输入“**node 文件名.js**”命令来运行JS文件。

+ **使用Code Runner插件**

​	安装Code Runner插件，打开一个JS文件，然后按下**“Ctrl+Alt+N”键**，Code Runner会自动运行当前打开的JS文件，并在底部显示输出结果。

+ **使用Live Server插件**

​	在VSCode中安装Live Server插件，打开一个HTML文件，然后按下**“Alt+L”键**，此时，Live Server会自动启动一个本地服务器，并在浏览器中打开我们的HTML文件。如果HTML文件中引用了JS文件，Live Server也会自动运行这些JS文件。

##### VScode怎样调试js文件？

1. 首先要加断点

   ![image-20240117163505090](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117163505090.png) 

2. 点击JavaScript调试终端

   ![image-20240117163526777](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117163526777.png) 

3. 在终端里面输入node 文件名.js，回车

​	![image-20240117163613470](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117163613470.png) 

4. 在左侧进行调试

​	<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117163831404.png" alt="image-20240117163831404" style="zoom:50%;" /> 

# 博客笔记

为了以后的深入学习，一定要培养自己看文档的习惯。为了能够使自己适应看文档的习惯，现在强制自己在每看完一篇文章后输出一篇博客，并发布到博客平台。



## Java核心技术卷

主要是写一些对于Java核心技术卷的观后感或笔记，然后发布到知识星球上面，强制自己适应对于文字的阅读，为以后的阅读文档打下良好的基础。

标题：**Java核心技术卷读书笔记：第一章 Java 程序设计概述**

### 01：Java 程序设计概述

Java的第一次发布就引起了人们的极大兴趣，Java 是一种功能齐全的出色语言，是一个高质量的执行环境， 还提供了一个庞大的库。正是因 为它集多种优势于一身，所以对广大的程序设计人员有着不可抗拒的吸引力。

**Java白皮书有11 个关键术语：**

1 ) 简单性 2 ) 面向对象 3 ) 分布式 4 ) 健壮性 5 ) 安全性 7 ) 可移植性 8 ) 解释型 9 ) 高性能 10 ) 多线程 11 ) 动态性 6 ) 体系结构中立

1. 简单性：Java 语法是 C++ 语法的一个“ 纯净” 版本，这里没有头文件、 指针运算、结构、 联合、 操作符重载、 虚基类等。简单的另一个方面是小，现在有 一个独立的具有较小类库的 Java 微型版。
2. 面向对象：开发 Java 时面向对象技术已经相当成熟。 Java 的面向对象特性与 C++ 旗鼓相当。Java 与 C++ 的主要不同点在于多重继承，在 Java 中，取而代之的是更简单的接口概念。
3. 分布式：Java 有一个丰富的例程库，用于处理像 HTTP 和 FIT 之类的 TCP/IP 协议。
4. 健壮性：Java 编译器能够检测许多在其他语言中仅在运行时才能够检测出来的问题。
5. 安全性：从一开始，Java 就设计成能够防范各种攻击，不过，Java 的安全模型很复杂。遭遇多次高调攻击之后， 浏览器开发商和 Oracle 都越来越谨慎 。现在看来， 尽管 Java 安全模型没有原先预想的那么成功， 但 Java 在那个时代确 实相当超前。
6. 体系结构中立：编译器生成一个体系结构中立的目标文件格式，这是一种编译过的代码， 只要有 Java 运行时系统， 这些编译后的代码可以在许多处理器上运行。
7. 可移植性：在 Java 中，数据类型具有固定的大小， 这消除了代码移植时令 人头痛的主要问题。
8. 解释性：Java 解释器可以在任何移植了解释器的机器上执行 Java 字节码
9. 高性能：尽管对解释后的字节码性能已经比较满意，但在有些场合下还需要更加高效的 性能。字节码可以（在运行时刻）动态地翻译成对应运行这个应用的特定 CPU 的机 器码。即时编译器可以监控经常执行哪 些代码并优化这些代码以提高速度。
10. 多线程：多线程可以带来更好的交互响应和实时行为。Java 在当时很超前，它是第一个支持并发程序设计的主流语言。
11. 动态性：从各种角度看， Java 与 C 或 C++ 相比更加具有动态性。它能够适应不断发展 的环境。例如：在 Java 中找出运行时类型信息十分简单

**Java发展简史：**

Java 的历史要追溯到 1991 年，由 Patrick Naughton 和 James Gosling Sun 带领的Sun公司的工程师小组想要设计一种小型的计算机语言， 这个项目被命名为“ Green”。这个“ Green”项目代码短小、 紧凑且与平台无关， 这些要求促使开发团队设计一个可移植的语言， 可以为 虚拟机生成中间代码。Gosling 把这种语言称为“ Oak ”，后来发现 Oak 是一种已有的计算机语言的 名字，于是， 将其改名为 Java。

1996 年年初，Sun 发布了 Java 的第 1 个版本。人们很快地意识到 Java1.0 不能用来进行 真正的应用开发。后 来的 Java 1.1弥补了其中的大多明显的缺陷 。 大大改进了反射能力，并为 GUI 编程增加了新 的事件处理模型：不过它仍然具有很大的局限性。

1998 年 JavaOne 会议的头号新闻是即将发布 Java 1.2 版。这个版本取代了早期玩具式的 GUI, 并且它的图形T.具箱更加精细而具有可伸缩性，更加接近“ 一次编写， 随处运行” 的 承诺。除了‘ 标准版’ 之外，Sun 还推出了两个其他的版本：一个是用于手机等嵌人式设备的‘ 微 型版”；另一个是用于服务器端处理的“ 企业版”。

标准版的 1.3 和 1.4 版本对最初的 Java 2 版本做出了某些改进， 扩展了标准类库，提高 系统性能。

5.0 版是自 1.1 版以来第一个对 Java 语言做出重大改进的版本（这一版本原来被命名为 1.5 版，在 2004 年的 JavaOne 会议之后，版本数字升至 5.0 )。

版本 6 ( 没有后缀 .0 ) 于 2006 年年末发布。 同样，这个版本没有对语言方面再进行改进。 但是，改进了其他性能，并增强了类库。

Sun Microsystems 公司沦陷， 于 2009 年被 Oracle 收购 _ Java 的开发停滞了很长一段时间。

2011年 Oracle 发布了 Java 的一个新版本，Java 7, 其中只做了一些简单的改进。

2014 年 ,Java 8终于发布，在近 20 年中这个版本有了最大的改变。Java 8 提供了一种“ 函数式” 编程方式，可以很容易地表述并发执行的计算。 所有编程语言都必须与时俱进，Java 在这方面显示出非凡的能力

![image-20240317210923604](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240317210923604.png) 

**关 于 Java 的常见误解：**

Java 是 HTML 的扩展：两者没有任何共同之处

Java 是一种非常容易学习的程序设计语言：像 Java 这种功能强大的语言大都不太容易学习。

Java 是解释型的， 因此对于关键的应用程序速度太慢了：早期的 Java 是解释型的。 现在 Java 虚拟机使用了即时编译器， 因此采用 Java 编写的 “ 热点” 代码其运行速度与 C++ 相差无几， 有些情况下甚至更快。

JavaScript 是 Java 的简易版：JavaScript 的语法类似 Java, 除此之外，两者无任何关系。

Java 只不过是另外一种程序设计语言：Java 是一种很好的程序设计语言，程序设计语言的成功更多地取决于其支撑系统的能力， 而不是优美的语 法。Java 的成功源于其类库能够让人们轻松地完成原本有一定难度的事情。

Java 将成为适用于所有平台的通用性编程语言：从理论上讲， 这是完全有可能的。 但在实际中， 某些领域其他语言有更出色的表现。

### 03：Java 的程序设计结构

本章主要介绍程序设计的基本概念（如数据类型、分支以 及循环）在 Java 中的实现方式。

**一个简单的 Java 应用程序：**

public class FirstSample { 

​	public static void main(String[] args) { 

​		System.out.println("We will not use 'Hello, World!"'); 

​	} 

} 

1. 首先，Java 区分大小写。 如果出现了大小写拼写错误（例如， 将 main 拼写成 Main), 程序将无法运行

2. 关键字 public 称为访问修饰符（access modifier), 这 些修饰符用于控制程序的其他部分对这段代码的访问级別
3. 关键字 class 表明 Java 程序中的全部内容都包含在类中，Java 应用程序中的全部内容都必须放置在类中
4. 关键字 class 后面紧跟类名。 Java 中定义类名的名字必须以字母开头，后面可以跟字母和数字的任意组合，但是不能使用 Java 保留字
5. 标准的类命名规范为（FirstSample）大驼峰：类名是以大写字母开头的名 词，如果名字由多个单词组成，每个单词的第一个字母都应该大写
6. 源代码的文件名必须与公共类的名字相同，并用 .java 作为扩展名
7. 在编译这段源代 码之后就会得到一个包含这个类字节码的文件，Java 编译器将字节码文件自动地命名为 FirstSample. class, 并与源文件存储在同一个目录下
8. 每个 Java 应用程序都 必须有一个 main 方法
9. 在 Java 中，每个句子必须用分号结束。 特别需要说明，回车不是语句的结束标志
10. 在这里，使用了 System.out 对象并调用了它的 println 方法。注意， 点号（ • ）用于调用 方法

**注 释：**

Java 中的注释不会出现在可执行程序中。因此， 可以在 源程序中根据需要添加任意多的注释，而不必担心可执行代码会膨胀。在 Java 中，有 3 种标 记注释的方式。

1. 最常用的方式是使用 //，其注释内容从 // 开始到本行结尾。
2. 当需要长篇的注释时， 既可以在每行的注释前面标记 //，也可以使用 /* 和 */ 将一段比较 长的注释括起来。
3. 第 3 种注释可以用来自动地生成文档。这种注释以 / ** 开始， 以 */ 结束

在 Java 中，/* **/ 注释不能嵌套 „ 也就是说， 不能简单地把代码用 /* *和 */ 括起来 作为注释， 因为这段代码本身可能也包含一个 */ 

**数 据 类 型:**

Java 是 -种强类型语言。这就意味着必须为每一个变量声明一种类型。在 Java 中， -共有 8 种基本类型（ primitive type ), 其中有 4 种整型、2 种浮点类型、 1 种用于表字符类型 char  和 1 种用于表示真值的 boolean 类型。

1. 整型
   1. byte型，1字节，
   2. short型，2字节
   3. int型，4字节
   4. long型，8字节，长整型数值有一个后缀 L 或 1 ( 如 4000000000L。)

​	注意， Java 没有任何无符号（unsigned) 形式的 int、 long、short 或 byte 类型。

2. 浮点类型

   1. float类型，4字节，float 类型的数值有一个后缀 F 或 f (例如，3.14F）
   2. double类型，8字节，没有后缀 F 的浮点数值（如 3.14 ) 默 认为 double 类型。

   下面是用于表示溢出和出错情况 的三个特殊的浮点数值：

   •正无穷大 ，常量 Double_POSITIVE_INFINITY

   •负无穷大，Double.NEGATIVEJNFINITY

    •NaN (不是一个数字），Double.NaN，特别要说明的是， 不能这样检测一个特定值是否等于 Double.NaN：
   	if (x = Double.NaN) // is never true 所有“ 非数值” 的值都认为是不相同的，然而，可以使用 Double.isNaN 方法：

   ​	if (Double.isNaN(x)) // check whether x is "not a number"

   注意： 浮点数值不适用于无法接受舍入误差的金融计算中。 例如，命令 System.out.println ( 2.0-1.1 ) 将打印出 0.8999999999999999, 而不是人们想象的 0.9。这种舍入误差的主要 原因是浮点数值采用二进制系统表示， 而在二进制系统中无法精确地表示分数 1/10。

3. char 类型

   char 类型原本用于表示单个字符，如今，有些 Unicode 字符可以用一个 char值描述，另外一些 Unicode 字符则需要两个 char 值。char 类型的字面量值要用单引号括起来。例如：‘A’ 是编码值为 65 所对应的字符常量。它与 "A" 不同，"A" 是包含一个字符 A 的字符串。

   char 类型的值可以表示为十六进制值，其 范围从 \u0000 到 \Uffff。例如：\u03C0 表示希腊字母 π。除了转义序列 \u 之外， 还有一些用于表示特殊字符的转义序列，\b 退格，\n 换行（\u00A0），\t 制表（对应\u0009）。更隐秘地， 一定要当心注释中的 \u。注释 // \u00A0 is a newline。会产生一个语法错误， 因为读程序时 \u00A0 会替换为一个换行符。

4. boolean 类型

   boolean (布尔）类型有两个值：false 和 true, 用来判定逻辑条件 整型值和布尔值之间 不能进行相互转换

**变 量：**

1. 在 Java 中，每个变量都有一个类型（ type)。在声明变量时，变量的类型位于变量名之 前。
   double salary;

2. 尽管 $ 是一个合法的 Java 字符， 但不要在你自己的代码中使用这个字符。它只用 在 Java 编译器或其他工具生成的名字中。

3. 声明一个变量之后，必须用赋值语句对变量进行显式初始化， 千万不要使用未初始化的 变量。要想对一个已经声明过的变量进行赋值， 就需要将变量名放在等号（=) 左侧， 相应取值 的 Java 表达式放在等号的右侧。
   int vacationDays; 
   vacationDays=12;

4. 在 Java 中， 变量的声明尽可能地靠近变量第一次使用的地方， 这是一种良好的程序编写 风格

5. 在 Java 中， 利用关键字 final 指示常量。final double CM_PER_INCH = 2.54;关键字 final 表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上, 常量名使用全大写。

**运 算 符：**

在 Java 中，使用算术运算符 + 、-、 * 、/ 表示加、减、 乘、除运算。 

1. 当参与 / 运算的两个 操作数都是整数时， 表示整数除法；否则， 表示浮点除法。

2. 整数的求余操作（有时称为取模) 用 ％ 表示。例如，15/2 等于 7 ，15%2 等于 1 , 15.0/2 等于 7.50

3. 在 Math类中，包含了各种各样的数学函数。println 方法和 sqrt 方法存在微小的差异。println 方法处理 System.out 对象。但是， Math 类中的 sqrt 方法处理的不是对象，这样的方法被称为静态方法。Java 还提供了两个用于表示 TC 和 e 常量的近似值Math.PI Math.E

4. 自动类型转换：
   byte ——short——int——long ——float——double
   char——int——long——float——double

5. 强制类型转换：

   在必要的时候， int 类型的值将会自动地转换为 double 类型。但另 一方面，有时也需要将 double 转换成 int。 在 Java 中， 允许进行这种数值之间的类型转换。 当然， 有可能会丢失一些信息。在这种情况下，需要通过强制类型转换（ cast) 实现这个操 作。double x = 9.997;
   int nx = (int) x;
   这样， 变量 nx 的值为 9。强制类型转换通过截断小数部分将浮点值转换为整型。

6. 如果想对浮点数进行舍人运算， 以便得到最接近的整数（在很多情况下， 这种操作更有 用，) 那就需要使用 Math_ round 方法double x z 9.997; 
   int nx = (int) Math.round(x);
   现在， 变量 nx 的值为 10。 当调用 round 的时候， 仍然需要使用强制类型转换（ int) 其原因 是 round 方法返回的结果为 long 类型

7. X += 4; 等价于： x = x + 4;
   如果 X 是一个 int, 则以下语句 x += 3.5; 是合法的， 将把 X 设置为（int)(x + 3.5）。

8. n++ 将变量 n 的当前值加 1, n-- 则将 n 的值减 1
   上面介绍的是运算符放在操作数后面的“ 后缀” 形式。 还有一种“ 前缀” 形式：++n。后缀和前缀形式都会使变量值加 1 或减 1。但用在表达式中时， 二者就有区别了。前缀形式会先完成加 1; 而后缀形式会使用变量原来的值。

9. && 和丨| 运算符是按照“ 短路” 方 式来求值的： 如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。
   & 和丨运算符也会得到一个布尔值。这些运算符与 && 和丨丨运 算符很类似，不过 & 和丨运算符不采用“ 短路” 方式来求值， 也就是说，得到计算结果之前两个操作数都需要计算。

10. Java 支持三元操作符？：，这个操作符有时很有用。如果条件为 true, 下面的 表达式 condition ? expressioni : expression

11. 自定义枚举类型。枚举类型包括有限个命名的值，enum  Size { SMALL, MEDIUM, LARGE, EXTRA.LARCE };现在，可以声明这种类型的变量： Size s = Size.MEDIUM

**字 符 串:**

1. Java 没有内置的字符串类型， 而是在标准 Java 类库中提供了 一个预定义类，很自然地叫做 String。每个用双引号括起来的字符串都是 String类的一个实 例

2. String 类的 substring 方法可以从一个较大的字符串提取出一个子串。
   String greeting = "Hello"; 
   String s = greeting.substring（0, 3);创建了一个由字符“ Hel” 组成的字符串。

3. Java语言允许使用 + 号连接（拼接）两个字符串。当将一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串

4. String 类没有提供用于修改字符串的方法，由于不能修改 Java 字符串中的字符， 所以在 Java 文档中将 String 类对象称为不可变字 符串， 如同数字 3 永远是数字 3 —样。不可变字符串却有一个优点：编译器可以让字符串共享。总而言之，Java 的设计者认为共享带来的高效率远远胜过于提取、 拼接字符串所带来的 低效率。

5. 可以使用 equals 方法检测两个字符串是否相等，要想检测两个字符串是否相等，而不区分大小写， 可以使用 equalsIgnoreCase 方法。一定不要使用==运算符检测两个字符串是否相等！ 这个运算符只能够确定两个字串 是否放置在同一个位置上。
   当然， 如果字符串放置在同一个位置上， 它们必然相等。但是， 完全有可能将内容相同的多个字符串的拷贝放置在不同的位置上
   String greeting = "Hello"; //initialize greeting to a string 
   if (greeting == "Hello") . // probably true 
   if (greeting.substring(0, 3) == "HeV") . . . // probably false

6. 空串 "" 是长度为 0 的字符串。空串是一个 Java 对象， 有自己的串长度（ 0 ) 和内容（空）。不过， String 变量还可以存 放一个特殊的值， 名为 null, 这表示目前没有任何对象与该变量关联

7. 调用 s.charAt(n) 将返回位置 n 的代码单元，n 介于 0 ~ s.length()-l 之间。

**输入输出:**

1. 打印输出到“ 标准输出流”（即控制台窗口）是一件非常容易的事情，只要 调用 System.out.println 即可。然而，读取“ 标准输人流” System.in 就没有那么简单了。要想通 过控制台进行输人，首先需要构造一个 Scanner 对象，并与“ 标准输人流” System.in 关联。Scanner in = new Scanner(System.in);

2. 现在，就可以使用 Scanner 类的各种方法实现输入操作了。String name = in.nextLine();
   要想读取一个整数， 就调用 nextlnt 方法。要想读取下一个浮点数， 就调用 nextDouble 方法

3. 可以使用 SyStem.0ut.print(x) 将数值 x 输出到控制台上。这条命令将以 x 对应的数据类型 所允许的最大非 0 数字位数打印输出 X。在 printf中，可以使用多个参数， 例如： 
   System.out.printf("Hello, %s. Next year, you'll be SSd", name, age)

4. 每一个以 ％ 字符开始的格式说明符都用相应的参数替换。 格式说明符尾部的转换符将指示被 格式化的数值类型：f 表示浮点数，s 表示字符串，d 表示十进制整数。

5. 可以使用静态的 String.format 方法创建一个格式化的字符串， 而不打印输出： 
   String message = String.format("Hello, %s. Next year, you'll be %d", name , age);

6. 要想对文件进行读取，就需要一个用 File 对象构造一个 Scanner 对象
   Scanner in = new Scanner(Paths.get("niyflle.txt"), "UTF-8")

**控 制 流 程：**

与任何程序设计语言一样， Java 使用条件语句和循环结构确定控制流程

1. 块（即复合语句）是指由一对大括号括起来的若干条简单的 Java 语句。块确定了变量的作 用域。一个块可以嵌套在另一个块中。

2. 在 Java 中，条件语句的格式为if (condition) statement。这里的条件必须用括号括起来。

3. 当条件为 true 时，while 循环执行一条语句（也可以是一个语句块）。一般格式为
   while { condition ) statement
   如果开始循环条件的值就为 false, 则 while 循环体一次也不执行 。

4. 如果希望 循环体至少执行一次， 则应该将检测条件放在最后。 使用 do/while 循环语句可以实现这种操 作方式。它的语法格式为： do statement while { condition);

5. for 循环语句是支持迭代的一种通用结构， 利用每次迭代之后更新的计数器或类似的变量 来控制迭代次数。
   for (int i = 1; i <= 10; i++) 
   System.out.println(i);
   特别指出，如果在 for 语句内部定义一个变量， 这个变量就不能在循环体之外使用。

6. 在处理多个选项时， 使用 if/else 结构显得有些笨拙。 Java 有一个与 C/C++ 完全一样的 switch 语句。switch语句将从与选项值相匹配的 case 标签处开始执行直到遇到 break 语句，或者执行到 switch i吾句的结束处为止。如果没有相匹配的 case 标签， 而有 default 子句， 就执行这个子句。
   有可能触发多个 case 分支。 如果在 case 分支语句的末尾没有 break 语句， 那么就 会接着执行下一个 case 分支语句。这种情况相当危险， 常常会引发错误。 

7. Java 还提供了一种带标签的 break语句，用于跳出多重嵌套的循环语句。可以将标签应用到任何语句中， 甚至可以应用到 if语句或者块语句中
   最后，还有一个 continue 语句。与 break 语句一样， 它将中断正常的控制流程。continue 语句将控制转移到最内层循环的首部。

**大 数 值：**

如果基本的整数和浮点数精度不能够满足需求， 那么可以使用java.math 包中的两个 很有用的类：Biglnteger 和 BigDecimal，这两个类可以处理包含任意长度数字序列的数值。 Biglnteger 类实现了任意精度的整数运算， BigDecimal 实现了任意精度的浮点数运算。

使用静态的 valueOf方法可以将普通的数值转换为大数值： Biglnteger a = Biglnteger.valueOf(100);

遗憾的是，不能使用人们熟悉的算术运算符（如：+ 和 *) 处理大数值。 而需要使用大数 值类中的 add 和 multiply 方法

**数 组：**

数组是一种数据结构， 用来存储同一类型值的集合。通过一个整型下标可以访问数组中 的每一个值。例如， 如果 a 是一个整型数组， a[i] 就是数组中下标为 i 的整数。

1. 在声明数组变量时， 需要指出数组类型 （ 数据元素类型紧跟 []) 和数组变量的名字。下 面声明了整型数组 a: 	
   int[] a;
   不过， 这条语句只声明了变量 a， 并没有将 a 初始化为一个真正的数组。应该使用 new 运算 符创建数组	
   int[] a = new int[100];

2. 创建一个数字数组时， 所有元素都初始化为 0。boolean 数组的元素会初始化为 false。 对 象数组的元素则初始化为一个特殊值 null, 这表示这些元素（还）未存放任何对象。

3. 要想获得数组中的元素个数，可以使用 array.length。一旦创建了数组， 就不能再改变它的大小（尽管可以改变每一个数组元素）。如果经常需 要在运行过程中扩展数组的大小， 就应该使用另一种数据结构—数组列表

4. Java 有一种功能很强的循环结构， 可以用来依次处理数组中的每个元素（其他类型的元 素集合亦可）而不必为指定下标值而分心。这种增强的 for 循环的语句格式为：
   for (variable : collection) statement
   定义一个变量用于暂存集合中的每一个元素， 并执行相应的语句（当然，也可以是语句块)。 collection 这一集合表达式必须是一个数组或者是一个实现了 Iterable 接口的类对象（例如 ArrayList)。
   for each 循环语句显得更加简洁、 更不易出错,不必为下标的起始值和终止值而操心。

5. 有个更加简单的方式打印数组中的所有值， 即利用 Arrays 类的 toString 方法。 调 用 Arrays.toString(a), 返回一个包含数组元素的字符串，这些元素被放置在括号内， 并 用逗号分隔， 例如，“ [2,3,5,7，11，13] ”

6. 在 Java中， 提供了一种创建数组对象并同时赋予初始值的简化书写形式
   int[] small Primes = { 2, 3, 5, 7, 11, 13 };
   这种表示法将创建一个新数组并利用括号中提供的值进行初始化，数组的大小就是初始值的 个数

7. 在 Java 中，允许将一个数组变量拷贝给 另一个数组变量。这时， 两个变量将引用同 一个数组。如果希望将 一个数组的所有值拷贝到一个新的数组中去， 就要使用 Arrays 类的 copyOf方法

8. 每一个 Java 应用程序都有一个带 String arg[]，参数的 main 方法。这个参数表明 main 方法将接收一个字符串数组， 也就是命令行参数
   public static void main(String[] args)
   如果使用下面这种形式运行这个程序： java Message -g cruel world

9. 要想对数值型数组进行排序， 可以使用 Arrays 类中的 sort 方法
   int[] a = new int[10000]; 
   Arrays.sort(a)这个方法使用了优化的快速排序算法。快速排序算法对于大多数数据集合来说都是效率比较 高的

10. 多维数组将使用多个下标访问数组元素， 它适用于表示表格或更加复杂的排列形式。Java 实际上没有多维数组，只有一维 数组。多维数组被解释为“ 数组的数组。”

### 04：对 象 与 类

面向 对象程序设计与面向过程程序设计在思维方式上存在着很大的差别,面向对象程序设计（简称 OOP) 是当今主流的程序设计范型，Java 是完全面向对象的.

**面向对象程序设计概述:**

面向对象的程序是由对象组成的， 每个对象包含对用户公开的特定功能部分和隐藏的实现部分。面向对象更加适用于解决规模较大的问题.

1. 类（ class) 是构造对象的模板或蓝图。由类构造（construct) 对象的过程称为创建类的实例 （instance )

2. 封装 是与对象有关的一个重要概念。从形式上看， 封装是将数据和行为组合在一个包中， 并对对象的使用者隐藏了数据的实现方式,封装给对象赋予了“ 黑盒” 特征， 这是提高重用性和可靠性 的关键。
   对象 中的数据称为成员变量（ instance field ), 操纵数据的过程称为方法（ method 。) 对于每个特定的 类实例（对象）都有一组特定的成员变量值。这些值的集合就是这个对象的当前状态（ state )。
3. 通过扩展一个类来建立另外一个 类的过程称为继承（inheritance)，在扩展一个已有的类时， 这个扩展后的新类具有所扩展的类的全部属性和方法。在新类 中，只需提供适用于这个新类的新方法和数据域就可以了。
4. 对象的三个主要特性：
   1. 对象的行为（behavior) —可以对对象施加哪些操作，或可以对对象施加哪些方法？
   2. 对象的状态（state ) —当施加那些方法时，对象如何响应？
   3. 对象标识（identity ) —如何辨别具有相同行为与状态的不同对象？
5. 识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。
6. 在类之间， 最常见的关系有：依赖、聚合、继承。
   依赖（ dependence ), 即“ uses-a” 关系， 是一种最明显的、 最常见的关系。例如，Order 类使用 Account 类是因为 Order 对象需要访问 Account 对象查看信用状态。应该尽可能地将相互依赖的类减至最少，用软件工程的术语来说，就是 让类之间的耦合度最小。
   聚合（aggregation ), 即“ has-a ” 关系， 是一种具体且易于理解的关系。例如， 一个 Order 对象包含一些 Item 对象。聚合关系意味着类 A 的对象包含类 B 的对象。
   继承（ inheritance ), 即“ is-a” 关系， 是一种用于表示特殊与一般关系的。例如，Rush Order类由 Order 类继承而来，Rush Order类具有Order类的一些属性和方法。

**类：**

1. 在 Java 中， 没有类就无法做任何事情，然而，并不是所有 的类都具有面向对象特征。例如：Math 类只封装了功能，它不需要也不 必隐藏数据。由于没有数据，因此也不必担心生成对象以及初始化成员变量。

2. 要想使用对象，就必须首先构造对象， 并指定其初始状态，构造器是一种特殊的方法， 用来构造并初始化对象。构造器的名字应该与类名相同，要想构造一个 Date 对 象， 需要在构造器前面加上 new 操作符。
   new Date()
   构造器与类同名 、每个类可以有一个以上的构造器 、构造器可以有 0 个、1 个或多个参数 、构造器没有返回值 、构造器总是伴随着 new 操作一起调用

3. 对象与对象变量之间存在着一个重要的区别，定义了一个对象变量 deadline, 它 可 以 引 用 Date 类型的对象。但是，一定要认识到： 变量 deadline 不是一个对象， 实际上也没有引用对象。此时，不能将任何 Date 方法应用于这个变 量上。
   Date deadline;
   s = deadline.toString（）; // not yet
   必须首先初始化变量 deadline，deadline = new Date();一定要认识到，一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。
4. raiseSalary 方法有两个参数。 第一个参数称为隐式 参数， 是出现在方法名前的 Employee 类对象。第二个参数位于方法名后面括号中的数值，这是一个显式 参 数 
   number007. raiseSalary(5);
5. 私有方法，在实现一个类时，由于公有数据非常危险， 所以应该将所有的数据域都设置为私有的。然 而，方法又应该如何设计呢？尽管绝大多数方法都被设计为公有的，但在某些特殊情况下，也 可能将它们设计为私有的。然而，只要方法是 私有的，类的设计者就可以确信：它不会被外部的其他类操作调用，可以将其删去。如果方 法是公有的， 就不能将其删去，因为其他的代码很可能依赖它
6. final 成员变量，可以将成员变量定义为 final。 构建对象时必须初始化这样的域。也就是说， 必须确保在每 一个构造器执行之后，这个域的值被设置， 并且在后面的操作中， 不能够再对它进行修改。

7. 静态变量，如果将域定义为 static, 每个类中只有一个这样的域。而每一个对象对于所有的实例域 却都有自己的一份拷贝。
   静态变量使用得比较少，但静态常量却使用得比较多。在 Math 类中定义了一个 静态常量：Math.Pi。
   静态方法是一种不能向对象施加操作的方法，例如， Math 类的 pow 方法就是一个静态 方法。静态方法不能访问实例域， 因为它不能操作实例对象。但是，静态方法可 以操作自身类中的静态域。当然，也可以使用对象调用静态方法，不过，这种方式很容易造成混淆，其原因 是静态 方法计算的结果与 实例对象 毫无关系。

8. main 方法不对任何对象进行操作。事实上，在启动程序时还没有任何一个对象。静态的 main 方法将执行并创建程序所需要的对象。

**方法参数：**

按 值调用 （call by value) 表示方法接收的是调用者提供的值。而按引用调用 （ call by reference) 表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而 不能修改传递值调用所对应的变量值

方法参数共有两种类型：基本数据类型（数字、布尔值）、对象引用。一个方法不可能修改一个基本数据类型的参数，而对象引用作为参数就不同了，对象引用及其他的拷贝是同时引用同一个对象。

**对 象 构 造：**

1. 重载，有些类有多个构造器，这种特征叫做重载（ overloading）。 如果多个方法（比如， StringBuilder 构造器方法）有 相同的名字、 不同的参数，便产生了重载。Java 允许重载任何方法， 而不只是构造器方法。
   重载解析：这个过程是如 果编译器找不到匹配的参数， 就会产生编译时错误，因为根本不存在匹配， 或者没有一个比 其他的更好。

2. 默认初始化，如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值： 数值为 0、 布尔值为 false、 对象引用为 null。同数组。

3. 无参数的构造器，很多类都包含一个无参数的构造函数，对象由无参数构造函数创建时， 其状态会设置为 适当的默认值。如果在编写一个类时没有编写构造器， 那么系统就会提供一个默认的无参数构造器。这个构造 器将所有的实例域设置为默认值。如果类中提供了至少一个构造器， 那么就会重载默认的无参构造器。
   仅当类没有提供任何构造器的时候， 系统才会提供一个默认的构造器

4. 显式初始化，可以在类定义中， 直接将一个值赋给任何属性，在执行构造器之前，先执行赋值操作。

5. 如果构造器的第一个语句形如 this(...)， 这个构造器将调用同一个类的另一个构造器。
   public Employee(double s) {

   ​	this("Employee #" + nextld, s);
   ​	nextld++;

   }

6. 初始化块，在一个类的声明中， 可以包含多个代码块，只要构造类的对象，这些块就会被执行。
   无论使用哪个构造器构造对象，首 先运行初始化块，然后才运行构造器的主体部分。这种机制不是必需的，也不常见。通常会直接将初始化代码放在构造器中

7. 静态的初始化块，将代码放在一个块中，并标记关键字 static。在类第一次加载的时候， 将会进行静态域的初始化。

8. 调 用构造器的具体处理步骤：

   1. 所有属性被默认初始化为默认值（0、false 或 null）。
   2. 按照在类声明中出现的次序， 依次执行初始化块。
   3. 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体
   4. 执行这个构造器的主体

**包：**

Java 允许使用包（ package ） 将类组织起来。借助于包可以方便地组织自己的代码，并将 自己的代码与别人提供的代码库分开管理。使用包的主要原因是确保类名的唯一性。

1. 一个类可以使用所属包中的所有类， 以及其他包中的公有类（ public class）。
2. 要想将一个类放人包中， 就必须将包的名字放在源文件的开头，包中定义类的代码之 前。
   package com.horstiann.corejava; 
   public class Employee { 
   }
3. 标记为 public 的部分可以被任意的类使 用；标记为 private 的部分只能被定义它们的类使用。如果没有指定 public 或 private , 这 个 部 分（类、方法或变量）可以被同一个包中的所有方法访问。

**文档注释：**

JDK 包含一个很有用的工具，叫做javadoc, 它可以由源文件生成一个 HTML 文档。

**类设计技巧：**

1. 一定要保证数据私有。这是最重要的，绝对不要破坏封装性。
2. 一定要对数据初始化。Java 不对局部变量进行初始化， 但是会对对象的实例域进行初始化。最好不要依赖于系 统的默认值， 而是应该显式地初始化所有的数据
3. 不要在类中使用过多的基本类型。就是说，用其他的类代替多个相关的基本类型的使用。这样会使类更加易于理解且易于 修改。
4. 不是所有的域都需要独立的域访问器和域更改器
5. 将职责过多的类进行分解。如果明 显地可以将一个复杂的类分解成两个更为简单的类，就应该将其分解
6. 类名和方法名要能够体现它们的职责。
7. 优先使用不可变的类。更改对象的问题在于， 如果多个线程试图同时更新一个对象，就会发生并发更改。

### 05：继 承

本章将学习面向对象程序设计的另外一个基本概念: 继承（inheritance)。利用继承，人们可以基于已存在的类构造一个新类。继承已存在的类就 是复用（继承）这些类的方法和域。

1. 关键字 extends 表示继承（public class Manager extends Employee）。关键字 extends 表明正在构造的新类派生于一个已存在的类。 已存在的类称为超类 ( superclass)、 基类（ base class) 或父类（parent class); 新类称为子类（subclass、) 派生类 ( derived class) 或孩子类（child class)
2. 在通过扩展超类定义子类的时候，仅需要指出子类与超类的不同之处。因此在设计类的时候，应该将通用的方法放在超类中， 而将具有特殊用途的方法放在子类中
3. 有些人认为 super 与 this 引用是类似的概念， 实际上，这样比较并不太恰当。这是 因为 super 不是一个对象的引用， 不能将 super 赋给另一个对象变量， 它只是一个指示编 译器调用超类方法的特殊关键字。
   关键字 this 有两个用途： 一是引用隐式参数，二是调用该类其他的构 造器 ， 同样，super 关键字也有两个用途：一是调用超类的方法，二是调用超类的构造器。
4. 由于 子类的构造器不能访问超 类的私有域， 所以必须利用 超 类 的构造器对这部分私有域进行初始化，我们可以通过 super 实现对超类构造器的调用。使用 super 调用构造器的语句必须是子类构造器的第一条语句。 
   如果子类的构造器没有显式地调用超类的构造器， 则将自动地调用超类默认（没有参数 ) 的构造器。 如果超类没有不带参数的构造器， 并且在子类的构造器中又没有显式地调用超类 的其他构造器，则 Java 编译器将报告错误。
5. 一个对象变量（例如， 变量 e ) 可以指示多种实际类型的现象被称为多态（ polymorphism)。 在运行时能够自动地选择调用哪个方法的现象称为动态绑定（ dynamic binding。)
6. 有时候，可能希望阻止人们利用某个类定义子类。不允许扩展的类被称为 final 类。如果 在定义类的时候使用了 final 修饰符就表明这个类是 final 类。
   类中的特定方法也可以被声明为 final。如果这样做，子类就不能覆盖这个方法（ final 类中的所有方法自动地成为 final 方法 ) ，将方法声明为 final 主要目的是： 确保它们不会在子类中改变语义。
7. 对象引用的转换语法与数值表达式的类型转换类似， 仅 需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了，Manager boss = (Manager) staff[0]；
   将一个子类的引用赋给一个超类 变量， 编译器是允许的。但将一个超类的引用赋给一个子类变量， 必须进行强制类型转换， 这样 才能够通过编译时的检査。
   总之，1、只能在继承层次内进行类型转换。2、在将超类转换成子类之前，应该使用 instanceof进行检查。（instanceof会检查变量的运行类型）
8. 如果自下而上在类的继承层次结构中上移，位于上层的类更具有通用性，甚至可能更加 抽象，祖先类更加通用， 人们只将它作为派生其他类的基类，而不作为想使 用的特定的实例类。
9. 包含一个或多个抽象方法的类本身必须被声明为抽象的，除了抽象方法之外，抽象类还可以包含具体数据和具体方法。抽象方法充当着占位的角色， 它们的具体实现在子类中。类即使不含抽象方法，也可以将类声明为抽象类，而抽象类不能被实例化。
   需要注意， 可以定义一个抽象类的对象变量， 但是它只能引用非抽象子类的对象，这是运用到了多态的知识。
10. Java 用于控制可见性的 4 个访问修饰符：1 ) 仅对本类可见 private。2 ) 对所有类可见 public。3 ) 对本包和所有子类可见 protected。4 ) 对本包可见—默认（很遗憾，) 不需要修饰符。
11. Object 类是 Java 中所有类的始祖， 在 Java 中每个类都是由它扩展而来的，如果没有明确地指出超类，Object 就被认为是这个类的超类。
    在 Java 中，只有基本类型 （ primitive types) 不是对象， 例如，数值、 字符和布尔类型的 值都不是对象。 所有的数组类型，不管是对象数组还是基本类型的数组都扩展了 Object 类。
12. Object 类中的 equals 方法用于检测一个对象是否等于另外一个对象，在 Object 类中，这 个方法将判断两个对象是否具有相同的引用，如果两个对象具有相同的引用， 它们一定是相 等的。然而，对于多数类来说， 这种判断 并没有什么意义。所以我们经常在子类中，重写基类的equals。
13. 在 Object 中还有一个重要的方法， 就是 toString方法， 它用于返回表示对象值的字符 串。当然，设计子类的程序员也应该定义自己的 toString 方法，并将子类域的描述添加进去。  强烈建议为自定义的每一个类增加 toString 方法。这样做不仅自己受益， 而且所 有使用这个类的程序员也会从这个日志记录支持中受益匪浅
14. ArrayList 是一个采用类型参数（ type parameter ) 的泛型类（ generic class)。为了指定数 组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面， 例如，ArrayList类型，ArrayList<Employee> staff = new ArrayList()；这被称为“ 菱形” 语法，因为空尖括号<>就像是一个菱形.
    数组列表自动扩展容量的便利增加了访问元素语法的复 杂程度。 其原因是 ArrayList 类并不是 Java 程序设计语言的一部分，它只是一个由某些人编 写且被放在标准库中的一个实用类。
15. 有时， 需要将 int 这样的基本类型转换为对象, 所有的基本类型都冇一个与之对应的类。例如，Integer 类对应基本类型 int。通常， 这些类称为包装类 （ wrapper ) 。
    Integer、Long、Float、Double、Short、Byte、Character 、 Boolean (前 6 个类派生于公共的超类 Number)。

**继承的设计技巧：**

1. 将公共操作和域放在超类
2. 不要使用受保护的域
3. 使用继承实现“ is-a” 关系
4. 除非所有继承的方法都有意义，否则不要使用继承
5. 在覆盖方法时，不要改变预期的行为
6. 使用多态， 而非类型信息

### 06：接 口 lambda 内部类

**接口：**

接口（ interface) 技术， 这种技术主要用来描述类具有什么功能，而并不 给出每个功能的具体实现。一个类可以实现（ implement) —个或多个接口，并在需要接口的 地方， 随时使用实现了相应接口的对象。

1. 接口不是类，而是对类的一组需求描述，这些类要遵从接口描 述的统一格式进行定义。
2. 接口中的所有方法自动地属于 public。 因此，在接口中声明方法时，不必提供关键字 public 。
3. 要将类声明为实现某个接口， 需要使用关键字 implements: class Employee implements Comparable
4. 接口不是类，尤其不能使用 new 运算符实例化一个接口，然而， 尽管不能构造接口的对象，却能声明接口的变量，接口变量必须引用实现了接口的类对象
5. 使用抽象类表示通用属性存在这样一个问题： 每个类只能扩展于一个类。假 设 Employee 类已经扩展于一个类， 例如 Person, 它就不能再像下面这样扩展第二个类了。接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。
6. 回调（ callback) 是一种常见的程序设计模式。在这种模式中，可以指出某个特定事件发 生时应该采取的动作。

**lambda 表达式：**

lambda表达式，这是 一种表示可以在将来某个时间点执行的代码块的简洁方法。使用 lambda 表达式，可以用一 种精巧而简洁的方式表示使用回调或变量行为的代码。

1. lambda 表达式是一个可传递的代码块， 可以在以后执行一次或多次。

2. lambda 表达式就是一个代码块， 以及必须传入 代码的变量规范。

   一种 lambda 表达式形式：参数， 箭头（->) 以及一个表达式。如 果代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在 {}中， 并包含显式的 return语句。
   (String first, String second) -> first.length() - second.length()

3. 对于只有一个抽象方法的接口， 需要这种接口的对象时， 就可以提供一个 lambda 表达 式。这种接口称为函数式接口

   下面考虑 Arrays.sort 方法。它的第二个参数需要一个 Comparator 实例， Comparator 就是只有一个方法的接口， 所以可以提供一个 lambda 表达式
   Arrays.sort (words, (first, second) -> first.length() - second.length()) ;

**内部类:**

内部类（ inner class) 机制。理论上讲，内部类有些复杂， 内部类定义在另 外一个类的内部， 其中的方法可以访问包含它们的外部类的域。内部类技术主要用于设计具 有相互协作关系的类集合

1. 内部类方法可以访问该类定义所在的作用域中的数据， 包括私有的数据
2. 内部类可以对同一个包中的其他类隐藏起来
3. 当想要定义一个回调函数且不想编写大量代码时，使用匿名 （anonymous) 内部类比较 便捷
4. 假如只创建这个类的一个对象，就不必命名了。这种类被称为匿名内部类
5. 在内部类不需要访问外围类对象的时候， 应该使用静态内部类。 有些程序员用嵌 套类 （nested class) 表示静态内部类。与常规内部类不同，静态内部类可以有静态域和方法。声明在接口中的内部类自动成为 static 和 public 类。

### 07：异常、断言和曰志

对于异常情况， 例如， 可能造成程序崩溃的错误输入，Java 使 用 一 种 称 为 异 常 处 理的错误捕获机制处理。假设在一个 Java 程序运行期间出现了一个错误。这个错误可能是由于文件包含了错误 信息，或者网络连接出现问题造成的，也有可能是因为使用无效的数组下标， 或者试图使用 一个没有被赋值的对象引用而造成的。用户期望在出现错误时， 程序能够采用一些理智的行 为。

1. 异常处理的任务就是将控制权从错误产生的地方转移给能够处理这种情况的错误处理 器。程序中可能会出现的错误和问题：
   1. 用户输入错误
   2. 设备错误
   3. 物理限制，磁盘满了，可用存储空间已被用完
   4. 代码错误，程序方法有可能无法正确执行。

2. Error 类层次结构描述了 Java 运行时系统的内部错误和资源耗尽错误。 应用程序不应该 抛出这种类型的对象。 如果出现了这样的内部错误， 除了通告给用户，并尽力使程序安全地 终止之外， 再也无能为力了。这种情况很少出现。
3. 在设计 Java 程序时， 需要关注 Exception 层次结构。 这个层次结构又分解为两个分支： 一个分支派生于 RuntimeException ; 另一个分支包含其他异常。
4. 由 程序错误导致的异常属于 RuntimeException ; 而程序本身没有问题， 但由于像 I/O 错误这类 问题导致的异常属于其他异常（编译异常）。
5. 在程序中，可能会遇到任何标准异常类都没有能够充分地描述清楚的问题。 在这种情 况下，创建自己的异常类就是一件顺理成章的事情了。我们需要做的只是定义一个派生于 Exception 的类，或者派生于 Exception 子类的类。
6. 只要将其抛出就不用理 踩了。当然， 有些代码必须捕获异常。如果某个异常发生的时候没有在任何地方进行捕获，那程序就会终止执行，并在控制台 上打印出异常信息， 其中包括异常的类型和堆栈的内容。要想捕获一个异常， 必须设置 try/catch语句块。
7. 在一个 try 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理。
8. 当代码抛出一个异常时， 就会终止方法中剩余代码的处理，并退出这个方法的执行。
9. 异常处理不能代替简单的测试、不要过分地细化异常、 利用异常层次结构、不要压制异常、在检测错误时，“ 苛刻 ” 要比放任更好、不要羞于传递异常
10. 在一个具有自我保护能力的程序中， 断言很常用。当希望进行检查， 以避免让“ 不是一个数” 的数值参与计算操作。主动可以抛 出一个异常。断言机制允许在测试期间向代码中插入一些检査语句，如果结果为 false, 则抛出一个 AssertionError 异常。

## Java基础技术

### 多态机制

#### 多态是什么

多态（Polymorphism）按字面的意思就是“多种状态”。在面向对象语言中，接口的多种不同的实现方式即为多态。

#### 多态的语法格式

父类类名 引用名称 = new 子类类名();

当是多态时，该引用名称只能访问父类中的属性和方法，但是访问的时候，会优先访问子类重写以后的方法

#### 满足多态的条件

子类必须继承父类

子类必须重写父类的方法

父类引用指向子类对象，即：父类类名 引用名称 = new 子类类名();

#### 使用多态好处

使用多态可以使代码之间的耦合度降低

减少冗余代码的同时，也使得项目的扩展能力更强

注：耦合度指的是代码（程序）之间的关联程度

#### 多态中的类型转换

Java多态中，有两种类型转换：向上转型和向下转型

##### 向上转型

向上转型，是自动类型转换，子类型赋值给父类型（父类型的引用指向子类型），构成多态

父类类型 引用名称 = new 子类类名();

当使用多态方式调用方法时，该引用名称只能访问父类中的属性和方法。编译器首先检查父类中是否有该方法，如果没有，则编译错误。如果有，再去调用子类的同名（重写）方法。

##### 向下转型

向下转型，是强制类型转换，父类型赋值给子类型

当使用多态时，并且访问子类独有的属性或方法时，则必须进行向下转型

当进行向下转型时，建议先使用 instance of 关键字进行判断，判断合法时，则在转为对应的类型，否则可能会出现类型转换异常 java.lang.ClassCastException。

#### 多态的实现方式

1. 普通子类重写父类方法
2. 接口
3. 抽象类和抽象方法

#### 多态简单使用案例

场景：假如有个饲养员，需要给不同的宠物喂食，下面给出使用多态和不使用多态的实现方式

##### 不使用多态的实现

首先定义一个抽象类Animal、一个饲养员类AnimalKeeper、一个宠物类Dog和一个宠物类Cat。

```java
public abstract class Animal {

    public void eat() {
        System.out.println("动物吃东西！");
    }
}

public class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("狗啃骨头！");
    }
}

public class Cat extends Animal {
    @Override
    public void eat() {
        System.out.println("猫吃鱼！");
    }
}
```

```java
/**
 * 饲养员
 */
public class AnimalKeeper {

    /**
     * 给宠物猫喂食
     *
     * @param cat
     */
    public void feed(Cat cat) {
        cat.eat();
    }

    /**
     * 给宠物狗喂食
     *
     * @param dog
     */
    public void feed(Dog dog) {
        dog.eat();
    }

}
```

```java
public class PolymorphicTest {

    public static void main(String[] args) {
        //创建饲养员对象
        AnimalKeeper animalKeeper = new AnimalKeeper();

        //创建宠物对象
        Cat cat = new Cat();
        animalKeeper.feed(cat);//猫吃鱼！

        Dog dog = new Dog();
        animalKeeper.feed(dog);//狗啃骨头！
    }
}
```

以上实现看起来没有什么问题，也容易理解，在目前情况下，饲养员可以满足喂养宠物的需求。但是，过了一周，饲养员又喂养了一只鸟，这时候不得不修改AnimalKeeper类，使其可以饲养宠物鸟，不仅违反了Java中的开闭原则，而且以上代码的实现，扩展性极差。

##### 使用多态的实现

只需要对以上代码中，饲养员类AnimalKeeper进行替换，新增一个饲养员类AnimalKeeperPolymorphic类。

```java
/**
 * 饲养员
 */
public class AnimalKeeperPolymorphic {

    /**
     * 饲养员给宠物喂食
     *
     * @param animal
     */
    public void feed(Animal animal) {
        animal.eat();
    }

}
```

这种实现有什么好处呢，当新需求来了，需要扩展时，不需要修改饲养员的代码。比如说刚才那个需求，新增加一个宠物鸟，只需要新建一个宠物鸟类，实现Animal接口，不仅遵循了OCP原则，也可以实现饲养宠物鸟的功能。

#### 多态分析

以上文中示例代码进行分析，看看多态是如何使用的。AnimalKeeperPolymorphic中的feed()方法，使用了多态。

当饲养员喂养宠物狗时，其实执行的是：

```abnf
Animal animal = new Dog();
```

当饲养员喂养宠物猫时，其实执行的是：

```abnf
Animal animal = new Cat();
```

这种属于向上转型，里面有继承（cat继承Animal）关系，重写了父类eat()方法，子类型赋值给父类型（父类型的引用指向子类型），构成了多态。

Animal animal = new Cat(); 程序**在编译阶段，animal引用类型被编译器看做Animal类型**，所以程序**在编译阶段，animal引用绑定的是Aninmal类中的eat()方法，这个过程叫做Java多态的静态绑定**。

程序**在运行的时候，堆中的对象实际上是Cat类型**，而Cat对象已经覆盖（重写）了父类Animal的eat()方法，所以**程序在运行阶段，对象绑定的方法是Cat中的eat()方法，这个过程叫做Java多态的动态绑定**。

### 注解机制详解

#### 注解基础

注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它主要的作用有以下四方面：

- 生成文档，通过代码里标识的元数据生成javadoc文档。
- 编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。
- 编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。
- 运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。

**Java自带的标准注解**，包括`@Override`、`@Deprecated`和`@SuppressWarnings`，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。

**元注解**，元注解是用于定义注解的注解，包括`@Retention`、`@Target`、`@Inherited`、`@Documented`，`@Retention`用于标明注解被保留的阶段，`@Target`用于标明注解使用的范围，`@Inherited`用于标明注解可继承，`@Documented`用于标明是否生成javadoc文档。

**自定义注解**，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。

接下来我们通过这个分类角度来理解注解。

#### Java内置注解

`@Override`：表示当前的方法定义将覆盖父类中的方法

`@Deprecated`：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告

`@SuppressWarnings`：表示关闭编译器警告信息

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
//从它的定义我们可以看到，这个注解可以被用来修饰方法，并且它只在编译时有效，在编译后的class文件中便不再存在。这个注解的作用我们大家都不陌生，那就是告诉编译器被修饰的方法是重写的父类的中的相同签名的方法，编译器会对此做出检查，若发现父类中不存在这个方法或是存在的方法签名不同，则会报错。

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})
public @interface Deprecated {
}
//从它的定义我们可以知道，它会被文档化，能够保留到运行时，能够修饰构造方法、属性、局部变量、方法、包、参数、类型。这个注解的作用是告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。

@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
    String[] value();
}
//它能够修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量，只能存活在源码时，取值为String[]。它的作用是告诉编译器忽略指定的警告信息
```

#### 元注解

上述内置注解的定义中使用了一些元注解（注解类型进行注解的注解类），在JDK 1.5中提供了4个标准的元注解：`@Target`，`@Retention`，`@Documented`，`@Inherited`, 在JDK 1.8中提供了两个元注解 `@Repeatable`和`@Native`。

##### @Target

Target注解的作用是：描述注解的使用范围（即：被修饰的注解可以用在什么地方） 。

Target注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数），在定义注解类时使用了@Target 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在ElementType 枚举中。

```java
public enum ElementType {
    TYPE, // 类、接口、枚举类
    FIELD, // 成员变量（包括：枚举常量）
    METHOD, // 成员方法
    PARAMETER, // 方法参数
    CONSTRUCTOR, // 构造方法
    LOCAL_VARIABLE, // 局部变量
    ANNOTATION_TYPE, // 注解类
    PACKAGE, // 可用于修饰：包
    TYPE_PARAMETER, // 类型参数，JDK 1.8 新增
    TYPE_USE // 使用类型的任何地方，JDK 1.8 新增
}
```

##### @Retention

Reteniton注解的作用是：描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时） 。

Reteniton注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在RetentionPolicy枚举中。

```java
public enum RetentionPolicy {
 
    SOURCE,    // 源文件保留
    CLASS,       // 编译期保留，默认值
    RUNTIME   // 运行期保留，可通过反射去获取注解信息
}
```

##### @Documented

Documented注解的作用是：描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。

##### @Inherited

Inherited注解的作用：被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。

```java
@TestInheritedAnnotation(values = {"value"}, number = 10)
public class Person {
}

class Student extends Person{
	@Test
    public void test(){
        Class clazz = Student.class;
        Annotation[] annotations = clazz.getAnnotations();
        for (Annotation annotation : annotations) {
            System.out.println(annotation.toString());
        }
    }
}

//输出：xxxxxxx.TestInheritedAnnotation(values=[value], number=10)
```

即使Student类没有显示地被注解`@TestInheritedAnnotation`，但是它的父类Person被注解，而且`@TestInheritedAnnotation`被`@Inherited`注解，因此Student类自动有了该注解。

#### 注解与反射接口

定义注解后，如何获取注解中的内容呢？反射包java.lang.reflect下的AnnotatedElement接口提供这些方法。这里注意：**只有注解被定义为RUNTIME后，该注解才能是运行时可见**，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。

AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息。

1. 判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。注意：此方法会忽略注解对应的注解容器。

   ```java
   boolean isAnnotationPresent(Class<?extends Annotation> annotationClass)
   ```

2. 返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。

   ```java
   <T extends Annotation> T getAnnotation(Class<T> annotationClass)
   ```

3. 返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。

   ```java
   Annotation[] getAnnotations()
   ```

#### 自定义注解

当我们理解了内置注解, 元注解和获取注解的反射接口后，我们便可以开始自定义注解了。这个例子我把上述的知识点全部融入进来, 代码很简单：

**定义自己的注解**

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyMethodAnnotation {

    public String title() default "";

    public String description() default "";

}
```

**使用注解**

```java
public class TestMethodAnnotation {

    @Override
    @MyMethodAnnotation(title = "toStringMethod", description = "override toString method")
    public String toString() {
        return "Override toString method";
    }

    @Deprecated
    @MyMethodAnnotation(title = "old static method", description = "deprecated old static method")
    public static void oldMethod() {
        System.out.println("old method, don't use it.");
    }

    @SuppressWarnings({"unchecked", "deprecation"})
    @MyMethodAnnotation(title = "test method", description = "suppress warning static method")
    public static void genericsTest() throws FileNotFoundException {
        List l = new ArrayList();
        l.add("abc");
        oldMethod();
    }
}
```

**用反射接口获取注解信息**

```java
// 获取所有methods(不理解)
Method[] methods = TestMethodAnnotation.class.getClassLoader()
        .loadClass(("com.pdai.java.annotation.TestMethodAnnotation"))
        .getMethods();

// 遍历
for (Method method : methods) {
    // 方法上是否有MyMethodAnnotation注解
    if (method.isAnnotationPresent(MyMethodAnnotation.class)) {
            // 获取并遍历方法上的所有注解
            for (Annotation anno : method.getDeclaredAnnotations()) {
                System.out.println("Annotation in Method '"
                        + method + "' : " + anno);
            }

            // 获取MyMethodAnnotation对象信息
            MyMethodAnnotation methodAnno = method
                    .getAnnotation(MyMethodAnnotation.class);

            System.out.println(methodAnno.title());
    }
}
```

#### 注解支持继承吗？

注解是不支持继承的。

不能使用关键字extends来继承某个@interface，但注解在编译后，编译器会自动继承java.lang.annotation.Annotation接口.

虽然反编译后发现注解继承了Annotation接口，请记住，即使Java的接口可以实现多继承，但定义注解时依然无法使用extends关键字继承@interface。

区别于注解的继承，被注解的子类继承父类注解可以用@Inherited： 如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。

### 重写与重载详解

#### 重写 (Override)

##### 重写基本介绍

重写是子类对父类的允许访问的方法的实现过程进行重新编写！返回值和形参都不能改变。即外壳不变，核心重写！

重写的好处在于子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法。实例如下：

```java
class Animal{
   public void move(){
      System.out.println("动物可以移动");
   }
}

class Dog extends Animal{
   public void move(){
      System.out.println("狗可以跑和走");
   }
}

Animal a = new Animal(); // Animal 对象
Animal b = new Dog(); // Dog 对象
a.move();// 执行 Animal 类的方法
b.move();//执行 Dog 类的方法

动物可以移动
狗可以跑和走
```

在上面的例子中可以看到，尽管 b 属于 Animal 类型，但是它运行的是 Dog 类的 move 方法。

**这是由于在编译阶段，只是检查参数的编译类型。然而在运行时，Java 虚拟机 (JVM) 指定对象的运行类型并且运行该对象的方法。**

**因此在上面的例子中，之所以能编译成功，是因为 Animal 类中存在 move 方法，然而运行时，是因为JVM指定了该对象的运行类型Dog，运行的是Dog类重写的move方法。**

思考以下例子：

```java
class Dog extends Animal{

   public void move(){
      System.out.println("狗可以跑和走");
   }
    //新增了一个子类特有的bark方法
   public void bark(){ 
      System.out.println("狗可以吠叫");
   }
}

Animal a = new Animal(); // Animal 对象
Animal b = new Dog(); // Dog 对象
a.move();// 执行 Animal 类的方法
b.move();//执行 Dog 类的方法
a.bark();//执行 Animal 类的方法  ？？这一行报错

该程序将抛出一个编译错误，因为 a 的编译类型 Animal 没有 bark 方法。这里要进行一个向下转型的操作即可
```

##### 方法重写的规则

* 参数列表与被重写方法的参数列表必须完全相同。

* 返回类型与被重写方法的返回类型最好是相同，如果不同，则必须是**该返回值的子类**

  ```java
  class a {}
  
  class b extends a {}
  
  class c {
      public a test() {
          return null;
      }
  }
  class d extends c {
      @Override
      public b test() {
          return null;
      }
  }
  ```

* 子类方法的访问权限必须大于或等于父类方法的访问权限。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。

* 声明为 final 的方法不能被重写。

* 声明为 static 的方法不能被重写。

* 构造方法不能被重写。

* 重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常

##### Super 关键字的使用

当需要在子类中调用父类的被重写方法时，要使用 super 关键字。

```java
class Dog extends Animal{

   public void move(){
      super.move(); // 应用super类的方法
      System.out.println("狗可以跑和走");
   }
}
Animal b = new Dog(); 
b.move(); //执行 Dog类的方法

动物可以移动
狗可以跑和走
```

#### 重载 (Overload)

重载 (overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型呢？可以相同也可以不同。

每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

最常用的地方就是构造器的重载。

**重载规则：**

* 被重载的方法必须改变参数列表；
* 被重载的方法可以改变返回类型；
* 被重载的方法可以改变访问修饰符；
* 被重载的方法可以声明新的或更广的检查异常；
* 方法只能在同一个类中被重载。
* 无法以返回值类型作为重载函数的区分标准。

**实例：**

```java
public int test(){
    System.out.println("test1");
    return 1;
}

public void test(int a){
    System.out.println("test2");
}	

//以下两个参数类型顺序不同
public String test(int a,String s){
    System.out.println("test3");
    return "returntest3";
}	

public String test(String s,int a){
    System.out.println("test4");
    return "returntest4";
}	
```



#### 总结

方法的重写 (Overriding) 和重载 (Overloading) 是 java 多态性的不同表现。重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。

1. 方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载 (Overloading)。
2. 方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写 (Overriding)。
3. 方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。

**重写与重载之间的区别：**

![image-20240322083419617](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240322083419617.png) 

![image-20240322083452116](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240322083452116.png)  

## Java集合框架

### Java 8系列之重新认识HashMap

HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet  Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。

Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap

(1) **HashMap**：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。  HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。

(2) **Hashtable**：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。

(3) **LinkedHashMap**：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。

(4) **TreeMap**：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。

对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。

**搞清楚HashMap，首先需要知道HashMap是什么，即它的存储结构-字段；其次弄明白它能干什么，即它的功能实现-方法。下面我们针对这两个方面详细展开讲解。**

#### 存储结构-字段

从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240326133555982.png" alt="image-20240326133555982" style="zoom:50%;" /> 

(1) 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。我们来看Node[JDK1.8]是何物。
Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。

(2)  HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。

```
map.put("美团","小美");
```

系统将调用”美团”这个key的hashCode()方法得到其hashCode  值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。

如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。

在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：

```
int threshold;             // 所能容纳的key-value对极限 
final float loadFactor;    // 负载因子
int modCount;  
int size;  
```

首先，Node[] table的初始化长度length(默认值是16)，Load  factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。

结合负载因子的定义公式可知，threshold就是在此Load  factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，**这个值可以大于1**（？）。

size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。

在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考[这篇文章](http://blog.csdn.net/liuqiyao_01/article/details/14475159)，Hashtable初始化桶大小为16，HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。

这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考[这篇文章](http://blog.csdn.net/v_july_v/article/details/6105630)。

#### 功能实现-方法

##### 确定哈希桶数组索引位置

HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。

不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。

```java
static final int hash(Object key) {
    int h;
    // h = key.hashCode() 为第一步 取hashCode值
     // h ^ (h >>> 16)  为第二步 高位参与运算
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

Hash算法本质上就是两步：**取key的hashCode值、高位运算**

对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^  (h >>>  16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。

**取模运算**

```java
 if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);
```

调用这个方法**i = (n - 1) & hash**来计算该对象应该保存在table数组的哪个索引处。

这个方法非常巧妙，它通过h & (table.length  -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h& (length-1)运算等价于对length取模，也就是h%length，但是&比%具有更高的效率。

##### HashMap的put

HashMap的put方法执行过程可以通过下图来理解，自己有兴趣可以去对比源码更清楚地研究学习。

![image-20240326140808081](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240326140808081.png) 

①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；

②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；

③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；

④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；

⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树（另外要求size大于64），在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；

⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。

##### 扩容机制resize（）

扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。

#### 线程安全性

在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：

```java
public class HashMapInfiniteLoop {  

    private static HashMap<Integer,String> map = new HashMap<Integer,String>(2，0.75f);  
    public static void main(String[] args) {  
        map.put(5， "C");  

        new Thread("Thread1") {  
            public void run() {  
                map.put(7, "B");  
                System.out.println(map);  
            };  
        }.start();  
        new Thread("Thread2") {  
            public void run() {  
                map.put(3, "A);  
                System.out.println(map);  
            };  
        }.start();        
    }  
} 
```

其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。

通过设置断点让线程1和线程2同时debug到transfer方法的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。

![image-20240326144915957](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240326144915957.png) 

注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。

线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。

e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。

于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。

![image-20240326145341670](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240326145341670.png) 

HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。 鉴于JDK1.8做了多方面的优化，总体性能优于JDK1.7。

文章链接：https://tech.meituan.com/2016/06/24/java-hashmap.html

### 对比Vector、ArrayList、LinkedList有何区别？

我们在日常的工作中，能够高效地管理和操作数据是非常重要的。由于每个编程语言支持的数据结构不尽相同，比如我最早学习的 C  语言，需要自己实现很多基础数据结构，管理和操作会比较麻烦。相比之下，Java 则要方便的多，针对通用场景的需求，Java  提供了强大的集合框架，大大提高了开发者的生产力。

今天我要问你的是有关集合框架方面的问题，**对比 Vector、ArrayList、LinkedList 有何区别？**

这三者都是实现集合框架中的 List，也就是所谓的有序集合，因此具体功能也比较近似，比如都提供按照位置进行定位、添加或者删除的操作，都提供迭代器以遍历其内容等。但因为具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同。

Vector 是 Java 早期提供的线程**安全的动态数组**，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。

ArrayList 是应用更加广泛的**动态数组**实现，它本身不是线程安全的，所以性能要好很多。与 Vector 近似，ArrayList 也是可以根据需要调整容量，不过两者的调整逻辑有所区别，Vector 在扩容时会提高 1 倍，而 ArrayList 则是增加 50%。

LinkedList 顾名思义是 Java 提供的**双向链表**，所以它不需要像上面两种那样调整容量，它也不是线程安全的。

似乎从我接触 Java 开始，这个问题就一直是经典的面试题，前面我的回答覆盖了三者的一些基本的设计和实现。

一般来说，也可以补充一下不同容器类型适合的场景：

Vector 和 ArrayList 作为动态数组，其内部元素以数组形式顺序存储的，所以非常适合随机访问的场合。除了尾部插入和删除元素，往往性能会相对较差，比如我们在中间位置插入一个元素，需要移动后续所有元素。

而 LinkedList 进行节点插入、删除却要高效得多，但是随机访问性能则要比动态数组慢。

所以，在应用开发中，如果事先可以估计到，应用操作是偏向于插入、删除，还是随机访问较多，就可以针对性的进行选择。这也是面试最常见的一个考察角度，给定一个场景，选择适合的数据结构，所以对于这种典型选择一定要掌握清楚。

原文链接：https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/08%20%20%e5%af%b9%e6%af%94Vector%e3%80%81ArrayList%e3%80%81LinkedList%e6%9c%89%e4%bd%95%e5%8c%ba%e5%88%ab%ef%bc%9f-%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4.md















# 项目笔记 

### 留言板项目：

![image-20240126133325443](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240126133325443.png)

1、在设置点赞的时候，你要用到<button onclick="点赞函数（this）">，这里面的this就是button按钮本身，通过**this.parentNode**,来访问到父级的容器节点，通过在**父级的容器节点.querySelect("点赞数")**，来获取到点赞按钮对应的点赞数。

2、设置了每一次在刷新或是发布评论时，随机更换头像。

### todolist项目：

要求：用前端三件套去实现todolist的基本功能，并结合git实现版本管理

成果图：

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E6%88%90%E6%9E%9C1.png" alt="image-20240128113121971" style="zoom: 80%;" /> 

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E6%88%90%E6%9E%9C2.png" alt="image-20240128113225760" style="zoom:80%;" /> 

心得：

1. 对于每一项任务的删除或完成操作，借鉴了留言板项目的点赞功能，通过this.parentNode找到父级容器，然后运用node.remove()操作进行删除操作
2. 批量操作师根据复选框的checked属性进行if判断的，勾选则checked属性为true，用forEach进行批量操作
3. 不完善的点，每一次计算待办任务和已完成任务的数量，都要重新计算类数组的长度，我觉得可以用监听来实现这一点，只要类数组的长度有变化，就会立即更新待办任务和已完成任务的数量，而不用在每一个需要删除和完成操作的函数最后面进行更新

### 用户中心项目：

完整了解做项目的思路，接触一些企业级的开发技术（尽量少写代码）

#### 企业做项目流程

需求分析=>设计（概要设计，详细设计）=> 技术选型=>初始化项目/引入需要的技术=>写Demo=>写代码（实现业务逻辑）=>测试（单元测试）=>代码提交/代码评审=>部署=>发布

#### 需求分析

1. 登录/注册

2. 数据库设计：

   id（主键）bigint

   username 昵称 varchar

   userAccount 登录账号 

   avatarUrl 头像 varchar

   gender 性别 tinyint

   userPassword 密码 varchar

   phone 电话 varchar

   email 邮箱 varchar

   isValid 是否有效 (比如被封号)tinyint 0 1

   ------

   createTime 创建时间（数据插入时间）datetime

   updateTime 更新时间（数据更新时间）datetime

   isDelete 是否删除0 1（逻辑删除）tinyint

3. 用户管理（仅管理员可见）对用户的查询、修改

4. 用户校验（仅星球用户）

   

   

#### 技术选型

前端：三件套+React+组件库Ant Design+Umi+Ant Design Pro（现成的管理系统）

后端：java + spring + springmvc + mybatis + mybatis-plus+springboot+mysql

部署：服务器+容器（平台）

#### 计划

1. 初始化项目
   1. 前端初始化
      1. 初始化项目
      2. 引入一些组件
      3. 框架介绍/项目瘦身
   2. 后端初始化
      1. 准备环境（MySql之类的）
      2. 引入框架（整合框架）
2. 登录/注册
   1. 前端
   2. 后端
3. 用户管理（仅管理员可见）
   1. 前端
   2. 后端

#### 注册逻辑

1. 用户在前端输入账号和密码，以及校验码
2. 校验用户的账户、密码、验证密码是否符合要求
   1. 非空
   2. 账户的话**不小于**4位
   3. 密码**不小于**8位
   4. 账户不能重复
   5. 账户不包含特殊字符
   6. 密码和验证密码相同
3. 对密码进行加密（密码千万不能直接以明文储存到数据库中）
4. 向数据库插入用户数据

#### 登录接口

接受参数： 用户账户、密码

请求类型：POST

请求体：JSON格式的数据

> 请求参数很长时，不建议用get

返回值：用户信息（**脱敏**） 

#### 登录逻辑

1. 校验用户账户密码是否合法 
   1. 非空
   2. 账户的话**不小于**4位
   3. 密码**不小于**8位
   4. 账户不包含特殊字符
2. 校验密码是否输入正确，要和数据库中的密文密码去比对
3. 返回用户信息（脱敏），隐藏敏感信息，防止数据库中的字段泄露
4. 记录用户的登录态（session），将其存到服务器上（用后端springboot框架封装的服务器tomcat去记录）
5. 返回脱敏后的用户信息

#### 用户管理接口

！！！必须鉴权

1. 查询用户
   1. 允许根据用户名查询
2. 删除用户

#### 如何知道那个用户登录了？（javaweb）

1. 连接服务器端后，得到一个session状态（匿名会话），返回给前端

2. 登陆成功后，得到一个登录成功的session，并给该session设置一些值，比如说用户信息，返回给前端一个设置cookie的命令。

   **session => cookie **

3. 前端接受到后端命令后，奢姿cookie，保存到浏览器内

4. 前端再次请求后端的时候（相同的域名），在请求头带上cookie去请求

5. 后端拿到前端传来的cookie，找到对应的session

6. 后端从session中可以取出基于该session存储的变量（用户的登录信息、登录名）


#### 前后端交互

前端需要向后端发送请求

前端ajax来请求后端

axious封装了ajax

request是ant design项目有封装了一次

#### 代理

正向代理：替客户端向服务器发送请求，

反向代理：替服务器接受请求，

怎么搞代理？

Nginx服务器

node.js服务器

![image-20240207144306714](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240207144306714.png)

#### 问题解决：

1. 前端初始化，在使用官网命令时，没有umi3选项？

   在cmd输入yarn global add create-umi@0.27.0，建个myapp文件夹，在这个文件夹的cmd下输入create-umi。如果在输入create-umi显示是外部命令（这是yarn的小毛病，yarn全局安装的包确实用不了），需要先**yarn global bin**找到yarn的bin目录，然后再把此目录添加进环境变量。

   总结：没有使用官方的命令，而是通过全局下载的create-umi



2. 前端初始化，yarn global add create-umi@0.27.0网络一直ping不通报？

   yarn和npm一样都可以配置淘宝镜像源，配置之后可以通过yarn config list检查。配置成功之后要关掉梯子。



3. 后端初始化，在配置java版本时，最低也只能到java17版本，需要java8？

   原因是springboot官方停止了对springboot2的维护，解决办法就是在IDEA里更改Server URL即可，用阿里云的镜像。

![image-20240202090502436](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240202090502436.png)

4. 连接数据库时，mysql连接不了，经过查找发现是Mysql服务无法启动的问题？

![image-20240202094357389](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240202094357389.png)

![image-20240202100104008](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240202100104008.png) 

直接专业卸载

5. 打开金师播放器后，复制粘连键用不了了？

   win + r 打开命令框，输入 cmd.exe /c echo off | clip （每次打开播放器观看都需要输入）

### 零钱通项目：

 使用 Java 开发 零钱通项目 , 完成收益入账，消费，查看明细，退出系统等功能。面向过程编程、面向对象编程两种方式

![image-20240303110648477](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303110648477.png) 

### 房屋出租系统

实现基于文本界面的《房屋出租软件》。

 能够实现对房屋信息的添加、修改和删除（用数组实现），并能够打印房屋明细表

![image-20240303164142160](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303164142160.png) 

![image-20240303164216502](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303164216502.png) 

**退出系统**

![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303164243311.png) 

**设计分析**

![image-20240303165520739](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303165520739.png) 

# 算法笔记

## 数组专项

### 二分查找

二分查找是先找到一个区间的中间位置middle，和某个target进行比较，可能这个middle就是target；也可能target大于middle，说明target是在左区间，反之target则在右区间，然后循环。

首先要想到一个while循环，循环条件是left和right比大小。其次，也是难点，**要根据区间的分类进行写代码，不同的区间，代码的形式不一样**。区间一般来讲，分为**左闭右闭**，和**左闭右开**。

#### **左闭右闭**

1. left等于0，right等于**arr.length-1**，因为是右闭，**如果right等于arr.length就说明arr.length在我们的范围区间里面**，而这是错误的

2. while的循环条件是(**left <= right**)，因为是左闭右闭，所以存在left等于right的情况，例如：[1,1]这是合理的区间

3. 当arr[middle] > target，说明target在左区间，left不需要改变，但是right需要改变，**此时right等于middle - 1**，**因为是右闭，已经明确得知arr[middle] > target的情况下，说明middle索引的数不等于target，middle不在范围区间里面，所以要middle - 1**

4. 当arr[middle] < target，说明target在右区间，right不需要改变，但是left需要改变，**此时left等于middle + 1**，原因同3

   ```java
   public static int search1(int[] nums, int target) {
           int right = nums.length - 1;
           int left = 0;
           int middle;
           while (left <= right) {
               middle = (left+right) / 2;
               if (nums[middle] > target) {
                   right = middle - 1;
                   continue;
               }
               if (nums[middle] < target) {
                   left = middle + 1;
                   continue;
               }
               return middle;
           }
           return -1;
       }
   ```

#### **左闭右开**

1. left等于0，right等于**arr.length**，因为是右开，**right等于arr.length这个范围区间本来就不包含arr.length这个索引**

2. while的循环条件是(**left < right**)，因为是左闭右开，不存在left等于right的情况，例如：[1,1）这是不合理的区间

```java
 public static int search2(int[] nums, int target) {
        int right = nums.length;
        int left = 0;
        int middle;
        while (left < right) {
            middle = (left+right) / 2;
            if (nums[middle] > target) {
                right = middle;
                continue;
            }
            if (nums[middle] < target) {
                left = middle + 1;
                continue;
            }
            return middle;
        }
        return -1;
    }
```

#### 总结

不管是左闭右闭也好，还是左闭右开也好，当你确定了一个区间分类后，在以后的代码分析中就要坚持这个想法，明确边界的范围。

### 移除元素

这个要求原地移除所有等于Val的数值，并返回新数组的长度。我们知道数组是不能拓展它自身的，除非嫁接到一个新的数组，而题目要求在原地进行操作。所以我们提出来**双指针的算法**来解决这一题。

**双指针算法**：

一个快指针（fast），一个慢指针（slow），它们的作用是：fast指针是通过遍历找到**不等于Val**的索引（这是要删除的，这是不满足新数组的数值），slow指针是在原地把**符合新数组的数值（fast找到的）**拷贝过来，fast指针和slow指针是在同一个数组里面，只是作用不一样。而且最后我们可以发现slow指针所指向的索引是新数组的长度。

```java
public static int removeElement(int[] nums, int val) {
    int slow = 0;
    for (int fast = 0; fast < nums.length; fast++) {
        if (nums[fast] != val) {
            nums[slow] = nums[fast];
            slow++;
        }
    }
    return slow;
}
```

### 有序数组平方

这个题我先开始是用平方，后用冒泡排序做的，但是发现时间复杂度太高，平方哪里遍历了一次所有的数组，然后再是冒泡排序，时间开销很大。

后面，有一种双指针的算法，可以极大的节省时间开销。而且这个题目也很有特点：它是要比较平方之后的大小，**那么越靠近两边的数，平方之后就越大**，因为可能有负数，而中间的数平方之后最小。那么就可以**设计一种双指针，一个指针指向头，一个指针指向尾，然后两个指针平方之后比大小,大的就存放进新数组**，然后进行相应的数据处理。

```java
//双指针的思路，时间复杂度低，但是多用了一个result数组 
public static int[] sortedSquares (int[] nums) {
        int[] result = new int[nums.length];
        int k = nums.length - 1;
        for (int i = 0,j = nums.length - 1; i <= j; ) {
            if (nums[i]*nums[i] > nums[j]*nums[j]) {
                result[k--] = nums[i]*nums[i];
                i++; //i要加一，而j不变，可以看到i和j不因循环次数而改变，只有相应的条件到达才能改变i，j的值
            } else {
                result[k--] = nums[j]*nums[j];
                j--;
            }
        }
        return result;
}
```

```java
//先平方，后用冒泡排序，时间复杂度高，但是是原地排序
public static int[] sortedSquares1 (int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        nums[i] = nums[i] * nums[i];
    }
    for (int i = 0; i < nums.length - 1; i++) {
        for (int j = 0; j < nums.length - 1 - i; j++) {
            if (nums[j] > nums[j+1]) {
                int temp = nums[j];
                nums[j] = nums[j+1];
                nums[j+1] = temp;
            }
        }
    }
    return nums;
}
```

### 长度最小的子数组

先开始想错了，以为可以先排序好，然后从头开始遍历找到最短的子数组满足target。题目要求数组不能动，你要在不懂原数组的基础上面，找到最小的大于等于target的子数组。

可以考虑用到滑动窗口的算法解。滑动窗口首先就要想到两个指针，滑动的区间就是这两个指针之间的区域，问题是怎么滑动这个区间。

首先，一个j指针，从头到尾开始移动，j指针移动到某个条件时，i指针开始滑动。这个条件就是当滑动区间的sum刚好大于或等于target的时候，进入到i指针的动作，i指针会向前移动一位，sum会减小，而且还要比较result和当前滑动区间的长度谁更小。

```java
public static int lengthOfLongestSubstring(int[] nums, int target) {
        int i = 0;
        int sum = 0;
        int result = nums.length;
        for (int j = 0; j < nums.length; j++) {
            sum += nums[j];
            while (sum >= target) { //这里是while而不是if，因为i有可能连续滑动(1,1,1,1,100),target=100
                sum -= nums[i];
                result = Math.min((j-i+1), result);
                i++;
            }
        }
        if (i == 0) {//i==0，说明for循环根本没有进入到while循环里面去，说明一直到滑动完，整个滑动区间的长度都没有大于target的情况
            return 0;
        }
        return result;
    }
}
```

### 螺旋矩阵

这一题是采用模拟的做法做出来的，模拟这个旋转矩阵。

首先就是要确定这个螺旋矩阵，我们模拟旋转的话，会转多少圈？答案是n / 2圈，但是当n为奇数时，我们单独处理中间的位置。

其次，我们要确定走的边的规则是什么，我的规则是左闭右开，那么就应该在4个for循环中都遵循左闭右开原则。

最后注意边界位置。

![image-20240312210028972](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312210028972.png) 

```java
public int[][]  generateMatrix(int n) {
        int[][] matrix = new int[n][n];
        int startX = 0;
        int startY = 0;
        int offset = 1;
        int count = 1;

        int circle = n / 2;
        while(circle-- > 0) {
            for (int j = startY; j < n - offset; j++) {
                matrix[startX][j] = count++;
            }
            for (int i = startX; i < n - offset; i++) {
                matrix[i][n - offset] = count++;
            }
            for (int j = n - offset; j > startY; j--) {
                matrix[n - offset][j] = count++;
            }
            for (int i = n - offset; i > startX; i--) {
                matrix[i][startY] = count++;
            }
            startX++;
            startY++;
            offset++;
        }
        if(n % 2 == 1) {
            matrix[n/2][n/2] = n * n;
        }
        return matrix;
}
```

## 链表专项

### 移除链表元素

#### 原链表删除元素

移除链表元素有两种解法，我采用的原链表删除元素。这里就要考虑到头节点的删除和头结点之外的删除是不一样的。

删除头结点：如果头结点的val满足条件，那么就将head指针移向下一个节点即可；

删除非头结点：先把head指针赋值给current指针，当current.next.val满足条件时，则将current.next 指向current.next.next以此来达到删除的目的

注意，两个都要保证节点部位空。

```java
 public ListNode removeElements(ListNode head, int val) {
        while (head != null && head.val == val) {
            head = head.next;
        }
        ListNode current = head;

        while (current != null && current.next != null) {
            if (current.next.val == val) {
                current.next = current.next.next;
            }
            else {
                current = current.next;
            }

        }
        return head;
 }
```

#### 虚拟头结点删除元素

采用虚拟头结点删除元素可以统一代码形式，而采用原链表删除元素的会有头结点和非头结点的区分。

首先就是要定义一个虚拟头结点，ListNode dummyHead = new ListNode(0,head);

然后就是，定义一个当前节点current，注意，是指向虚拟头结点，而不是虚拟头结点的next，因为头结点也可能被删除；

然后，while循环的条件是，current.next != null，说明还没有遍历到最后一个元素

最后返回的是虚拟头结点的next，而不是head，因为head有可能被删除，就是说链表一个元素都没有，都被删除了，如果此时返回head，那就剩head这个节点。

```java
//虚拟头结点删除元素
    public ListNode removeElements2(ListNode head, int val) {
        ListNode dummyHead = new ListNode(0,head); //先定义一个虚拟头结点
        ListNode current = dummyHead;
        while (current.next != null) {
            if (current.next.val == val) {
                current.next = current.next.next;
            } else {
                current = current.next;
            }
        }
        return dummyHead.next;
}
```

```java
//链表结构
class ListNode {
      int val;
      ListNode next;
      ListNode() {}
      ListNode(int val) { this.val = val; }
      ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}
```

### 设计链表

这题首先要想到用一个**虚拟头结点**来代表整个链表，这样设计的代码结构清晰，逻辑清楚，注意这时候可以只用虚拟头结点，而不需要在使用head指针。至于说，为什么统一，可以看代码，统一了头结点和非头结点的操作。

其次，要想到在这个链表类中，定义一个内部类Node，这样就可以很好的区分LinkedList类，虽然这两个类本质上没有什么区别，但是逻辑上给人很清晰的感觉。

注意，要定义一个全局的size，这样就可以在增删改查时，利用size快速索引出对应的index

```java
public class MyLinkedList {
    class Node {
        int val;
        Node next;
        public Node(int val) {
            this.val = val;
            this.next = null;
        }
    }

    int size;
    Node dummyHead;

    public MyLinkedList() {
        size = 0;
        dummyHead = new Node(0);
    }

    public int get(int index) {
        if (index<0 || index >= size) {
            return -1;
        }

        Node current = dummyHead;
        int i = 0;
        while (true) {
            if (index == i) {
                return current.next.val;
            }
            i++;
            current = current.next;
        }
    }

    public void addAtHead(int val) {
        Node node = new Node(val);
        node.next = dummyHead.next;
        dummyHead.next = node;
        size++;
    }

    public void addAtTail(int val) {
        Node node = new Node(val);

        Node current = dummyHead;
        while (current.next != null) {
            current = current.next;
        }
        current.next = node;
        size++;
    }

    public void addAtIndex(int index, int val) {
        if (index<0 || index >size ) {
            return;
        }
        if (index == size) {
            addAtTail(val);
            return;
        }

        Node node = new Node(val);
        Node current = dummyHead;
        int i = 0;
        while (true) {
            if (i == index) {
                node.next = current.next;
                current.next = node;
                size++;
                return;
            }
            current = current.next;
            i++;
        }
    }

    public void deleteAtIndex(int index) {
        if (index<0 || index >= size) {
            return;
        }
        Node current = dummyHead;
        int i = 0;
        while (true) {
            if (index == i) {
                current.next = current.next.next;
                size--;
                return;
            }
            i++;
            current = current.next;
        }
    }
}

class MyLinkedListTest {
    public static void main(String[] args) {
        MyLinkedList myLinkedList = new MyLinkedList();
        myLinkedList.addAtHead(5);
        myLinkedList.addAtIndex(1, 2);
        myLinkedList.get(1);
        myLinkedList.addAtHead(6);
        myLinkedList.addAtTail(2);
        myLinkedList.get(3);
        myLinkedList.addAtTail(1);
        myLinkedList.get(5);
        myLinkedList.addAtHead(2);
        myLinkedList.get(2);
        myLinkedList.addAtHead(6);
    }
}
```

### 反转链表

这一题，我是采用双指针的思路来写的，一个是current指针，指向当前的节点，另一个是pre指针，在current前面一位。记得还要有一个临时指针temp哦

首先是初始化，current初始化为head，pre初始化为null，想想为什么？然后想像一下这两个指针在完成current.next = pre之后，同时向后移动，直到pre指向最后一个节点，而current指向null，所以current == null是终止条件。

注意顺序哦，要先temp = current.next，保存current的下一个节点，然后就将current.next指向前一个节点pre，然后县移动pre = current，在移动current = temp

```java
//双指针解法
public static ListNode reverseList(ListNode head) {
    ListNode current = head;
    ListNode pre = null;
    ListNode temp;

    while (current != null) {
        temp = current.next;
        current.next = pre;
        pre = current;
        current = temp;

    }
    return pre;
    }
}
```

### 两两交换链表中的节点

这个题目首先是要想到虚拟头结点，然后你就要想象交换两两节点的一个大致流程：

流程：dummyHead先指向第二个节点，然后原始第二个节点指向原始第一个节点，然后原始第一个节点指向原始第三个节点，这样就完成了节点的两两交换，然后将current指针向前移动两位，开始进行下一轮的操作

注意的点：

1. 循环结束的条件，如果是奇数个节点，循环结束的条件是current.next.next为null；如果是偶数个节点，循环结束的条件是current.next为null，所以综合起来就是**while(current.next != null && current.next.next != null)**,一定要注意顺序，否则会造成NPE
2. 流程走向的具体细节，当dummyHead先指向第二个节点的时候，会失去current.next原本指向的第一个节点，这里要用一个临时指针保存；当原始第二个节点指向原始第一个节点的时候，会失去原本第二个节点.next指向的第三个节点，所以也要用一个临时指针保存。

```java
public ListNode swapPairs(ListNode head) {
    ListNode dummyHead = new ListNode();
    dummyHead.next = head;
    ListNode current = dummyHead;

    while (current.next != null && current.next.next != null) {
        ListNode temp = current.next;
        ListNode temp2 = current.next.next.next;
        current.next = current.next.next;
        current.next.next = temp;
        temp.next = temp2;

        current = current.next.next;
    }
    return dummyHead.next;
}
```

### 删除链表中倒数第N个节点

我首先是先循环遍历，得出链表的长度，然后计算得出删除节点的索引。删除的主题思想使用双指针，pre和current，然后就要考虑空指针异常，我就采用的虚拟头结点，这样当链表中只有一个节点的时候，我可以统一起来，pre指向dummyHead，current指向head，循环结束的条件是current遍历到对应的index为止，执行pre.next = current.next删除操作。

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    int length = 0;
    ListNode tempNode = head;
    while (tempNode != null) {
        length++;
        tempNode = tempNode.next;
    }

    int index = length - n;
    ListNode dummyHead = new ListNode();
    dummyHead.next = head;
    ListNode pre = dummyHead;
    ListNode current = head;
    for (int i = 0; i <= index; i++) {
        if (i == index) {
            pre.next = current.next;
            break;
        }
        pre = current;
        current = current.next;
    }
    return dummyHead.next;
}
```

### 链表相交

判断链表相交的思路是，**把两个链表右对齐**，只用判断右对齐后，从左往右判断他们的节点是否相等，来判断出相交的节点。这种思路很巧妙，规避了常规思路左对齐的各种分类讨论情况。

具体实现步骤是：先算出两个链表的长度；然后移动长度较长的current指针，使其右对齐；循环比较两个节点的current是否相等，来判断是否为相交节点。

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    int lengthA = getLength(headA);
    int lengthB = getLength(headB);
    ListNode currentA = headA;
    ListNode currentB = headB;
    if (lengthA > lengthB) {
        for (int i = 0; i < lengthA - lengthB; i++) {
            currentA = currentA.next;
        }
    }
    if (lengthA < lengthB) {
        for (int i = 0; i < lengthB - lengthA; i++) {
            currentB = currentB.next;
        }
    }

    while (currentA != currentB) {
        currentA = currentA.next;
        currentB = currentB.next;
    }
    return currentA;
}

public int getLength(ListNode current) {
    int length = 0;
    while (current != null) {
        length++;
        current = current.next;
    }
    System.out.println(length);
    return length;
}
```

### 环形链表二

首先这题是要你找到环形链表的入口节点。分为两步，第一步先判断是否有环，第二步既然有环，根据第一步找到的相遇节点结合头结点找到环形的入口节点。

第一步先判断是否有环：

首先就是定义两个快慢指针，快指针一次走走两步，慢指针一次走一步，那么如果他们相遇，他们必定是在环里面相遇，也证明了存在环；如果不相遇，那说明快指针先走到了结尾，说明没有环。如果有环，他们必定相遇在环内，这个相遇节点我们有安排

第二步既然有环，根据第一步找到的相遇节点结合头结点找到环形的入口节点：

![image-20240321200856016](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240321200856016.png) 

这里就要考察数学公式了，首先重新定义一个current指针指向head，然后让current指针和slow指针同时向后移动，直到他们相遇，相遇的节点就是环形的入口节点。

slow：**(X + Y)  * 2 = X + Y + (Y + Z)*N** :fast

==> X + Y = (Y + Z) * N

==>X = (Y + Z) * (N - 1) + Z    (N >= 1)

**当N = 1时，有X = Z**，这说明current移动到环形的入口节点的距离 与 slow指针移动到环形的入口节点的距离正好相等。也可以推断，当N > 1时，这两个指针的第一次相遇都是在环形的入口节点。

```java
public static ListNode detectCycle(ListNode head) {
    ListNode fast = head;
    ListNode slow = head;
    do {
        try {
            fast = fast.next.next;
        } catch (Exception e) {
            return null;
        }
        slow = slow.next;
    } while (fast != slow);

    ListNode current = head;
    while (current != slow) {
        current = current.next;
        slow = slow.next;
    }
    return current;
}
```

## 哈希专项

### 有效字母异位词

首先要理解题意，异位词是指，若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

然后，我是第一次用hash表的解法，用hash的解法要想到三种数据结构分别是：数组、Set、Map

这是我是采用数组的方式来解这一题的，思路是：

首先你要想到用一个长度为26的整型数组，来记录26个小写字母出现的次数，

先看第一个字符串s，我们循环遍历s，hash [ **s.chatAt(i)  -  'a'** ] ++,字符会自动转型为整型，它会计算该字符与a字符的相对距离，这样就可以用hash数组的索引来表示每个字母出现的个数了，0表示a，1表示b，25表示z

然后我们遍历第二个字符串t，这里我们要做减减的操作，hash [ **s.chatAt(i)  -  'a'** ] --。

通过第一个for循环做加加操作，通过第二个for循环做减减操作，只要我们发现最后hash数组里面有元素大于0，或者是小于0，说明，这两个字符串肯定有些元素多了或是有些元素少了，总之就是不相等

~~~java
public static boolean isAnagram(String s, String t) {
    int[] hash = new int[26];
    for (int i = 0; i < s.length(); i++) {
        hash[s.charAt(i) - 'a']++;
    }
    for (int i = 0; i < t.length(); i++) {
        hash[t.charAt(i) - 'a']--;
    }
    for (int i = 0; i < 26; i++) {
        if (hash[i] != 0) {
            return false;
        }
    }
    return true;
}
~~~

### 两个数组的交集

我的思路是，先把其中一个数组num1转换成HashSet，这样可以为num1数组去重，然后我已num2数组为遍历，去查找num2的元素是否会出现在Hashset中，出现就把它存入到result的Hashset里面，这样就又可以去重（针对num2），最后再把result转换成整型数组。

难点就是，怎样把整型数组转换成HashSet，怎样把Hash装换成整形数组

~~~java
HashSet numSet= new HashSet<>(nums1.length);
        HashSet result= new HashSet<>(nums1.length);
        for (int i : nums1) {
            numSet.add(i);
        }

        for (int i : nums2) {
            if (numSet.contains(i)) {
                result.add(i);
            }
        }
        int[] arr = new int[result.size()];
        Object[] array = result.toArray();
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int)array[i];
        }
        return arr;
~~~

### 快乐数

**快乐数」** 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。

```
输入：n = 19
输出：true
解释：
1**2 + 9**2 = 82
8**2 + 2**2 = 68
6**2 + 8**2 = 100
1**2 + 0**2 + 0**2 = 1
```

首先这题不要想复杂了，很简单，一轮计算过程是：分别取出所有位数，然后平方求和看是不是1，如果不是就开始下一轮。

题目可以简化，把这些求出来的下一轮n，都统一放进一个Hashset中，如果在一轮一轮的计算过程中，发现这个下一轮n，竟然已经出现在Hashset中，那么说明再过一段时间，也会重复出现这个n，说明程序出现了无限循环，而这个数自然也不是happy数。那么当我发现下一轮n已经存在Hashset中是2，我就可以结束循环了，再就是确确实实出现了n ==  1，这就是happy数。

~~~java
public boolean isHappy(int n) {
    HashSet<Integer> set = new HashSet<>();
    while (n != 1 && !set.contains(n)) {
        set.add(n);
        n = getNextNum(n);
    }
    return n == 1;
}

public int getNextNum(int num) {
    int result = 0;
    int temp;
    while (num != 0) {
        temp = num % 10;
        result += temp * temp;
        num /= 10;
    }
    return result;
}
~~~

### 两数之和

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

其实这一题，很容易想到用两层for循环，循环遍历，直到找出两个数之和为target。但是我想用map的方式来解这一题，具体思路如下：

首先就是要定义一个HashMap，这个map的作用是遍历存放这个nums数组的元素值，和索引，具体来说：key=元素的值，value=元素在数组中的索引。这里我们只用一层for循环，在这循环里面我们首先计算target和nums[i]的差值，即**int s = target - num[i]**；然后我们判断这个s是否存在于map的key中，这样做的**目的在于，既然我的s存在于你的map中，那么map的这个key与nums[i]的和就是target，这就找到了**，只要返回这两个索引即可。

~~~java
public int[] twoSum(int[] nums, int target) {
    int[] res = new int[2];
    HashMap<Integer, Integer> map = new HashMap<>();

    for (int i = 0; i < nums.length; i++) {
        int s = target - nums[i];
        if (map.containsKey(s)) {
            res[0] = i;
            res[1] = map.get(s);
            break;
        }
        map.put(nums[i],i);
    }
    return res;
}
~~~

### 四数相加III

这个题目是四个数字，然后找出所有的nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0的个数，可以直接采用暴力解法，通过四层for循环，可以把所用的情况都遍历出来，而且不需要去重。

但是这一题我们采用哈希map的方式来解这一题，这是一道经典的采用map方式解决的一题。

思路：

首先定义两层for循环，将数组一num1和数组二num2的和保存到map的key中，那么map的value保存的是这个求和的值出现的次数；
然后，再定义两层for循环，去遍历数组三num3和数组四num4的和的相反数，在map的key中去匹配是否有与这个相反数相匹配的；
如果有的话，那么count的值要加上此时key对应的value值

代码：

~~~java
public static int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
    Map<Integer, Integer> map = new HashMap<>();
    int count = 0;

    for (int k : nums1) {
        for (int i : nums2) {
            int temp = k + i;
            map.put(temp, map.getOrDefault(temp, 0) + 1);
        }
    }

    for (int k : nums3) {
        for (int i : nums4) {
            int temp = -k - i;
            count += map.getOrDefault(temp, 0);
        }
    }

    return count;
}

~~~

### 赎金信

给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。

如果可以，返回 `true` ；否则返回 `false` 。

`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。

**示例 ：**

```
输入：ransomNote = "aa", magazine = "ab"
输出：false
输入：ransomNote = "aa", magazine = "aab"
输出：true
```

这一题很明显是要采用HashMap来做的，思路如下：

首先就是要遍历magazine，把它put到map中，key对应字符串中的字符，value对应该字符在字符串中出现的次数

然后遍历第二个字符串ransomNote，取到的字符在map中是否存在，如果不存在就直接return false，否则把该字符key对应的value减一，而且我们还要判断这个value的值是否小于0，如果小于0也要返回false。最后for循环后，return true

~~~java
public static boolean canConstruct(String ransomNote, String magazine) {
    Map<Character, Integer> map = new HashMap<>();

    for (int i = 0; i < magazine.length(); i++) {
        char c = magazine.charAt(i);
        map.put(c, map.getOrDefault(c, 0) + 1);
    }

    for (int i = 0; i < ransomNote.length(); i++) {
        char c = ransomNote.charAt(i);
        map.put(c, map.getOrDefault(c, 0) - 1);
        if (map.get(c) < 0) {
            return false;
        }
    }
    return true;
}
~~~

### 三数之和

给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]]，满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0。你返回所有和为 0 且不重复的三元组。注意：答案中不可以包含重复的三元组。

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。

这一题不能用Hash的解法，因为太过复杂。这题我是采用双指针的解法，思路如下：

首先，最外层是一个for循环遍历nums，然后定义一个left指针指向i+1，一个right指针指向num.length - 1的索引位置。，这里我们要再定义一个while循环，再循环里面如果nums[i] + nums[left] + nums[right] == 0的话，这是满足条件的，可以直接add到集合中；如果nums[i] + nums[left] + nums[right] > 0，说明sum大了，要将right左移；如果nums[i] + nums[left] + nums[right] <  0，说明sum小了，要将left右移。这就是大概的一个流程，但是问题的关键在于去重。

如何去重？首先我想到的是i的去重，如果num[i] == num[i - 1]，说明我前面的i对应的值，和当前的i对应的值相等，那么前面i的数据对应的三元组（如果求得的话），也应该是一样的，那么这里我就要进行一次去重，直接continue

然后就是当nums[i] + nums[left] + nums[right] == 0，按道理我们应该同时进行right--和left++，但是考虑到：例如：如果我的nums[right] == nums[right-1],那这说明我当前的right的值和下一个right的值相等，在得知i是一定的，而right的值也是一定的情况下，那left的值也一定是固定的，这就是我们要去重的，具体做法是**while（nums[right] == nums[right - 1] && left < right）right--;**。同理**while (nums[left] == nums[left + 1] && left < right) {left++;}**，这就是三次去重操作。

~~~java
public static List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> list = new ArrayList<>();
    Arrays.sort(nums);

    if (nums[0] > 0) {
        return list;
    }

    for (int i = 0; i < nums.length; i++) {
        int left = i + 1;
        int right = nums.length - 1;

        if (i > 0 && nums[i] == nums[i - 1]) {
            continue;
        }

            while (left < right) {
                int temp = nums[i] + nums[left] + nums[right];
                if (temp > 0) {
                    right--;
                } else if (temp < 0) {
                    left++;
                } else {
                    list.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    while (nums[right] == nums[right - 1] && left < right) {
                        right--;
                    }
                    while (nums[left] == nums[left + 1] && left < right) {
                        left++;
                    }
                    left++;
                    right--;
                }
            }
    }
    return list;
}
~~~

### 四数之和

给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：

- `0 <= a, b, c, d < n`
- `a`、`b`、`c` 和 `d` **互不相同**
- `nums[a] + nums[b] + nums[c] + nums[d] == target`

**示例 1：**

```
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

**示例 2：**

```
输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
```

这题目和上一道题三数之和是一个思路，只不过四数之和是四个数，多了一个数，都是用的双指针的思路，只不过原来是for循环里面套双指针，现在是for循环，再套for循环，再用双指针。

首先，当然是先排序，然后先用一个for循环来遍历第一个数i，这里我们要做一步剪枝，这与三数之和一致，但是if里面的判断条件要变化，因为target有小于0的情况，所以向判断**nums[i]>0 && nums[i] > target**，这说明确实没戏了，后面不需要遍历了，永远都得不到target的值，直接return。然后就要做去重的步骤，这和三数之和一致，**i > 0 && nums[i] == nums[i - 1]**

接下来，用第二个for循环，来遍历j，这里的**j的初始值等于i+1**，在这个第二个for循环里面，只用对j进行去重操作，**j > i + 1 && nums[j] == nums[j - 1]**

再就是，在第二个for循环里面定义双指针的遍历，这个和三数之和一模一样

~~~java
public List<List<Integer>> fourSum(int[] nums, int target) {
    List<List<Integer>> list = new ArrayList<>();
    Arrays.sort(nums);


    for (int i = 0; i < nums.length; i++) {
        //一级剪枝
        if (nums[i] > 0 && nums[i] > target) {
            return list;
        }
        //一级去重
        if (i > 0 && nums[i] == nums[i - 1]) {
            continue;
        }
        for (int j = i + 1; j < nums.length; j++) {
            //二级去重
            if (j > i + 1 && nums[j] == nums[j - 1]) {
                continue;
            }

            int left = j + 1;
            int right = nums.length - 1;
            while (right > left) {
                int temp = nums[i] + nums[j] + nums[left] + nums[right];
                if (temp > target) {
                    right--;
                } else if (temp < target) {
                    left++;
                } else {
                    list.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));
                    while (right > left && nums[right] == nums[right - 1]) {
                        right--;
                    }
                    while (right > left && nums[left] == nums[left + 1]) {
                        left++;
                    }
                    right--;
                    left++;
                }
            }
        }
    }
    return list;
}
~~~

## 字符串专项

### 反转字符串II

给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

- 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
- 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。

**示例 1：**

```
输入：s = "abcdefg", k = 2
输出："bacdfeg"
```

这个题目有坑，要仔细审题才行呀，第一次做的时候，我没有把一个公用的操作放入一个函数中，导致后期写代码的时候发现自己写的代码很杂乱，这是一个点。然后这个题目有坑，它题目里面没有说剩余字符大于2k的情况，实际上测试代码里面有剩余字符数大于2k的情况，这时候，就要用while循环来解决，而不是用if，这是第二个点。然后就是题目里面也没有说k大于或等于s的长度的情况，当k大于或等于s的长度的时候，则把整个字符串反转。

以上就是这个题的大致思路，这题没有考察什么算法，但是它的逻辑步骤有些复杂，你就要去模拟它的逻辑，一步一步走不要出错

**反转指定位置的【start，end）字符串数组：**

~~~java
public static void reverseString(char[] s, int start, int end) {
    char temp;
    for (int i = start; i < start + (end - start) / 2; i++) {
        temp = s[i];
        int rightIndex = end - 1 - (i - start);
        s[i] = s[rightIndex];
        s[rightIndex] = temp;
    }
}
~~~

**将字符串数组转换为字符串：**

~~~java
public static String gainString(char[] c) {
    String result = "";
    for (char s : c) {
        result += s;
    }
    return result;
}
~~~

**反转字符串II方法：**

~~~java
public static String reverseStr(String s, int k) {
    char[] charArray = new char[s.length()];
    for (int i = 0; i < s.length(); i++) {
        charArray[i] = s.charAt(i);
    }

    //如果k大于或等于s的长度，则全部反转,并直接返回
    if (k >= s.length()) {
        reverseString(charArray,0,charArray.length);
        return gainString(charArray);
    }

    int start = 0;
    int end = k;
    int residualLength = s.length();
    do {
        //反转这 2k 字符中的前 k 个字符
        reverseString(charArray,start,end);

        //剩余的长度
        residualLength -= 2 * k;

        //如果剩余字符少于 k 个，则将剩余字符全部反转
        if (residualLength < k) {
            reverseString(charArray,s.length() - residualLength,s.length());
            return gainString(charArray);
        }

        //如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。
        if (residualLength < 2 * k && residualLength >= k) {
            reverseString(charArray,s.length() - residualLength,s.length() - residualLength + k);
            return gainString(charArray);
        }

        start += 2 * k;
        end += 2 * k;

    } while (true);
}
~~~

## 栈和队列

### 用栈实现队列

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：

- `void push(int x)` 将元素 x 推到队列的末尾
- `int pop()` 从队列的开头移除并返回元素
- `int peek()` 返回队列开头的元素
- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`

**说明：**

- 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。

我用java语言写的，java里面有一个栈，Stack，里面的push、pop、peek、empty方法都已经写好了。题目要求我用两个栈来模拟队列的实现。我的思路是这样的：

首先定义两个栈，Stack1和Stack2，其中stack1作为主栈，用栈的逻辑来存储队列的数据，当需要pop或则是peek需要返回队尾元素时，这时我们借助stack2辅助栈，先把stack1中的所有元素已后进先出的方式载入到stack2中，然后这是元素的顺序就颠倒了，这正是队列需要的顺序。

~~~java
public class MyQueue {
    private Stack<Object> stack1;
    private Stack<Object> stack2;

    public MyQueue() {
        stack1 = new Stack<>();
        stack2 = new Stack<>();
    }

    public void push(int x) {
        stack1.push(x);
    }

    public int pop() {
        while (!stack1.isEmpty()) {
            stack2.push(stack1.pop());
        }
        Object pop = stack2.pop();

        while (!stack2.isEmpty()) {
            stack1.push(stack2.pop());
        }
        return (int) pop;
    }

    public int peek() {
        while (!stack1.isEmpty()) {
            stack2.push(stack1.pop());
        }
        Object peek = stack2.peek();
        while (!stack2.isEmpty()) {
            stack1.push(stack2.pop());
        }
        return (int) peek;
    }

    public boolean empty() {
        return stack1.isEmpty();
    }
}
~~~









