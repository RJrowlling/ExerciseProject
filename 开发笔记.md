# 后端笔记

## java SE

### 02：Java概述

#### Java 重要特点

1. Java 语言是面向对象的(oop)

2. Java 语言是健壮的。Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证
3. Java 语言是跨平台性的。[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台]

3) Java 语言是解释型的[了解] 。

   解释性语言：javascript,PHP, java 

   编译性语言: c / c++ 

   区别是：解释性语言，编译后的代码，不能直接被机器执行,需要解释器来执行, 编译性语言, 编译后的代码, 可以直接被机器执行, c /c+

#### 什么是 JDK，JRE，JVM

1. JDK 的全称（Java Development Kit） Java 开发工具包。JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独 安装 JRE 了。

   **JDK = JRE + java 的开发工具** [java, javac,javadoc,javap 等]

2. JRE的全称（Java Runtime Environment） Java 运行环境。包括 Java 虚拟机(**JVM** Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序， 计算机中只需要安装 JRE 即可。

   **JRE = JVM +Java 的核心类库**

####  Java 开发注意事项和细节说明

![image-20240224162718902](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240224162718902.png)

####  Java 转义字符

![image-20240224162905093](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240224162905093.png)

#### 注释(comment)

用于注解说明解释程序的文字就是注释，注释提高了代码的阅读性（可读性）；注释是一个程序员必须要具有的良 好编程习惯。将自己的思想通过注释先整理出来，再用代码去体现。

```java
//单行注释

/*
多行注释

多行注释
*/

/**
	*文档注释
	*author 陈俊宇
	*version 1.0
	*	
	*见下图
*/
```

![image-20240224163254806](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240224163254806.png)

####  Java 代码规范

![image-20240224163415535](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240224163415535.png)

#### Java编写步骤

1. 编写java的源代码

2. javac编译，得到对应的.class字节码文件

3. java运行，本质就是把.class加载到JVM运行

#### 本章作业

![image-20240224163527124](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240224163527124.png)

### 03：变量

#### 概念

变量相当于内存中一个数据存储空间的表示，你可以把变量看做是一个房间的门牌号，通过门牌号我们可以找到房间，而通过变量名可以访问到变量(值)

**变量 = 变量名 + 值 + 数据类型**

#### 程序中 +号的使用

1. 当左右两边都是数值型时，则做加法运算

2. 当左右两边有一方为字符串,则做拼接运算

![image-20240225113717741](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225113717741.png)

#### 数据类型

每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间(字节)。

![image-20240225145443035](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225145443035.png)

 基本数据类型有 8 中 数值型 byte , short , int , long , float ,double，char , boolean；引用类型有三种：类，接口， 数组。

##### 整型

Java 的整数类型就是用于存放整数值的，比如 12 , 30, 3456 等等。

![image-20240225145649044](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225145649044.png) 

![image-20240225145807635](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225145807635.png) 

**注意：byte a = 10;**

**看似是将默认的int类型转换成了更小的byte类型应该会报错，但是表达式是正确的。因为这里程序所做的事是：判断10这个值是否在-128~127之间，根据这个来看是否符合要求，注意：这里的10一定是一个具体的值，而不能是变量，或者是大于这个范围的值。short类型同样适用。**

##### 浮点型

Java 的浮点类型可以表示一个小数，比如 123.4 ，7.8 ，0.12 等等。

![image-20240225145919616](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225145919616.png) 

![image-20240225150023292](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150023292.png) 

##### 字符型

字符类型可以表示单个字符,字符类型是 char，char 是两个字节(可以存放汉字)，多个字符我们用字符串 String。

![image-20240225150238229](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150238229.png) 

![image-20240225150345863](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150345863.png) 

##### 布尔型

![image-20240225150439440](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150439440.png) 

#### 基本数据类型转换

##### 自动类型转换

![image-20240225150544626](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150544626.png) 

![image-20240225150650565](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150650565.png) 

##### 强制类型转换

自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符 ( )，但可能造成
精度降低或溢出,格外要注意。

![image-20240225150803240](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150803240.png) 

![image-20240225150850098](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150850098.png) 

#### 基本数据类型和 String 类型的转换

![image-20240225151001328](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225151001328.png) 

1. 在将 String 类型转成 基本数据类型时， 要确保String类型能够转成有效的数据，比如 我们可以把 "123" , 转成一个整数，但是不能把 "hello" 转成一个整数

2. 如果格式不正确，就会抛出异常，程序就会终止，

#### 本章作业

![image-20240225151148714](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225151148714.png)

### 04：运算符

运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等

#### 算术运算符

算术运算符是对数值类型的变量进行运算的，在 Java 程序中使用的非常多

![image-20240227145701670](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227145701670.png)

![image-20240227145728090](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227145728090.png)

![image-20240227145749356](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227145749356.png)

#### 比较运算符

关系运算符的结果都是 boolean 型，也就是要么是 true，要么是 false

![image-20240227145853553](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227145853553.png)

关系运算符组成的表达式，我们称为**关系表达式**。 a > b

#### 逻辑运算符

用于连接多个条件（多个关系表达式），最终的结果也是一个 boolean 

![image-20240227150124179](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227150124179.png)

1. **a&b** : & 叫**逻辑与**：规则：当 a 和 b 同时为 true ,则结果为 true, 否则为 false 

2. **a&&b** : && 叫**短路与**：规则：当 a 和 b 同时为 true ,则结果为 true,否则为 false 

3. **a|b** : | 叫**逻辑或**，规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false 

4. **a||b** : || 叫**短路或**，规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false

5. **!a** : 叫**取反**。当 a 为 true, 则结果为 false, 当 a 为 false 是，结果为 true 

6. **a^b**: 叫**逻辑异或**，当 a 和 b 不同时，则结果为 true, 否则为 false

**&& 和 & 使用区别（||和|同）:**

1. &&短路与：**如果第一个条件为 false，则第二个条件不会判断**，最终结果为 false，效率高 
2. & 逻辑与：**不管第一个条件是否为 false，第二个条件都要判断**，效率低

#### 赋值运算符

赋值运算符就是将某个运算后的值，赋给指定的变量。

赋值运算符分为两类：

1. 基本赋值运算符 **=** ：int a = 10
2.  复合赋值运算符**+= ，-= ，*= ， /= ，%=** ：
   a += b  ====》  等价 a = a + b; 

#### 三元运算符

条件表达式    ?     表达式 1    :     表达式2

运算规则： 

1. 如果条件表达式为 true，运算后的结果是表达式 1； 
2. 如果条件表达式为 false，运算后的结果是表达式 2

细节：

表达式 1 和表达式 2 要为可以赋给接收变量的类型(或可以自动转换)

#### 标识符的命名规则和规范

规则：

![image-20240227151129934](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227151129934.png)

规范：

1. 包名：多单词组成时所有字母都小写：aaa.bbb.ccc //比如 com.hsp.crm 
2. 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰] 比如： TankShotGame 
3. 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz [小 驼峰， 简称 驼峰法] 比如： tankShotGame 
4. 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ 比如 ：定义一个所得税率 TAX_RATE 

#### 键盘输入语句

在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。Input.java , 需要一个 扫描器(对象), 就是 Scanner

步骤：

1.  引入/导入 Scanner 类所在的包
   **import java.util.Scanner;**
2. 创建 Scanner 对象 , new 创建一个对象
   **Scanner myScanner = new Scanner(System.in)；**
3. 调用里面的功能
   **String name = myScanner.next(); //接收用户输入字符串**
   int age = myScanner.nextInt(); //接收用户输入 int
   double sal = myScanner.nextDouble(); //接收用户输入 doubl

```java
import java.util.Scanner;
public class Input {
    Scanner myScanner = new Scanner(System.in);
    String name = myScanner.next();
}
```



#### 原码、反码、补码

**进制:**

二进制：0,1 ，满 2 进 1.以 0b 或 0B 开头。 

十进制：0-9 ，满 10 进 1。 

八进制：0-7 ，满 8 进 1. 以数字 0 开头表示。 

十六进制：0-9 及 A(10)-F(15)，满 16 进 1. 以 0x 或 0X

**原码、反码、补码：**

![image-20240227152037830](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227152037830.png)

为什么计算机的计算都是采用补码的方式？

因为可以统一正数和负数的运算

#### 位运算符

java 中有 **7 个**位运算(**&、|、 ^ 、~、>>、<<和 >>>**)

![image-20240227152230556](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227152230556.png)

1. 算术右移 >>：低位溢出,符号位不变,并用符号位补溢出的高位 
2. 算术左移 <<: 符号位不变,低位补 0 
3. **>>>**逻辑右移也叫无符号右移,运算规则是: 低位溢出，高位补 0 
4. 特别说明：没有 <<< 符号

本章作业：

![image-20240227152554047](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227152554047.png)

![image-20240227152604098](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227152604098.png)

### 05：程序控制结构

在程序中，程序运行的流程控制决定程序是如何执行的，是我们必须掌握的，主要有三大流程控制语句：

1. 顺序控制
2. 分支控制 
3. 循环控制

####  顺序控制

![image-20240227184158551](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227184158551.png)

#### 分支控制 

让程序有选择的的执行,分支控制有三种 

1. 单分支 if 
2. 双分支 if-else 
3. 多分支 if-else if -....-else

##### 单分支

![image-20240227184323395](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227184323395.png)

![image-20240227190203640](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227190203640.png) 

##### 双分支

![image-20240227190255856](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227190255856.png)

![image-20240227190411393](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227190411393.png) 

##### 多分支

![image-20240227191732315](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227191732315.png) 

![image-20240227191751330](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227191751330.png) 

##### 嵌套分支

在一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支的结构称为内层分支外面的分支结构称为外 层分支。

老师建议: 不要超过 3层（可读性不好）

##### switch 分支结构

![image-20240227193344488](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227193344488.png)

![image-20240227193358043](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227193358043.png)

![image-20240227193956153](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227193956153.png)

##### switch 和 if 的比较

1. 如果判断的具体数值不多，而且符合 byte、 short 、int、 char, enum[枚举], String 这 6 种类型。虽然两个语句都可 以使用，建议使用 swtich 语句。 
2. 其他情况：对区间判断，对结果为 boolean 类型判断，使用 if，if 的使用范围更广

#### 循环控制

##### for 循环

![image-20240227194619183](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227194619183.png)

![image-20240227194634788](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227194634788.png)

1.  循环条件是返回一个布尔值的表达式 
2. for(;循环判断条件;) 中的初始化和变量迭代可以写到其它地方，但是两边的分号不能省略。 
3. 循环初始值**可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开**，循环变量迭代也可以有多条变量迭代 语句，中间用逗号隔开。

##### while 循环

![image-20240227195208401](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227195208401.png) 

![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227195217459.png) 

1. 循环条件是返回一个布尔值的表达式 
2. while 循环是先判断再执行语句

#####  do..while 循环

![image-20240227195605308](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227195605308.png) 

![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227195722863.png) 

1. 先执行，再判断，也就是说，一定会至少执行一次 
2. **最后 有一个 分号 ;** 

##### 多重循环

1. 将一个循环放在另一个循环体内，就形成了嵌套循环。其中，for ,while ,do…while 均可以作为外层循环和内层循环。 【**建议一般使用两层，最多不要超过 3 层**, 否则，代码的可读性很差】 
2. 实质上，**嵌套循环就是把内层循环当成外层循环的循环体**。当只有内层循环的循环条件为 false 时，才会完全跳出内 层循环，才可结束外层的当次循环，开始下一次的循环

3. 设外层循环次数为 m 次，内层为 n 次，则内层循环体实际上需要执行 m*n 次。

![image-20240227200302757](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227200302757.png) 

#### 跳转控制

##### break

break 语句用于终止某个语句块的执行，一般使用在 switch 或者循环[for , while , do-while]中

![image-20240227202403904](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227202403904.png) 

![image-20240227202419529](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227202419529.png)

##### continue

1. continue 语句用于结束本次循环，继续执行下一次循环。 
2. continue 语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环 , 这个和前面的标签的 使用的规则一样

![image-20240227202548239](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227202548239.png) 

##### return

return 使用在方法，表示跳出所在的方法。如果 return 写在 main 方法中，则退出程序。

![image-20240227202706376](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227202706376.png) 

#### 本章作业

![image-20240227202734212](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227202734212.png)

![image-20240227202741313](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227202741313.png) 

### 06：数组、排序和查找

数组可以存放多个同一类型的数据。数组也是一种数据类型，是引用类型。

**数(数据)组(一组)就是一组数据**

#### 数组的使用

```java
//**使用方式一：动态初始化**
int a[] = new int[3];

//**使用方式二：动态初始化**
//先申明数组、再创建数组
int a[];
a = new int[3];

//**使用方式三：静态初始化**
int a[] = {2,3,4};
```

![image-20240228162344823](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228162344823.png) 

#### 数组的细节

1. 数组是多个**相同类型数据的组合**，实现对这些数据的统一管理

2) 数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用。
3) 数组创建后，**如果没有赋值，有默认值**
   int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \u0000，boolean false，String null

4) 使用数组的步骤 
   1) 声明数组并开辟空间 
   2) 给数组各个元素赋值 
   3) 使用数组
5) 数组的**下标是从** **0** **开始的**
6) 数组下标必须在指定范围内使用，否则报错：下标越界异常
7) 数组属**引用类型**，数组型数据是对象(object)

#### 数组赋值机制

1. 基本数据类型赋值，这个值就是具体的数据，而且相互不影响。int n1 = 2; int n2 = n1;

2) 数组在**默认情况下是引用传递，赋的值是地址**。

![image-20240228162932571](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228162932571.png) 

#### 排序

排序是将多个数据，依指定的顺序进行排列的过程。

排序分为：内部排序和外部排序

1. 内部排序：指将需要处理的所有数据都加载到内部存储器中进行排序。包括(交换式排序法、选择式排序法和插入式排序法)
2. 外部排序：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括(合并排序法和直接合并排序法)

#### 冒泡排序法

冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从后向前（从下标较大的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。

**思路：**

![image-20240228163400974](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228163400974.png) 

#### 二维数组

```java
//**使用方式1：动态初始化**
int a[3][3] = new int[3][3];

//**使用方式2：动态初始化**
//先声明、再开辟空间
int a[][];
a = new int[3][3]
    
//**使用方式 3: 动态初始化-列数不确定**
/**
0
00
000
*/
int a[][] = new a[10][];//先开辟行数的空间
for(int i = 0; i < a.length; i++) {
    a[i] = new int[i+1]; //再动态开辟列数的空间
}

int a[][];
a

//**使用方式 4: 静态初始化**
int a[][] = {{1,2,3},{4,5,6},{7,8,9}};
```

**储存细节：**

![image-20240228163846781](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228163846781.png) 

#### 二维数组细节

1) 一维数组的声明方式有:
   int[] x 或者 int x[]

2) 二维数组的声明方式有:
   ![image-20240228164437857](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228164437857.png)

3. 二维数组实际上是由多个一维数组组成的，它的各个一维数组的长度可以相同，也可以不相同。
4. 还是要注意数据类型的自动转换

![image-20240228164546217](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228164546217.png) 

#### 本章作业

![image-20240228164725724](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228164725724.png) 

![image-20240228164742609](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228164742609.png) 

### 07：面向对象编程

#### 类与对象

```java
Cat cat1 = new Cat();

class Cat {
	String name; 
	int age; 
	String color; 
}
```

##### 类和对象的区别和联系

1. 类是抽象的，概念的，代表一类事物,比如人类,猫类.., 即它是数据类型
2. 对象是具体的，实际的，代表一个具体事物, 即 是实例
3. 类是对象的模板，对象是类的一个个体，对应一个实例

##### 对象在内存中存在形式

![image-20240229150533210](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229150533210.png)

##### 属性/成员变量

从概念或叫法上看： 成员变量 = 属性 = field(字段)

属性是类的一个组成部分，一般是基本数据类型,也可是引用类型(对象，数组)。

**属性细节：**

1. 属性的定义语法同变量，
   示例：访问修饰符 属性类型 属性名(**public int name**); 
2. 访问修饰符： 控制属性的访问范围 有四种访问修饰符 public, proctected, 默认, private 
3. 属性的定义类型可以为任意类型，包含基本类型或引用类型 
4. 属性如果不赋值，有默认值，规则和数组一致。
   具体说: int 0，short 0, byte 0, long 0, float 0.0,
   double 0.0，char \u0000， boolean false，String null

##### 创建对象

```java
//1. 先声明再创建
Cat cat; //声明对象 cat
cat = new Cat(); //创建

//1. 直接创建
Cat cat = new Cat();
```

##### 访问属性

```java
cat.name;
cat.age;
cat.color;
```

##### 类和对象的内存分配机制

**Java 内存的结构分析:** 

1. 栈： 一般存放基本数据类型(局部变量) 
2. 堆： 存放对象(Cat cat , 数组等) 
3. 方法区：常量池(常量，比如字符串)， 类加载信息

```java
//简单流程分析
Person p = new Person();
p.name = “jack”;
p.age = 1

/**
1) 先加载 Person 类信息(属性和方法信息, 只会加载一次)
2) 在堆中分配空间, 进行默认初始化(看规则)
3) 把地址赋给 p , p 就指向对象
4) 进行指定初始化，比如 p.name =”jack” p.age = 10  
*/

```

![image-20240229152024847](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229152024847.png)

#### 成员方法

在某些情况下，我们要需要定义成员方法(简称方法)。比如人类:除了有一些属性外( 年龄，姓名..),我们人类还有一 些行为比如:可以说话、跑步..,通过学习。这时就要用成员方法才能完成。

##### 基本使用

```java
//1. 方法写好后，如果不去调用(使用)，不会输出
//2. 先创建对象 ,然后调用方法即可
Person p1 = new Person();
p1.speak(); //调用方法

class Person {
	String name;
	int age;
    
    public void speak() {
        System.out.println("我是一个好人");
    }
    
    public int getSum(int num1, int num2) {
        int res = num1 + num2;
        return res;
    }
}
```

##### 方法的调用机制原理

![image-20240229152600039](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229152600039.png)

##### 成员方法的定义

![image-20240229152732957](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229152732957.png) 

1. **访问修饰符**： (作用是控制 方法使用的范围) 如果不写默认访问，[有四种: public, protected, 默认, private]

2.  **返回数据类型**：

   1. 一个方法最多有一个返回值 [如果返回多个结果 **返回数组** ]
   2. 返回类型可以为任意类型，包含基本类型或引用类型(数组，对象)
   3.  如果方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值; 而且要求返回值类型必须和 return 的 值类型一致或兼容
   4. 如果方法是 void，则方法体中可以没有 return 语句，或者 只写 **return ;**

3. **方法名**：遵循驼峰命名法，最好见名知义，表达出该功能的意思即可

4. **参数列表**：

   ![image-20240229153308376](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229153308376.png) 

##### 方法调用细节

![image-20240229153450642](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229153450642.png)

#### 成员方法传参机制

**基本数据类型的传参机制**

![image-20240229153624402](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229153624402.png) 

**引用数据类型的传参机制**

引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参

#### 方法递归调用

递归就是方法**自己调用自己**,每次调用时传入不同的变量.递归有助于编程者解决复杂问题,同时可以让代码变 得简洁

**递归重要规则**

![image-20240229153906120](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229153906120.png)

![image-20240229154053516](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229154053516.png)

#### 方法重载

java 中允许同一个类中，多个同名方法的存在，但要求 形参列表不一致！

**好处：**

1) 减轻了起名的麻烦 
2) 减轻了记名的麻烦

```java
class MyCalculator {
    //一个整数，一个 double 的和
    public double calculate(int n1, double n2) {
    	return n1 + n2;
    }
    //一个 double ,一个 Int 和
    public double calculate(double n1, int n2) {
        System.out.println("calculate(double n1, int n2) 被调用..");
        return n1 + n2;
    }
}
```

**细节:**

![image-20240301084526792](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301084526792.png) 

![image-20240301084546628](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301084546628.png) 

####  可变参数

java 允许将**同一个类中多个同名同功能但参数个数不同**的方法，封装成一个方法。 就可以通过可变参数实现。

**基本语法：**

![image-20240301084725289](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301084725289.png) 

```java
public int sum(int... nums) {
    //System.out.println("接收的参数个数=" + nums.length);
    int res = 0;
    for(int i = 0; i < nums.length; i++) {
    	res += nums[i];
    }
    return res;
}
```

**细节：**

![image-20240301084907686](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301084907686.png) 

```java
//细节: 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后
public void f2(String str, double... nums) {
}

//细节: 一个形参列表中只能出现一个可变参数
//下面的写法是错的. 
public void f3(int... nums1, double... nums2) {
}
```

#### 作用域

![image-20240301085201052](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301085201052.png) 

**注意事项和细节使用:**

![image-20240301085248768](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301085248768.png) 

#### 构造方法

构造方法又叫构造器(constructor)，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。它有几个特点：

1) 方法名和类名相同 
2) 没有返回值 
3) 在创建对象时，系统会自动的调用该类的构造器完成对象的初始化。

**基本语法：**

![image-20240301085351515](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301085351515.png) 

1) 构造器的修饰符可以默认， 也可以是 public protected private 
2) 构造器没有返回值 
3) 方法名 和类名字必须一样 
4) 参数列表 和 成员方法一样的规则 
5) 构造器的调用, 由系统完成

**注意事项和使用细节：**

![image-20240301085756408](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301085756408.png) 

```java
public class ConstructorDetail {
	//编写一个 main 方法
    public static void main(String[] args) {
        Person p1 = new Person("king", 40);//第 1 个构造器
        Person p2 = new Person("tom");//第 2 个构造器
        Dog dog1 = new Dog();//使用的是默认的无参构造器
    }
}

class Dog {
    //如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器(也叫默认构造器)
}

class Person {
    String name;
    int age; //默认0
    
    //第 1 个构造器
	public Person(String pName, int pAge) {
        name = pName;
        age = pAge;
	}
    
   //第 2 个构造器, 只指定人名，不需要指定年龄
    public Person(String pName) {
    	name = pName;
    }
}
    
```

#### 对象创建的流程分析

![image-20240301090245190](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301090245190.png) 

####  this 关键字

简单的说，那个对象调用，this就代表那个对象。

1. this 关键字可以用来访问本类的属性、方法、构造器 
2. this 用于区分当前类的属性和局部变量 
3. **访问成员方法的语法：this.方法名(参数列表)**
4. **访问构造器语法：this(参数列表)**; 注意:只能在构造器中使用(即**只能在构造器中**访问另外一个构造器, **必须放在第一 条语句**)
5. this 不能在类定义的外部使用，只能在类定义的方法中使用

#### 本章作业

![image-20240301090818873](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301090818873.png) 

![image-20240301090832365](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301090832365.png) 

![image-20240301090848648](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301090848648.png) 

![image-20240301090904456](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301090904456.png) 

![image-20240301090915425](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301090915425.png) 

### 08：面向对象编程(中级)

#### 包

**作用：**

![image-20240302082554681](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302082554681.png) 

**语法：**

![image-20240302082641790](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302082641790.png) 

**本质：**

![image-20240302082724253](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302082724253.png) 

**命名：**

![image-20240302082824346](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302082824346.png) 

**细节：**

![image-20240302083016432](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302083016432.png) 

![image-20240302082932774](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302082932774.png) 

#### 访问修饰符

java 提供四种访问控制修饰符号，用于控制方法和属性(成员变量)的访问权限（范围）：

1) 公开级别:用 **public** 修饰,对外公开 
2) 受保护级别:用 **protected** 修饰,对子类和同一个包中的类公开 
3) 默认级别:**没有修饰符号**,向同一个包的类公开
4) 私有级别:用 **private** 修饰,只有类本身可以访问,不对外公开

![image-20240302094024820](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302094024820.png) 

**注意事项：**

![image-20240302083342543](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302083342543.png) 

#### 封装

![image-20240302103331943](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302103331943.png) 

**好处：**

![image-20240302103402079](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302103402079.png) 

**实现步骤：**

![image-20240302103503236](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302103503236.png) 

**将构造器和 setXxx 结合：**

![image-20240302103609067](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302103609067.png) 

#### 继承

继承可以解决代码复用,让我们的编程更加靠近人类思维.**当多个类存在相同的属性(变量)和方法时,可以从这些类中 抽象出父类**,在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 **extends 来 声明**继承父类即可。

![image-20240302103743228](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302103743228.png) 

**继承的基本语法：**

![image-20240302103821353](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302103821353.png) 

**好处：**

1) 代码的复用性提高了 
2) 代码的扩展性和维护性提高了

**继承细节：**

1. 子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访 问，要通过父类提供公共的方法去访问
2. 子类**必须调用父类的构造器**， 完成父类的初始化
3. 当创建子类对象时，不管使用子类的哪个构造器，**默认情况下总会去调用父类的无参构造器**，如果**父类没有提供无参构造器，则必须在子类的构造器中用 super 去指定**使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过
4. 如果希望指定去调用父类的某个构造器，则显式的调用一下 : **super(参数列表）**
5. super 在使用时，**必须放在构造器第一行(super 只能在构造器中使用)**
6. super() 和 this() 都只能放在构造器第一行，因此这**两个方法不能共存在一个构造器**
7. java 所有类都是 Object 类的子类, Object 是所有类的基类
8. 父类构造器的调用不限于直接父类，将一直往上追溯直到 Object 类(顶级父类）
9. 子类最多只能继承一个父类(指直接继承)，即 **java 中是单继承机制**
10. 不能滥用继承，**子类和父类之间必须满足 is-a 的逻辑关系**

**继承的本质分析：**

![image-20240302104358566](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302104358566.png) 

**查找关系：**

1. 首先看子类是否有该属性
2. 如果子类有这个属性，并且可以访问，则返回信息
3. 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..)
4. 如果父类没有就按照(3)的规则，继续找上级父类，直到 Object..

**内存布局：**

![image-20240302104638634](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302104638634.png) 

#### super关键字

super 代表父类的引用，用于访问**父类的属性、方法、构造器**

**语法：**

![image-20240302113723098](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302113723098.png) 

```java
System.out.println(n1);
System.out.println(this.n1);
//n1 和 this.n1 查找的规则是
//(1) 先找本类，如果有，则调用
//(2) 如果没有，则找父类(如果有，并可以调用，则调用)
//(3) 如果父类没有，则继续找父类的父类,整个规则，就是一样的,直到 Object 类
// 提示：如果查找属性的过程中，找到了，但是不能访问， 则报错, cannot access
// 如果查找属性的过程中，没有找到，则提示属性不存在
    
System.out.println(super.n1);
//找 n1 (super.n1) 的顺序是直接查找父类属性，其他的规则一样
```

**细节：**

![image-20240302114122709](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302114122709.png) 

#### super 和 this 的比较

![image-20240302114230453](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302114230453.png) 

#### 方法重写

![image-20240302114331887](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302114331887.png) 

**细节：**

![image-20240302114413515](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302114413515.png) 

**方法重写与方法重载区别：**

![image-20240302134050595](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302134050595.png) 

#### 多态

方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。

##### 多态的具体体现

1. 方法的多态：重写和重载体现多态
2. 对象的多态：

 ![image-20240302161158753](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302161158753.png)

##### 多态注意事项和细节

1. 多态的前提是：两个对象(类)存在继承关系

2. 多态的**向上转型**
   ![image-20240302161318650](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302161318650.png)

   为什么不能调用子类的特有成员？因为在编译阶段，能调用哪些成员,是由编译类型来决定的。

   最终运行效果看子类(运行类型)的具体实现, 即调用方法时，按照从子类(运行类型)开始查找方法，然后调用规则我前面我们讲的方法调用规则一致

3. 多态**向下转型**
   ![image-20240302161406048](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302161406048.png)

4. **instanceOf 比较操作符**，用于判断对象的**运行类型**是否为 XX 类型或 XX 类型的子类型

![image-20240302161851944](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302161851944.png) 

##### java 的动态绑定机制

![image-20240302162152620](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302162152620.png) 

##### 多态的应用

1. 多态数组：数组的定义类型为父类类型，里面保存的实际元素类型为子类类型
   应用实例:现有一个继承结构如下，要求创建 1 个 Person 对象、2 个 Student 对象和 2 个 Teacher 对象, 统一放在数组 中，并调用每个对象 say 方法

   ```java
   Person[] persons = new Person[5];
   
   persons[0] = new Person("jack", 20);
   persons[1] = new Student("mary", 18, 100);
   persons[2] = new Student("smith", 19, 30.1);
   persons[3] = new Teacher("scott", 30, 20000);
   persons[4] = new Teacher("king", 50, 25000);
   ```

2. 多态参数
   ![image-20240302162658189](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302162658189.png)

#### Object 类详解

##### equals 方法

==和 equals 的对比：

![image-20240302190357187](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302190357187.png) 

![image-20240303155917455](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303155917455.png)

##### hashCode 方法

![image-20240302190736043](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302190736043.png) 

1. 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的
2. 两个引用，如果指向的是不同对象，则哈希值是不一样的 
3. 哈希值主要根据地址号来的，不能完全将哈希值等价于地址

##### toString 方法

1. 基本介绍：

   默认返回：全类名+@+哈希值的十六进制，【查看 Object 的 toString 方法】

   子类往往重写 toString 方法，用于返回对象的属性信息

2. 重写 toString 方法，打印对象或拼接对象时，都会自动调用该对象的 toString 形式

3. **当直接输出一个对象时，toString 方法会被默认的调用**, 比如 System.out.println(monster)； 就会默认调用 monster.toString()

##### finalize 方法

1. 当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作
2. 什么时候被回收：当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来 销毁该对象，在销毁该对象前，会先调用 finalize 方法。 
3. 垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法), 也可以通过 **System.gc()** 主动触发垃圾回收机制
4.  **我们在实际开发中，几乎不会运用 finalize , 所以更多就是为了应付面试.**

#### 本章作业：

![image-20240303111746815](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303111746815.png) 

![image-20240303111800007](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303111800007.png) 

![image-20240303151844489](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303151844489.png) 

![image-20240303111843504](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303111843504.png) 

![image-20240303111906766](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303111906766.png) 

### 10：面向对象编程(高级)

#### 类变量和类方法

##### 类变量

![image-20240305155410347](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305155410347.png) 

**定义：**

![image-20240305155451552](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305155451552.png) 

**访问类变量:**

![image-20240305155627145](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305155627145.png) 

```java
class AA {
    public static void num;
}

AA.num;
//或者
new AA().num;
```

**细节：**

![image-20240305155841863](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305155841863.png) 

##### 类方法

![image-20240305160024564](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305160024564.png) 

![image-20240305160055714](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305160055714.png) 

如果我们希望不创建实例，也可以调用某个方法(即当做工具来使用），这时，把方法做成静态方法时非常合适。

**类方法经典的使用场景：**

![image-20240305160248348](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305160248348.png) 

**细节：**

![image-20240305160332732](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305160332732.png) 

#### main方法

**理解 main 方法：**

![image-20240305160726592](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305160726592.png) 

**特别提示：**

1) 在 main()方法中，我们可以直接调用 main 方法所在类的静态方法或静态属性。 
2) 但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员

**在idea中传递参数：**

![image-20240305160928734](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305160928734.png) 

#### 代码块

##### 基本介绍

![image-20240305161018264](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305161018264.png) 

##### 基本语法

![image-20240305161102528](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305161102528.png) 

##### 代码块的好处

 ![image-20240305161233498](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305161233498.png) 

##### 代码块的细节讨论

![image-20240305161346185](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305161346185.png) 

![image-20240305161525158](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305161525158.png) 

![image-20240305161643324](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305161643324.png) 

![image-20240305161710575](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305161710575.png) 

#### 单例模式

**什么是设计模式：**

![image-20240305200508550](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305200508550.png) 

**什么是单例模式：**

![image-20240305200419112](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305200419112.png) 

##### **饿汉式：**

```java
//步骤[单例模式-饿汉式]
//1. 将构造器私有化
//2. 在类的内部直接创建对象(该对象是 static)
//3. 提供一个公共的 static 方法，返回 gf 对象
class GirlFriend {
	private String name;
    //2. 在类的内部直接创建对象(该对象是 static)
    private static GirlFriend gf = new GirlFriend("小红红");
    //1. 将构造器私有化
    private GirlFriend(String name) {
		System.out.println("構造器被調用.");
		this.name = name;
	}
    //3. 提供一个公共的 static 方法，返回 gf 对象
    public static GirlFriend getInstance() {
		return gf;
    }
}
```

##### **懒汉式：**

```java
//步骤[单例模式-懒式]
//1. 将构造器私有化
//2. 在类的内部定义一个对象(该对象是 static)
//3. 提供一个公共的 static 方法，返回 Cat 对象
//4. 只有当用户调用getInstance这个公用方法时，才会真正创建Cat对象
class Cat {
    private String name;
    public static int n1 = 999;
    //2. 在类的内部定义一个对象(该对象是 static)
    private static Cat cat ; //默认是 null
    //1. 将构造器私有化
    private Cat(String name) {
        this.name = name;
    }
    //3. 提供一个公共的 static 方法，返回 Cat 对象
    public static Cat getInstance() {
        if(cat == null) {//如果还没有创建cat对象，就创建一个
        	cat = new Cat("小可愛");
        }
        return cat;
   	}
}
```

##### 饿汉式 VS 懒汉式

![image-20240305201445529](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305201445529.png) 

#### final关键字

**基本介绍：**

![image-20240305205312151](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305205312151.png) 

**细节：**

![image-20240305205404737](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305205404737.png) 

![image-20240305205506115](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305205506115.png) 

#### 抽象类

**理解：**

![image-20240306085546788](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306085546788.png) 

父类方法不确定性的问题 ===> 考虑将该方法设计为抽象(abstract)方法 ===> 所谓抽象方法就是没有实现的方法 ===> 所谓没有实现就是指，没有方法体 ===> 当一个类中存在抽象方法时，需要将该类声明为 abstract 类 ==> 一般来说，抽象类会被继承，有其子类来实现抽象方法

**介绍：**

![image-20240306085841810](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306085841810.png) 

**细节：**

![image-20240306085933576](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306085933576.png) 

![image-20240306090007586](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306090007586.png) 

![image-20240306090038794](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306090038794.png) 

不能用static是因为static声明的静态成员可以直接被类调用，而抽象类就只有被继承的能力。

#### 模板设计模式

**基本介绍：**

![image-20240306093306421](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306093306421.png) 

**模板设计模式能解决的问题：**

![image-20240306093354767](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306093354767.png) 

```java
abstract public class Template { //抽象类-模板设计模式
    public abstract void job();//抽象方法
    
    public void calculateTime() {//实现方法，调用 job 方法
        //得到开始的时间
        long start = System.currentTimeMillis();
        job(); //动态绑定机制
        //得的结束的时间
        long end = System.currentTimeMillis();
        System.out.println("任务执行时间 " + (end - start));
  	}
}
 
class AA extends Template {
    @Override
    public void job() { //实现 Template 的抽象方法 job
        long num = 0;
        for (long i = 1; i <= 800000; i++) {
        	num += i;
        }
    }
}

class BB extends Template {
    @Override
    public void job() { //实现 Template 的抽象方法 job
        long num = 0;
        for (long i = 1; i <= 600000; i++) {
        	num += i;
        }
    }
}      
```

#### 接口

##### 为什么有接口

![image-20240306105841413](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306105841413.png) 

##### 基本介绍

![image-20240306105933451](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306105933451.png) 

##### 注意事项和细节

![image-20240306110040799](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306110040799.png) 

![image-20240306110118438](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306110118438.png) 

##### 实现接口 vs 继承

![image-20240306110244415](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306110244415.png) 

小结: 

1. 当子类继承了父类，就自动的拥有父类的功能

2. 如果子类需要扩展功能，可以通过实现接口的方式扩展.（可以理解 实现接口 是 对 java 单继承机制的一种补充）

```java
//猴子
class Monkey {
    public String name;
    public Monkey(String name) {
    	this.name = name;
    }
    public void climbing() {
    System.out.println(name + " 会爬树...");
    }
}
//鱼
interface Fishable {
	void swimming();
}
//鸟
interface Birdable {
	void flying();
} 

//小猴子继承了猴子的爬树，小猴子实现了与鱼的游泳和鸟的飞翔
class LittleMonkey extends Monkey implements Fishable,Birdable {
    public LittleMonkey(String name) {
		super(name);
	}
    @Override
    public void swimming() {
    	System.out.println(getName() + " 通过学习，可以像鱼儿一样游泳...");
    }
    @Override
    public void flying() {
    	System.out.println(getName() + " 通过学习，可以像鸟儿一样飞翔...");
    }
}
```

![image-20240306110811731](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306110811731.png) 

##### 接口的多态特性

![image-20240306110901095](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306110901095.png) 

##### 接口练习

```java
interface A {
	int x = 0;
}
class B {
	int x = 1;
}
class C extends B implements A {
    public void pX() {
		System.out.println(x); //错误，x是A的还是B的，模糊
        // 改
        System.out.println(A.x + " " + super.x);
        //可以明确的指定 x
        //访问接口的 x 就使用 A.x
        //访问父类的 x 就使用 super.x
    }
}
```

#### 内部类

1. 如果**定义在局部位置**(方法中/代码块) :
   1. 局部内部类（有类名）
   2. 匿名内部类（**没有类名，重点！！！**）

2. 定义在成员位置
   1. 成员内部类
   2. 静态内部类（有static修饰）

##### 基本介绍

![image-20240306143853579](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306143853579.png) 

##### 基本语法

![image-20240306143954630](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306143954630.png) 

##### 局部内部类

![image-20240306144054269](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306144054269.png) 

```java
class Outer02 {//外部类
    private int n1 = 100;
    private void m2() {
    	System.out.println("Outer02 m2()");
	}//私有方法
    public void m1() {//方法
        ////2.不能添加访问修饰符,但是可以使用 final 修饰
        final class Inner02 {//局部内部类(本质仍然是一个类)
            private int n1 = 800;
            public void f1() {
                //7.如果外部类和局部内部类的成员重名时,使用 外部类名.this.成员去访问
                System.out.println("n1=" + n1 + " 外部类的 n1=" + Outer02.this.n1);
                //4.局部内部类可以直接访问外部类的成员
                m2();
            }
            //5.外部类在方法中，可以创建 Inner02 对象，然后调用方法即可
            Inner02 inner02 = new Inner02;
            inner02.f1();
        }
    }
}     
```

##### 匿名内部类

![image-20240306145355085](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306145355085.png) 

![image-20240306145446514](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306145446514.png) 

```java
//需求是Tiger类只是使用一次，后面再不使用,可以使用匿名内部类来简化开发

class Outer04 { //外部类
	private int n1 = 10;//属性
    public void method() {//方法
        //基于接口的匿名内部类
        IA tiger = new IA() {
        //tiger 的编译类型 是 IA，
        //tiger 的运行类型是匿名内部类 Outer04$1(系统自动生成的)
            @Override
            public void cry() {
            	System.out.println("老虎叫唤...");
            }
        }
        //jdk 底层在创建匿名内部类 Outer04$1,然后立即马上就创建了 Outer04$1,并把地址返回给tiger
      	//**********************************************
        //类似于
        class Outer04$1 implements IA {
            @Override
            public void cry() {
            	System.out.println("老虎叫唤...");
            }
     	}
        //**********************************************
        System.out.println("tiger 的运行类型=" + tiger.getClass())
    	tiger.cry();
    }
}
   
interface IA {//接口
	public void cry();
} 
```

**最佳实践：当做实参直接传递，简洁高效。**

```java
public class InnerClassExercise01 {
	public static void main(String[] args) {
        //当做实参直接传递，简洁高效
        f1(new IL() {
        	@Override
        	public void show() {
       			System.out.println("这是一副名画~~...");
        	}
		});
    }
}
//接口
interface IL {
	void show();
}
```

##### 成员内部类

![image-20240306151747626](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306151747626.png) 

![image-20240306151802370](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306151802370.png) 

![image-20240306151831810](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306151831810.png) 

**外部其他类 使用成员内部类：**

```java
class Outer08 { //外部类
	public class Inner08 {//成员内部类
        public void say() {
            System.out.println("你好");
        }
    }
}
public class Test {//外部类其他类
    public static void main(String[] args) {
        //方式 1
		//outer08.new Inner08(); 相当于把 new Inner08()当成outer08的成员
        // 这就是一个语法，不要特别的纠结
        Outer08.Inner08 inner08 = outer08.new Inner08();
        inner08.say();
        //方式 2
		//编写一个方法，可以返回成员内部类的对象实例.
    }
}
```

##### 静态内部类

![image-20240306151901882](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306151901882.png) 

**外部其他类 使用静态内部类：**

```java
class Outer10 { //外部类
    static class Inner10 {
        public void say() {
            System.out.println("你好");
        }
    }
}
public class Test {//外部类其他类
    public static void main(String[] args) {
        //方式 1
		//因为静态内部类，是可以通过类名直接访问(前提是满足访问权限)
        Outer10.Inner10 inner10 = new Outer10.Inner10();
        inner10.say();
        //方式 2
		//编写一个方法，可以返回静态内部类的对象实例.
    }
}
```

### 11：枚举和注解

#### 枚举

1) 枚举对应英文(enumeration, 简写 enum) 
2) 枚举是一组常量的集合
3) 可以这里理解：枚举属于一种特殊的类，里面只包含一组有限的特定的对象。

**枚举的二种实现方式：**

1) 自定义类实现枚举 
2) 使用 enum 关键字实现枚举

##### 增强for循环

```java
int[] nums = {1,2,3,4,5,6};

//执行流程是 依次从 nums 数组中取出数据，赋给 i, 如果取出完毕，则退出 for
for (int i : nums) {
    System.out.println("i=" + i);
}
```

##### 自定义枚举

![image-20240307101028951](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307101028951.png) 

**步骤：**

1. 将构造器私有化,目的防止 直接 new 
2. 去掉 setXxx 方法, 防止属性被修该
3. 在 Season 内部，直接创建固定的对象 
4. 优化，可以加入 final 修饰符

```java
class Season {
    private String name;
    private String desc;//描述
    
    //3.在 Season 内部，直接创建固定的对象 
    //4.优化，可以加入 final 修饰符
    public static final Season SPRING = new Season("春天", "温暖");
    public static final Season WINTER = new Season("冬天", "寒冷");
    public static final Season AUTUMN = new Season("秋天", "凉爽");
    public static final Season SUMMER = new Season("夏天", "炎热");
    
    //1.将构造器私有化,目的防止 直接 new 
    private Season(String name, String desc) {
        this.name = name;
        this.desc = desc;
	}
```

**进行自定义类实现枚举，有如下特点：**

1) 构造器私有化 
2) 本类内部创建一组对象[四个 春夏秋冬]
3) 对外暴露对象（通过为对象添加 public final static 修饰符）
4) 可以提供 get 方法，但是不要提供 set

##### enum 枚举

###### enum 来实现枚举

1. 使用关键字 enum 替代 class
2. public static final Season SPRING = new Season("春天", "温暖")   ====》**SPRING("春天", "温暖")** 解读 常量名(实参列表) 
3. **如果有多个常量(对象)， 使用 ,号间隔即可**
4.  **常量对象的定义要写在最前面** 
5. 如果我们使用的是无参构造器，创建常量对象，则可以省略 **括号（）**

```java
//1.使用关键字 enum 替代 class
enum Season2 {
    //2.public static final Season SPRING = new Season("春天", "温暖")   ====》SPRING("春天", "温暖")
    //解读 常量名(实参列表) 
	SPRING("春天", "温暖"), 
    WINTER("冬天", "寒冷"), //3.如果有多个常量(对象)， 使用 ,号间隔
    AUTUMN("秋天", "凉爽"),
    SUMMER("夏天", "炎热");
    //4. 常量对象的定义要写在最前面
    
    //What() ==> what;  5.如果我们使用的是无参构造器，创建常量对象，则可以省略 括号（）
    
    private String name;
	private String desc;//描述
    
    //默认是私有的
    Season2(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }
    
    private Season2() {//无参构造器
	}
}
```

###### **注意事项**

1. 当我们使用 enum 关键字开发一个枚举类时，**默认会继承 Enum 类**, **而且是一个 final 类**,可以使用 javap 工 具来演示 
2. 传统的 public static final Season2 SPRING = new Season2("春天", "温暖"); **简化成 SPRING("春天", "温暖")**， 这里必须知道，它调用的是哪个构造器. 
3. 如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略
4. 当有多个枚举对象时，使用,间隔，**最后有一个分号结尾** 
5. **枚举对象必须放在枚举类的行首**

![image-20240307102849743](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307102849743.png) 

###### enum 常用方法

说明：使用关键字 enum 时，会隐式继承 Enum 类, 这样我们就可以使用 Enum 类相关的方法。

1) **toString**:Enum 类已经重写过了，返回的是当前对象 名,子类可以重写该方法，用于返回对象的属性信息 
2) **name**：返回当前对象名（常量名），子类中不能重写
   System.out.println(==autumn.name()==);
3) **ordinal**：返回当前对象的位置号，默认从 0 开始
   System.out.println(==autumn.ordinal()==);
4) **values**：返回当前枚举类中所有的常量
   Season2[] values = ==Season2.values()==;
5) **valueOf**：将字符串转换成枚举对象，要求字符串必须 为已有的常量名，否则报异常！
   Season2 autumn1 = ==Season2.valueOf("AUTUMN")==;
6) **compareTo**：比较两个枚举常量，比较的就是编号！
   System.out.println(==Season2.AUTUMN.compareTo(Season2.SUMMER)==)

###### enum 实现接口

1. 使用 enum 关键字后，就不能再继承其它类了，**因为 enum 会隐式继承 Enum，而 Java 是单继承机制**。 

2. 枚举类和普通类一样，可以实现接口，如下形式。 
   **enum 类名 implements 接口 1，接口 2{}**

   ```java
   interface IPlaying {//接口
   	public void playing();
   }
   
   enum Music implements IPlaying {//枚举类实现接口
       CLASSICMUSIC;
       @Override
       public void playing() {
       	System.out.println("播放好听的音乐...");
       }
   }
   ```

#### 注解

##### 注解的理解

1) 注解(Annotation)也被称为元数据(Metadata)，**用于修饰解释** 包、类、方法、属性、构造器、局部变量等数据信息。
2) 和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，**相当于嵌入在代码中的补充信息**。
3) 在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。
4) 在 JavaEE 中注解占据了更重要的角 色，例如用来配置应用程序的任何切面，代替 java EE 旧版中所遗留的繁冗代码和 XML 配置等。

##### Annotation 分类

使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素

三个基本的 Annotation: 

1. **@Override**: 限定某个方法，是重写父类方法, 该注解只能用于方法
2. **@Deprecated**: 用于表示某个程序元素(类, 方法等)已过时
3. **@SuppressWarnings**: 抑制编译器警告

##### @Override

![image-20240307105801970](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307105801970.png) 

![image-20240307105835684](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307105835684.png) 

##### @Deprecated

@Deprecated: 用于表示某个程序元素(类, 方法等)已过时

![image-20240307105919709](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307105919709.png) 

##### @SuppressWarnings

@SuppressWarnings: 抑制编译器警告

![image-20240307110004803](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307110004803.png) 

##### 元注解的基本介绍

**JDK 的元 Annotation 用于修饰其他 Annotation** 

元注解： 本身作用不大，讲这个原因希望同学们，看源码时，可以知道他是干什么.

1) Retention //指定注解的作用范围，三种 SOURCE,CLASS,RUNTIME 
2) Target // 指定注解可以在哪些地方使用 
3) Documented //指定该注解是否会在 javadoc 体现 
4) Inherited //子类会继承父类注解

#### 本章作业

![image-20240307110345574](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307110345574.png) 

![image-20240307110359777](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307110359777.png) 

### 12：异常

#### 异常介绍

![image-20240307174052378](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307174052378.png) 

#### 异常体系图

![image-20240307174200505](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307174200505.png) 

![image-20240307174225877](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307174225877.png) 

#### 运行时异常

对于运行时异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。

**常见的运行时异常：**

1) NullPointerException 空指针异常 
   当应用程序试图在**需要对象的地方使用null时**，抛出该异常
2) ArithmeticException 数学运算异常 
   当出现异常的运算条件时，抛出此异常。例如，**一个整数“除以零”**时，抛出此类的一个实例
3) ArrayIndexOutOfBoundsException 数组下标越界异常
   **用非法索引访问数组时抛出的异常**。如果索引为负或大于等于数组大小，则该索引为非法索引
4) ClassCastException 类型转换异常 
   当**试图将对象强制转换为不是实例的子类时**，抛出该异常，例如：在向上转型和向下转型的时候
5) NumberFormatException 数字格式不正确异常
   当应用程序**试图将字符串转换成一种数值类型**，但该字符串不能转换为适当格式时，抛出该异常

#### 编译异常

编译异常是指在编译期间，就必须处理的异常，否则代码不能通过编译。

**常见的编译异常：**

![image-20240307175609545](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307175609545.png) 

#### 异常处理

异常处理就是当异常发生时，对异常处理的方式。

**异常处理的方式：**

1. try-catch-finally

2. throws

   ![image-20240307175805347](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307175805347.png) 

##### try-catch 异常处理

![image-20240307175857673](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307175857673.png) 

**try-catch 方式处理异常说明：**

![image-20240307180020062](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180020062.png) 

**try-catch 方式处理异常-注意事项：**

![image-20240307180104995](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180104995.png) 

![image-20240307180120345](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180120345.png) 

![image-20240307180148754](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180148754.png) 

##### throws异常处理

**介绍：**

![image-20240307180240788](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180240788.png) 

![image-20240307175938523](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307175938523.png) 

**使用细节：**

![image-20240307180330439](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180330439.png) 

#### 自定义异常

**基本概念：**

![image-20240307180428334](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180428334.png) 

**步骤：**

![image-20240307180446022](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180446022.png) 

```java
class AgeException extends RuntimeException {
    public AgeException(String message) {//构造器
		super(message);
	}
}

throw new AgeException("年龄需要在 18~120 之间");
```

#### throw 和 throws 区别

![image-20240307180635727](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180635727.png) 

#### 本章作业

![image-20240307180731664](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180731664.png) 

![image-20240307180748657](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180748657.png) 

### 13：常用类

#### 包装类

##### 包装类的分类

1) 针对八种基本数据类型相应的引用类型—包装类 
2) 有了类的特点，就可以调用类中的方法。

![image-20240308170618202](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308170618202.png) 

##### 包装类和基本数据

![image-20240308170741778](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308170741778.png) 

**手动装箱：**

```java
//手动装箱 int->Integer
int n1 = 100;
Integer integer = new Integer(n1);
Integer integer1 = Integer.valueOf(n1);

//手动拆箱 Integer -> int
int i = integer.intValue();
```

**自动装箱：**

```java
//jdk5 后，就可以自动装箱和自动拆箱
//自动装箱 int->Intege
int n2 = 200;
Integer integer2 = n2;//底层使用的是 Integer.valueOf(n2)

//自动拆箱 Integer->int
int n3 = integer2; //底层仍然使用的是 intValue()方法
```

##### 包装类和 String 类

```java
//包装类(Integer)->String
Integer i = 100;//自动装箱
//方式 1
String str1 = i + "";
//方式 2
String str2 = i.toString();
//方式 3
String str3 = String.valueOf(i);

//String -> 包装类(Integer)
String str4 = "12345";
Integer i2 = Integer.parseInt(str4);//使用到自动装箱
Integer i3 = new Integer(str4);//构造
```

####  String 类

##### String 类的理解

![image-20240308171619508](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308171619508.png) 

![image-20240308171701632](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308171701632.png) 

```java
//1.String 对象用于保存字符串，也就是一组字符序列

//2. "jack" 字符串常量, 双引号括起的字符序列

//3. 字符串的字符使用 Unicode 字符编码，一个字符(不区分字母还是汉字)占两个字节

//4. String 类有很多构造器，构造器的重载
// 常用的有 String s1 = new String(); //
//String s2 = new String(String original);
//String s3 = new String(char[] a);
//String s4 = new String(char[] a,int startIndex,int count)
//String s5 = new String(byte[] b)

//5. String 类实现了接口 Serializable【String 可以串行化:可以在网络传输】，接口 Comparable [String 对象可以比较大小]

//6. String 是 final 类，不能被其他的类继承

//7. String 有属性 private final char value[]; 用于存放字符串内容

//8. 一定要注意：value 是一个 final 类型， 不可以修改(需要功力)：即 value 不能指向新的地址，但是单个字符内容是可以变
```

##### 创建 String 对象

![image-20240308172017598](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172017598.png) 

**两种创建 String 对象的区别：**

![image-20240308172052241](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172052241.png) 

![image-20240308172114853](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172114853.png) 

##### String 类的常见方法

**String缺点：**

![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172216821.png) 

**String 类的常见方法一览：**

![image-20240308172255299](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172255299.png) 

![image-20240308172331604](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172331604.png) 

#####  StringBuffer 类

###### **基本介绍：**

![image-20240308172504823](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172504823.png) 

```java
//1. StringBuffer 的直接父类 是 AbstractStringBuilder

//2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化

//3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final该 value 数组存放 字符串内容，引出存放在堆中的

//4. StringBuffer 是一个 final 类，不能被继承

//5. 因为 StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除)

// 不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String
StringBuffer stringBuffer = new StringBuffer("hello");
```

######  **String VS StringBuffer：**

![image-20240308172848918](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172848918.png) 

###### **String 和 StringBuffer 相互转换：**

![image-20240308172914816](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172914816.png) 

```java
//看 String——>StringBuffer
String str = "hello tom";
//方式 1 使用构造器
//注意： 返回的才是 StringBuffer 对象，对 str 本身没有影响
StringBuffer stringBuffer = new StringBuffer(str);
//方式 2 使用的是 append 方法
StringBuffer stringBuffer1 = new StringBuffer();
stringBuffer1 = stringBuffer1.append(str);

//看 StringBuffer ->String
StringBuffer stringBuffer3 = new StringBuffer("韩顺平教育");
//方式 1 使用 StringBuffer 提供的 toString 方法
String s = stringBuffer3.toString();
//方式 2: 使用构造器来搞定
String s1 = new String(stringBuffer3)
```

######  StringBuffer 类常见方法

```java
StringBuffer s = new StringBuffer("hello");
//增
s.append(',');// "hello,
s.append("张三丰");//"hello,张三丰"
s.append("赵敏").append(100).append(true).append(10.5);//"hello,张三丰赵敏 100true10.5"

//删
s.delete(11, 14);//"hello,张三丰赵敏 true10.5

//改
s.replace(9, 11, "周芷若");//"hello,张三丰周芷若 true10.5

//插
s.insert(9, "赵敏");//"hello,张三丰赵敏周芷若 true10.5

//长度
s.length()
```

##### StringBuilder 类

###### **基本介绍**

![image-20240308174956149](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308174956149.png) 

```java
//1. StringBuffer 的直接父类 是 AbstractStringBuilder

//2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化

//3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final该 value 数组存放 字符串内容，引出存放在堆中的

//4. StringBuffer 是一个 final 类，不能被继承

//5. 因为 StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除),不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String

StringBuffer stringBuffer = new StringBuffer("hello");

//6. StringBuilder 的方法，没有做互斥的处理,即没有 synchronized 关键字,因此在单线程的情况下使用
```

######  String、StringBuffer 和 StringBuilder 的比较

![image-20240308175326835](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308175326835.png) 

###### String、StringBuffer 和 StringBuilder 的选择

![image-20240308175436067](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308175436067.png) 

####  Math 类

Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。

**方法一览(均为静态方法)：**

```java
//1.abs 绝对值
int abs = Math.abs(-9);
System.out.println(abs);//9
//2.pow 求幂
double pow = Math.pow(2, 4);//2 的 4 次方
System.out.println(pow);//16
//3.ceil 向上取整,返回>=该参数的最小整数(转成 double);
double ceil = Math.ceil(3.9);
System.out.println(ceil);//4.0
//4.floor 向下取整，返回<=该参数的最大整数(转成 double)
double floor = Math.floor(4.001);
System.out.println(floor);//4.0
//5.round 四舍五入 Math.floor(该参数+0.5)
long round = Math.round(5.51);
System.out.println(round);//6
//6.sqrt 求开方
double sqrt = Math.sqrt(9.0);
System.out.println(sqrt);//3.0

//7.random 求随机数
// random 返回的是 0 <= x < 1 之间的一个随机小数
// 思考：请写出获取 a-b 之间的一个随机整数,a,b 均为整数 ，比如 a = 2, b=7
// 即返回一个数 x 2 <= x <= 7
// 老韩解读 Math.random() * (b-a) 返回的就是 0 <= 数 <= b-a
// (1) (int)(a) <= x <= (int)(a + Math.random() * (b-a +1) )
// (2) 使用具体的数给小伙伴介绍 a = 2 b = 7
// (int)(a + Math.random() * (b-a +1) ) = (int)( 2 + Math.random()*6)
// Math.random()*6 返回的是 0 <= x < 6 小数
// 2 + Math.random()*6 返回的就是 2<= x < 8 小数

//8.max , min 返回最大值和最小值
int min = Math.min(1, 9);
int max = Math.max(45, 90);
System.out.println("min=" + min);
System.out.println("max=" + max);
```

####  Arrays 类

**Arrays 类常见方法：**

![image-20240309110000976](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309110000976.png) 

![image-20240309110031519](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309110031519.png) 

```java
3)binarySearch 通过二分搜索法进行查找，要求必须排好
//1. 使用 binarySearch 二叉查找
//2. 要求该数组是有序的. 如果该数组是无序的，不能使用 binarySearch
//3. 如果数组中不存在该元素，就返回 return -(low + 1) // key not found.
```



#### System 类

![image-20240309110213285](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309110213285.png) 

```java
2）arraycopy()
// srcPos： 从源数组的哪个索引位置开始拷贝
// dest : 目标数组，即把源数组的数据拷贝到哪个数组
// destPos: 把源数组的数据拷贝到 目标数组的哪个索引
// length: 从源数组拷贝多少个数据到目标数组
```

#### 大数类

**BigInteger 、BigDecimal 类：**

![image-20240309110808224](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309110808224.png) 

**常见方法：**注意这些大数类不能直接+-*/哦，要调用方法

![image-20240309110839015](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309110839015.png) 

```java
long l = 23788888899999999999999999999l; // 编译会报错
BigInteger bigInteger = new BigInteger("23788888899999999999999999999");
System.out.println(bigInteger);

//1. 在对 BigInteger 进行加减乘除的时候，需要使用对应的方法，不能直接进行 + - * /
//2. 可以创建一个 要操作的 BigInteger 然后进行相应操作
BigInteger add = bigInteger.add(bigInteger2);

//当我们需要保存一个精度很高的数时，double 不够
double d = 1999.11111111111999999999999977788d; //输出时，会截断后面的很多小数
BigDecimal bigDecimal = new BigDecimal("1999.11111111111999999999999977788");

//1. 如果对 BigDecimal 进行运算，比如加减乘除，也需要使用对应的方法
//2. 创建一个需要操作的 BigDecimal 然后调用相应的方法即可
System.out.println(bigDecimal.divide(bigDecimal2));//可能抛出异常 ArithmeticExceptio
//在调用 divide 方法时，指定精度即可. BigDecimal.ROUND_CEILING
//如果有无限循环小数，就会保留 分子 的精度
System.out.println(bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING))
```

#### 日期类

#####  第一代日期类

![image-20240309111356647](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309111356647.png) 

```java
//1. 获取当前系统时间
//2. 这里的 Date 类是在 java.util 包
//3. 默认输出的日期格式是国外的方式, 因此通常需要对格式进行转换

Date d1 = new Date(); 
Date d2 = new Date(9234567);  //通过指定毫秒数得到时间

//1. 创建 SimpleDateFormat 对象，可以指定相应的格式
//2. 这里的格式使用的字母是规定好，不能乱写
SimpleDateFormat sdf = new SimpleDateFormat("yyyy 年 MM 月 dd 日 hh:mm:ss E");
String format = sdf.format(d1); // format:将日期转换成指定格式的字符串
System.out.println("当前日期=" + format);
```



#####  第二代日期类

![image-20240309111430624](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309111430624.png) 

```java
//1. Calendar 是一个抽象类， 并且构造器是 private
//2. 可以通过 getInstance()
//3. 提供大量的方法和字段提供给程序员
//4. Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活)
//5. 如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR ==改成=> Calendar.HOUR_OF_DAY

Calendar c = Calendar.getInstance();
System.out.println("c=" + c);

System.out.println("年：" + c.get(Calendar.YEAR));
// 这里为什么要 + 1, 因为 Calendar 返回月时候，是按照 0 开始编号
System.out.println("月：" + (c.get(Calendar.MONTH) + 1));
//Calender 没有专门的格式化方法，所以需要程序员自己来组合显示
System.out.println(c.get(Calendar.YEAR) + "-" + (c.get(Calendar.MONTH) + 1) + "-" +
					c.get(Calendar.DAY_OF_MONTH) +" " + c.get(Calendar.HOUR_OF_DAY) + ":" + 									c.get(Calendar.MINUTE) + ":" + c.get(Calendar.SECOND) )
```

#####  第三代日期类

**前两代的不足：**

![image-20240309112129814](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309112129814.png) 

**第三代日期类：**

![image-20240309112237443](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309112237443.png) 

```java
//1. 使用 now() 返回表示当前日期时间的 对象
LocalDateTime ldt = LocalDateTime.now(); //LocalDate.now();//LocalTime.now()
System.out.println(ldt);

//2. 使用 DateTimeFormatter 对象来进行格式化
// 创建 DateTimeFormatter 对象
DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
String format = dateTimeFormatter.format(ldt);
System.out.println("格式化的日期=" + format);

System.out.println("年=" + ldt.getYear());
System.out.println("月=" + ldt.getMonth());
System.out.println("月=" + ldt.getMonthValue());
System.out.println("日=" + ldt.getDayOfMonth());
System.out.println("时=" + ldt.getHour());
System.out.println("分=" + ldt.getMinute());
System.out.println("秒=" + ldt.getSecond());

//3.提供 plus 和 minus 方法可以对当前时间进行加或者减
//看看 890 天后，是什么时候 把 年月日-时分秒
LocalDateTime localDateTime = ldt.plusDays(890);
//看看在 3456 分钟前是什么时候，把 年月日-时分秒
LocalDateTime localDateTime2 = ldt.minusMinutes(3456);
```

#####  DateTimeFormatter

![image-20240309112551648](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309112551648.png) 

#####  Instant 时间戳

![image-20240309112619261](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309112619261.png) 

#### 本章作业

![image-20240309112659936](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309112659936.png) 

![image-20240309112726941](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309112726941.png)  

### 14：集合

#### 数组的缺点

前面我们保存多个数据使用的是数组，而数组有不足的地方

![image-20240309162809195](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309162809195.png) 

#### 集合

**介绍：**

![image-20240309162853015](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309162853015.png) 

**集合框架体系：**

Java 的集合类很多，主要分为两大类，集合主要是两组(**单列集合** , **双列集合**），Collection 接口有两个重要的子接口 **List** 和**Set** , 他们的实现子类都是单列集；Map 接口的实现子类 是双列集合，存放的 **K-V**

1. **Collection**

   ![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309162947303.png) 

2. **Map**

   ![image-20240309163045641](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309163045641.png) 

#### Collection 接口

#####  **特点**

![image-20240309163352481](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309163352481.png) 

##### 使用 Iterator遍历

![image-20240309163614699](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309163614699.png) 

![image-20240309163647889](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309163647889.png) 

![image-20240309163713779](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309163713779.png) 

```java
Collection col = new ArrayList();
col.add(new Book("三国演义", "罗贯中", 10.1));
col.add(new Book("小李飞刀", "古龙", 5.1));
col.add(new Book("红楼梦", "曹雪芹", 34.6));

//1. 先得到 col 对应的 迭代器
Iterator iterator = col.iterator();
//2. 使用 while 循环遍历
while (iterator.hasNext()) {//判断是否还有数据
    Object obj = iterator.next();    //返回下一个元素，类型是 Object
    System.out.println("obj=" + obj);
}

//3. 当退出 while 循环后 , 这时 iterator 迭代器，指向最后的元素
iterator.next();//NoSuchElementException

//4. 如果希望再次遍历，需要重置我们的迭代器
iterator = col.iterator();
```

##### 使用增强for 遍历

![image-20240309164237070](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309164237070.png) 

#### List 接口

 **List 接口基本介绍：**

![image-20240309164428358](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309164428358.png) 

**List 的三种遍历方式：**

![image-20240309164555204](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309164555204.png) 

#### ArrayList类

#####  ArrayList 注意事项

![image-20240309164720678](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309164720678.png) 

##### 底层操作机制

![image-20240309164804936](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309164804936.png) 

##### 源码分析

![image-20240309165014622](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309165014622.png)

#### Vector类

**Vector 的基本介绍:**

![image-20240309165133485](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309165133485.png) 

**Vector 和 ArrayList 的比较:**

![image-20240309165240707](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309165240707.png) 

#### LinkedList类

 **LinkedList说明：**

![image-20240309165344385](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309165344385.png) 

**LinkedList 的底层操作机制：**

![image-20240309165456367](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309165456367.png) 

**ArrayList 和 LinkedList 比较：**

![image-20240309165557406](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309165557406.png) 

#### Set 接口

**基本介绍：**

![image-20240310154100791](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310154100791.png) 

**常用方法：**

和 List 接口一样, Set 接口也是 Collection 的子接口，因此，常用方法和 Collection 接口一样

**遍历方式：**

![image-20240310154225134](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310154225134.png) 

#### HashSet类

##### 介绍

![image-20240310154355827](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310154355827.png) 

##### 底层机制

**HashMap底层：**

![image-20240310154508648](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310154508648.png) 

**运行流程：**

![image-20240310154526665](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310154526665.png) 

![image-20240310154555876](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310154555876.png) 

**扩容和树化流程：**

![image-20240310154651452](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310154651452.png) 

#### LinkedHashSet类

**介绍：**

![image-20240310154940416](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310154940416.png) 

**底层机制：**

![image-20240310155038426](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310155038426.png) 

#### TreeSet类

```java
//1. 当我们使用无参构造器，创建 TreeSet 时，仍然是无序的
TreeSet treeSet = new TreeSet();
//2. 老师希望添加的元素，按照字符串大小来排序
//3. 使用 TreeSet 提供的一个构造器，可以传入一个比较器(匿名内部类)， 并指定排序规则
TreeSet treeSet = new TreeSet(new Comparator() {
    @Override
    public int compare(Object o1, Object o2) {
        return ((String) o1).length() - ((String) o2).length();
    }
}
```



#### Map 接口

##### 介绍

![image-20240310155148144](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310155148144.png) 

![image-20240310155251575](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310155251575.png) 

##### 遍历方法

![image-20240310155358780](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310155358780.png) 

![image-20240310155415049](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310155415049.png) 

#### HashMap类

##### 介绍

![image-20240310155658702](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310155658702.png) 

##### 底层机制

![image-20240310155644731](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310155644731.png) 

![image-20240310155732414](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310155732414.png) 

#### Hashtable类

**介绍：**

![image-20240310155843663](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310155843663.png) 

**Hashtable 和 HashMap对比：**

![image-20240310155941192](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310155941192.png) 

#### Properties类

**介绍：**

![image-20240310160024459](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310160024459.png) 

#### TreeMap类

```java
//1. 当我们使用无参构造器，创建 TreeMap 时，仍然是无序的
TreeMap treeMap = new TreeMap();
//2. 老师希望添加的元素，按照字符串大小来排序
//3. 使用 TreeSet 提供的一个构造器，可以传入一个比较器(匿名内部类)， 并指定排序规则
TreeMap treeMap = new TreeMap(new Comparator() {
    @Override
    public int compare(Object o1, Object o2) {
		return ((String) o2).length() - ((String) o1).length()
    }
}
```

#### 如何选择集合实现类

![image-20240310160133720](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310160133720.png) 

#### Collections 工具类

**介绍:**

![image-20240310160826860](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310160826860.png) 

**排序操作：（均为 static 方法)**

![image-20240310160910975](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310160910975.png) 

**查找、替换操作：**

![image-20240310161004044](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310161004044.png) 

#### 本章作业

![image-20240310183453137](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310183453137.png) 

![image-20240310183505143](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310183505143.png) 

![image-20240310161235533](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310161235533.png) 

### 15：泛型

**使用传统方法的问题分析：**

![image-20240312163904885](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312163904885.png) 

```java
//使用传统的方法来解决，在Arraylist中添加了三个Dog对象
ArrayList arrayList = new ArrayList();
arrayList.add(new Dog("旺财", 10));
arrayList.add(new Dog("发财", 1));
arrayList.add(new Dog("小黄", 5));
    
//假如我们的程序员，不小心，添加了一只猫
arrayList.add(new Cat("招财猫", 8));

//遍历时就会出错，而且有向下转型的时空间开销
for (Object o : arrayList) {
    //向下转型 Object ->Dog
    Dog dog = (Dog) o;
    System.out.println(dog.getName() + "-" + dog.getAge());
}
```

**泛型快速体验：**

![image-20240312164258141](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312164258141.png) 

```java
//1. 当我们 ArrayList<Dog> 表示存放到 ArrayList 集合中的元素是 Dog 类型
//2. 如果编译器发现添加的类型，不满足要求，就会报错
//3. 在遍历的时候，可以直接取出 Dog 类型而不是 Object

ArrayList<Dog> arrayList = new ArrayList<Dog>();
arrayList.add(new Dog("旺财", 10));
arrayList.add(new Dog("发财", 1));
arrayList.add(new Dog("小黄", 5);

//假如我们的程序员，不小心，添加了一只猫
arrayList.add(new Cat("招财猫", 8));//会编译报错

//直接取出 Dog 类型而不是 Object，意思就是不用向下转型，提高了效率
for (Dog dog : arrayList) {
System.out.println(dog.getName() + "-" + dog.getAge());
}
```

#### 泛型的好处

![image-20240312164738223](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312164738223.png) 

#### 泛型介绍

![image-20240312164834821](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312164834821.png) 

```java
class Person<E> {
    E s;//可以在类声明时通过一个标识表示类中某个属性的类型
    
    public Person(E s) {//E 也可以是参数类型
    	this.s = s;
    }
    
    public E f() {//返回类型也可以使用 E
    	return s;
    }
}
```

#### 泛型语法

##### 泛型的声明

![image-20240312164958429](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312164958429.png) 

##### 泛型的实例化

![image-20240312165040545](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312165040545.png) 

##### 泛型使用举例

![image-20240312165423938](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312165423938.png) 

```java
HashSet<Student> studentHashSet = new HashSet<Student>();
studentHashSet.add(new Student("陈俊宇",23));
studentHashSet.add(new Student("小明",24));
studentHashSet.add(new Student("小红",25));

for (Student student : studentHashSet) {
    System.out.println(student.getName() + "-" + student.getAge());
}

HashMap<String, Student> studentHashMap = new HashMap<>();
studentHashMap.put("陈俊宇",new Student("陈俊宇",23));
studentHashMap.put("小明",new Student("小明",23));
studentHashMap.put("小红",new Student("小红",23));

//先取entrySet，再取itrator，最后取iterator.next()
Set<Map.Entry<String, Student>> entries = studentHashMap.entrySet();
Iterator<Map.Entry<String, Student>> iterator = entries.iterator();
while (iterator.hasNext()) {
    Map.Entry<String, Student> next = iterator.next();
    System.out.println(next.getKey()+"-"+next.getValue().getAge());
}
```

##### 泛型使用的注意事项

![image-20240312171808800](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312171808800.png) 

```java
自定义泛型
//1.给泛型指向数据类型是，要求是引用类型，不能是基本数据类型
List<Integer> list = new ArrayList<Integer>(); //OK
List<int> list2 = new ArrayList<int>();//错误

//2. B是A的子类
//在给泛型指定具体类型后，可以传入该类型或者其子类类型
Pig<A> aPig = new Pig<A>(new A());
Pig<A> aPig2 = new Pig<A>(new B());

//3. 泛型的使用形式，在实际开发中，我们往往简写
ArrayList<Integer> list1 = new ArrayList<Integer>();
List<Integer> list2 = new ArrayList<Integer>();
//等价于
ArrayList<Integer> list3 = new ArrayList<>();
List<Integer> list4 = new ArrayList<>();

//4. 如果是这样写 泛型默认是 Object
ArrayList arrayList = new ArrayList();
//等价于
ArrayList<Object> arrayList = new ArrayList<Object>()
```

#### 自定义泛型

##### 自定义泛型类

![image-20240312185141247](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312185141247.png) 

```java
class Tiger<T, R, M> {
    String name;
	R r; //属性使用到泛型
    T[] ts = new T[10];//错误，因为数组在 new 不能确定 T 的类型，就无法在内存开空间。使用泛型的数组，不能初始化
    static R r2; //错误，因为静态是和类相关的，在类加载时，对象还没有创建。所以，如果静态方法和静态属性使用了泛型，JVM 就无法完成初始化。
    
    public Tiger(R r) {//构造器使用泛型
        this.r = r;
    }
    public void setR(R r) {//方法使用到泛型
    	this.r = r;
    }
}

Tiger<Double,String,Integer> g = new Tiger<>("john");
Tiger g2 = new Tiger("john~~");//OK T=Object R=Object M=Object
```

##### 自定义泛型接口

![image-20240312190108785](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312190108785.png) 

```java
interface IUsb<U, R> {
    int n = 1;
    U name; //不能这样使用
    //普通方法中，可以使用接口泛型
	R get(U u);
}

//在继承接口 指定泛型接口的类型
interface IA extends IUsb<String, Double> {
}
```

##### 自定义泛型方法

![image-20240312190648901](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312190648901.png) 

####  泛型的继承和通配符

![image-20240312190752691](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312190752691.png) 

```java
List<?> list = new ArrayList<>();
List<? extends AA> c list = new ArrayList<>();
List<? super AA> c list = new ArrayList<>();

public static void printCollection3(List<? super AA> c) {};
public static void printCollection1(List<?> c) {};
public static void printCollection2(List<? extends AA> c) {};
```

#### 本章作业

![image-20240312191252043](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312191252043.png) 

### 16：坦克大战

#### java 绘图坐标体系

![image-20240313105756958](C:\Users\cjy\AppData\Roaming\Typora\typora-user-images\image-20240313105756958.png) 

**坐标体系-像素:**

![image-20240313105851236](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240313105851236.png) 

#### 绘图原理

![image-20240313110022641](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240313110022641.png) 

**Graphics 类:**

![image-20240313110105199](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240313110105199.png) 

#### 绘出坦克

![image-20240313110152617](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240313110152617.png) 

![image-20240313110210579](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240313110210579.png) 

#### java 事件处理机制

##### 基本说明

![image-20240313110316761](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240313110316761.png) 

##### 示意图

![image-20240313110345490](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240313110345490.png) 

##### 机制分析

![image-20240313110408373](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240313110408373.png) 

##### 深入理解

![image-20240313110436330](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240313110436330.png) 

![image-20240313110508870](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240313110508870.png) 

![image-20240313110523591](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240313110523591.png) 

#### 本章作业

![image-20240313110615410](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240313110615410.png) 

### 17：多线程基础

#### 进程基本概念

1. 正在运行的程序（软件）就是一个独立的进程
2. 线程是属于进程的，一个进程中可以同时运行很多个线程
3. 进程中的多个线程其实是并发和并行执行的

**并发的含义：**

进程中的线程是由CPU负责调度执行的，但CPU能同时处理线程的数量有限，为了保证全部线程都能往前执行，**CPU会轮询为系统的每个线程服务**，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。

**并行的理解：**

在同一个时刻上，同时有多个线程在被CPU调度执行。

所以说，**多线程是并发和并行同时进行的。**

#### 线程基本概念

**什么是线程：**

![image-20240314111445419](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314111445419.png) 

**什么是多线程：**

![image-20240314111539060](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314111539060.png)

#### 线程的生命周期

1. 线程的生命周期是线程从生到死的过程中，经历的**各种状态及状态转换**。
2. Java总共定义了6种状态，6种状态都定义在Thread类的内部枚举类中。
   ![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314155917176.png) 

3. 线程的6种状态转换
   ![image-20240314160109740](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314160109740.png)

4. 线程六种状态总结
   ![image-20240314160228236](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314160228236.png) 

#### 创建多线程

**Java是通过java.lang.Thread 类的对象来代表线程的**。Java有三种方式创建多线程，分别为：继承Thread类、实现Runnable接口、实现Callable接口。

##### 继承Thead类

**步骤：**

1. 定义一个子类MyThread继承线程类java.lang.Thread，重写run()方法
2. 创建MyThread类的对象
3. 调用线程对象的start()方法启动线程（启动后还是执行run方法的）
   （注意：这里调用start()方法——>start0()方法——>底层调用run()方法，这里是JVM的调用）

```java
//1.定义一个子类MyThread继承线程类java.lang.Thread，重写run()方法
public class MyThread extends Thread {
    @Override
    public void run() {
        for (int i = 1; i <= 3; i++) {
            System.out.println("您好");
        }
    }
}
//2.创建MyThread类的对象
Thread t1 = new MyThread();
//3.调用线程对象的start()方法启动线程
t1.start();
```

**注意事项：**

1. 启动线程必须是调用start方法，不是调用run方法。
   1. 直接调用run方法会当成普通方法执行，此时相当于还是单线程执行。
   2. 只有调用start方法才是启动一个新的线程执行。
2. 不要把主线程任务放在启动子线程之前。因为这样主线程一直是先跑完的，相当于是一个单线程的效果了。

**优缺点：**

优点：编码简单

缺点：线程类已经继承Thread，无法继承其他类，不利于功能的扩展。

##### 实现Runnable接口

**步骤：**

1. 定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法
2. 创建MyRunnable**任务对象**
3. 把MyRunnable任务对象交给Thread处理。
   ![image-20240314112803624](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314112803624.png) 
4. 调用**线程对象**的start()方法启动线程

```java
//1.定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法
public class MyRunnable implements Runnable {
    @Override
    public void run() {
		for (int i = 1; i <= 3; i++) {
            System.out.println("您好");
        }
    }
}
//2.创建MyRunnable任务对象
Runnable runnable = new MyRunnable();
//3.把MyRunnable任务对象交给Thread处理。4.调用线程对象的start()方法启动线程
new Thread(runnable).start();

//用匿名内部类优化
new Thread(new Runnable {
    @Override
    public void run() {
        System.out.println("您好");
    }
}).start();
```

**优缺点:**

优点：任务类只是实现接口，**可以继续继承其他类、实现其他接口，扩展性强**。

缺点：需要多一个Runnable对象。

##### 实现Callable接口

**前两个方式的问题：**

![image-20240314113849925](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314113849925.png) 

**利用Callable接口、FutureTask类来实现的步骤：**

1. 创建任务对象
   1. 定义一个类实现Callable接口，重写call方法，封装要做的事情，和要返回的数据。
   2. **把Callable类型的对象**封装成FutureTask（**线程任务对象**）。
      ![image-20240314115043019](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314115043019.png)
2. 把线程任务对象交给**Thread对象**。
3. 调用Thread对象的start方法启动线程。
4. 线程执行完毕后，通过**FutureTask对象的的get方法**去获取线程任务执行的结果。

```java
//1.1 定义一个类实现Callable接口，重写call方法，封装要做的事情，和要返回的数据。
public class MyCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        System.out.println("您好");
        return "您好";
    }
}
MyCallable myCallable = new MyCallable();
//1.2 把Callable类型的对象封装成FutureTask（线程任务对象）。
FutureTask<String> stringFutureTask = new FutureTask<>(myCallable);
//2. 把线程任务对象交给Thread对象。
Thread thread = new Thread(stringFutureTask);
//3. 调用Thread对象的start方法启动线程。
thread.start();
//4. 线程执行完毕后，通过FutureTask对象的的get方法去获取线程任务执行的结果
String s = stringFutureTask.get();
```

**优缺点:**

优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强；可以在线程执行完毕后去获取线程执行的结果。

缺点：编码复杂一点。

![image-20240314115151846](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314115151846.png) 

#### Thread常用方法

![image-20240314140152345](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314140152345.png) 

```java
public class MyThread extends Thread{
    public MyThread(String name){
        super(name); //1.执行父类Thread(String name)构造器，为当前线程设置名字了
    }
    @Override
    public void run() {
        //2.currentThread() 哪个线程执行它，它就会得到哪个线程对象。
        Thread t = Thread.currentThread();
        for (int i = 1; i <= 3; i++) {
            //3.getName() 获取线程名称
            System.out.println(t.getName() + "输出：" + i);
        }
    }
}
```

#### 线程安全

多个线程，同时操作同一个共享资源的时候，可能会出现业务安全问题。

![image-20240314140627270](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314140627270.png) 

#### 线程同步

解决线程安全问题的方案。

线程同步的思想是**让多个线程实现先后依次访问共享资源**，这样就解决了安全问题。

线程同步的常见方案是**加锁**：每次只允许一个线程加锁，加锁后才能进入访问，访问完毕后自动解锁，然后其他线程才能再加锁进来。

线程同步有三种方式分别是：同步代码块、同步方法、Lock锁

##### 同步代码块

**作用：**

把访问共享资源的核心代码给上锁，以此保证线程安全。对出现问题的核心代码**使用synchronized进行加锁**，每次只能一个线程占锁进入访问

![image-20240314141114951](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314141114951.png)  

**原理：**

每次只允许一个线程加锁后进入，执行完毕后自动解锁，其他线程才可以进来执行。

**注意事项：**

1. 对于当前同时执行的线程来说，**同步锁必须是同一把（同一个对象）**，否则会出bug。
2. 锁对象**不能随便选择一个唯一的对象**，因为会影响其他无关线程的执行。
3. 建议使用共享资源作为锁对象，对于**实例方法建议使用this作为锁对象**。
4. 对于**静态方法建议使用字节码（类名.class）对象作为锁对象**。

```java
// 小明 小红线程同时过来的
public void drawMoney(double money) {
    String name = Thread.currentThread().getName();    // 先搞清楚是谁来取钱？
    //1. 对于实例方法建议使用this作为锁对象
    synchronized (this) {
        if(this.money >= money){
            System.out.println(name + "来取钱" + money + "成功！");
            this.money -= money;
            System.out.println(name + "来取钱后，余额剩余：" + this.money);
        }else {
            System.out.println(name + "来取钱：余额不足~");
        }
    }
}

//静态方法
public static void drawMoney(double money) {
    String name = Thread.currentThread().getName();    // 先搞清楚是谁来取钱？
    //2. 静态方法建议使用字节码（类名.class）对象作为锁对象
    synchronized (drawMoney.class) {
        if(this.money >= money){
            System.out.println(name + "来取钱" + money + "成功！");
            this.money -= money;
            System.out.println(name + "来取钱后，余额剩余：" + this.money);
        }else {
            System.out.println(name + "来取钱：余额不足~");
        }
    }
}
```

##### 同步方法

其实同步方法，**就是把整个方法给锁住**，一个线程调用这个方法，另一个线程调用的时候就执行不了，只有等上一个线程调用结束，下一个线程调用才能继续执行。

![image-20240314142120207](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314142120207.png) 

**底层原理：**

1. 同步方法其实底层也是有隐式锁对象的，只是锁的范围是整个方法代码。
2. 如果方法是实例方法：同步方法默认用this作为的锁对象。
3. 如果方法是静态方法：同步方法默认用类名.class作为的锁对象。

**同步代码块VS同步方法：**

范围上：同步代码块锁的范围更小，同步方法锁的范围更大。

可读性：同步方法更好。

```java
// 同步方法
public synchronized void drawMoney(double money) {
    // 先搞清楚是谁来取钱？
    String name = Thread.currentThread().getName();
    // 1、判断余额是否足够
    if(this.money >= money){
        System.out.println(name + "来取钱" + money + "成功！");
        this.money -= money;
        System.out.println(name + "来取钱后，余额剩余：" + this.money);
    }else {
        System.out.println(name + "来取钱：余额不足~");
    }
}
```

##### Lock锁

Lock锁是JDK5版本专门提供的一种锁对象，通过这个锁对象的方法来达到加锁，和释放锁的目的，使用起来更加灵活。

Lock是接口，不能直接实例化，可以采用它的实现类ReentrantLock来构建Lock锁对象。

![image-20240314142543119](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314142543119.png) 

```java
1.首先在成员变量位子，需要创建一个Lock接口的实现类对象（这个对象就是锁对象）
	private final Lock lk = new ReentrantLock();
2.在需要上锁的地方加入下面的代码
	 lk.lock(); // 加锁
	 //...中间是被锁住的代码...
	 lk.unlock(); // 解锁
```

```java
// 先创建了一个锁对象
private final Lock lk = new ReentrantLock();

public void drawMoney(double money) {
        // 先搞清楚是谁来取钱？
        String name = Thread.currentThread().getName();
        try {
            lk.lock(); // 加锁
            // 1、判断余额是否足够
            if(this.money >= money){
                System.out.println(name + "来取钱" + money + "成功！");
                this.money -= money;
                System.out.println(name + "来取钱后，余额剩余：" + this.money);
            }else {
                System.out.println(name + "来取钱：余额不足~");
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lk.unlock(); // 解锁
        }
    }
}
```

#### 线程池

##### 线程池工作原理

线程池就是一个可以**复用线程的技术**。如果不使用线程池，用户每发起一个请求，后台就需要创建一个新线程来处理，下次新任务来了肯定又要创建新线程处理的，  而创建新线程的开销是很大的，并且请求过多时，肯定会产生大量的线程出来，这样会严重影响系统的性能。

![image-20240314160532753](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314160532753.png) 

##### 创建线程池

JDK 5.0起提供了代表线程池的**接口：ExecutorService**。有两种方式创建线程池对象分别是：

方式一、使用ExecutorService的实现类**ThreadPoolExecutor**自创建一个线程池对象；
![image-20240314160820300](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314160820300.png) 

方式二、使用**Executors**（线程池的工具类）调用方法返回不同特点的线程池对象。

##### ThreadPoolExecutor

**ThreadPoolExecutor构造器：**

![image-20240314160957384](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314160957384.png)

![image-20240314161022252](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314161022252.png) 

```java
ExecutorService pool = new ThreadPoolExecutor(
    3,	//核心线程数有3个
    5,  //最大线程数有5个。   临时线程数=最大线程数-核心线程数=5-3=2
    8,	//临时线程存活的时间8秒。 意思是临时线程8秒没有任务执行，就会被销毁掉。
    TimeUnit.SECONDS,//时间单位（秒）
    new ArrayBlockingQueue<>(4), //任务阻塞队列，没有来得及执行的任务在，任务队列中等待
    Executors.defaultThreadFactory(), //用于创建线程的工厂对象
    new ThreadPoolExecutor.CallerRunsPolicy() //拒绝策略
);
```

**新任务拒绝策略：**

![image-20240314161456630](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314161456630.png) 

**注意事项：**

![image-20240314161159124](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314161159124.png) 

##### 执行Runnable任务

创建好线程池之后，接下来我们就可以使用线程池执行任务了。线程池执行的任务可以有两种，**一种是Runnable任务；一种是callable任务**。

![image-20240314161353570](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314161353570.png) 

下面的execute方法可以用来执行Runnable任务。

先准备一个线程任务类

```java
public class MyRunnable implements Runnable{
    @Override
    public void run() {
        // 任务是干啥的？
        System.out.println(Thread.currentThread().getName() + " ==> 输出666~~");
        //为了模拟线程一直在执行，这里睡久一点
        try {
            Thread.sleep(Integer.MAX_VALUE);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

下面是执行Runnable任务的代码，注意阅读注释，对照着前面的7个参数理解。

```java
ExecutorService pool = new ThreadPoolExecutor(
    3,	//核心线程数有3个
    5,  //最大线程数有5个。   临时线程数=最大线程数-核心线程数=5-3=2
    8,	//临时线程存活的时间8秒。 意思是临时线程8秒没有任务执行，就会被销毁掉。
    TimeUnit.SECONDS,//时间单位（秒）
    new ArrayBlockingQueue<>(4), //任务阻塞队列，没有来得及执行的任务在，任务队列中等待
    Executors.defaultThreadFactory(), //用于创建线程的工厂对象
    new ThreadPoolExecutor.CallerRunsPolicy() //拒绝策略
);

Runnable target = new MyRunnable();
pool.execute(target); // 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！
pool.execute(target); // 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！
pool.execute(target); // 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！
//下面4个任务在任务队列里排队
pool.execute(target);
pool.execute(target);
pool.execute(target);
pool.execute(target);

//下面2个任务，会被临时线程的创建时机了
pool.execute(target);
pool.execute(target);
// 到了新任务的拒绝时机了！
pool.execute(target);
```

![image-20240314162411893](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314162411893.png) 

##### 执行Callable任务

callable任务相对于Runnable任务来说，就是多了一个返回值。执行Callable任务需要用到下面的submit方法

先准备一个Callable线程任务

```java
public class MyCallable implements Callable<String> {
    private int n;
    public MyCallable(int n) {
        this.n = n;
    }

    // 2、重写call方法
    @Override
    public String call() throws Exception {
        // 描述线程的任务，返回线程执行返回后的结果。
        // 需求：求1-n的和返回。
        int sum = 0;
        for (int i = 1; i <= n; i++) {
            sum += i;
        }
        return Thread.currentThread().getName() + "求出了1-" + n + "的和是：" + sum;
    }
}
```

再准备一个测试类，在测试类中创建线程池，并执行callable任务。

```java
public class ThreadPoolTest2 {
    public static void main(String[] args) throws Exception {
        // 1、通过ThreadPoolExecutor创建一个线程池对象。
        ExecutorService pool = new ThreadPoolExecutor(
            3,
            5,
            8,
            TimeUnit.SECONDS, 
            new ArrayBlockingQueue<>(4),
            Executors.defaultThreadFactory(),
            new ThreadPoolExecutor.CallerRunsPolicy());

        // 2、使用线程处理Callable任务。
        Future<String> f1 = pool.submit(new MyCallable(100));
        Future<String> f2 = pool.submit(new MyCallable(200));
        Future<String> f3 = pool.submit(new MyCallable(300));
        Future<String> f4 = pool.submit(new MyCallable(400));

        // 3、执行完Callable任务后，需要获取返回结果。
        System.out.println(f1.get());
        System.out.println(f2.get());
        System.out.println(f3.get());
        System.out.println(f4.get());
    }
}
```

##### Executors

线程池工具类（Executors）

有同学可能会觉得前面创建线程池的代码参数太多、记不住，有没有快捷的创建线程池的方法呢？有的。Java为开发者提供了一个创建线程池的工具类，叫做Executors，它提供了方法可以创建各种不能特点的线程池。如下图所示 

![image-20240314162940886](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314162940886.png) 

```java
// 1、通过Executors创建一个线程池对象。
ExecutorService pool = Executors.newFixedThreadPool(17);

// 计算密集型的任务：核心线程数量 = CPU的核数 + 1
// IO密集型的任务：核心线程数量 = CPU核数 * 2
```

Executors创建线程池这么好用，为什么不推荐同学们使用呢？原因在这里：看下图，这是《阿里巴巴Java开发手册》提供的强制规范要求。

![image-20240314163109093](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314163109093.png) 

### 18：IO流

#### 文件

**文件概念：**

![image-20240316111657696](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316111657696.png) 

**文件流：**

![image-20240316111724161](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316111724161.png) 

#### 文件操作

##### 创建文件对象

![image-20240316111835857](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316111835857.png) 

```java
//方式一
String filePath = "e:\\news1.txt";
File file = new File(filePath);
//方式二
File parentFile = new File("e:\\");
String fileName = "news2.txt";
File file = new File(parentFile, fileName);
//方式三
String parentPath = "e:\\";
String fileName = "news4.txt";
File file = new File(parentPath,fileName);

file.createNewFile();//如果路径没有该文件，就创建。
```

##### 获取文件的相关信息

![image-20240316112244798](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316112244798.png) 

```java
System.out.println("文件名字=" + file.getName());

System.out.println("文件绝对路径=" + file.getAbsolutePath());

System.out.println("文件父级目录=" + file.getParent();
                   
System.out.println("文件大小(字节)=" + file.length());
                   
System.out.println("文件是否存在=" + file.exists());
                   
System.out.println("是不是一个文件=" + file.isFile());
                   
System.out.println("是不是一个目录=" + file.isDirectory());               
```

##### 目录的操作

![image-20240316112526329](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316112526329.png) 

#### IO 流原理及流的分类

##### Java IO 流原理

![image-20240316112607182](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316112607182.png) 

##### 流的分类

![image-20240316112659411](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316112659411.png) 

#### IO 流体系

##### IO 流体系图

![image-20240316112809966](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316112809966.png) 

##### FileInputStream

```java
//单个字节的读取，效率比较低
String filePath = "e:\\hello.txt";
int readData = 0;
FileInputStream fileInputStream = null;

try {
    //创建 FileInputStream 对象，用于读取 文件
    fileInputStream = new FileInputStream(filePath);
    //从该输入流读取一个字节的数据。 如果没有输入可用，此方法将阻止,如果返回-1 , 表示读取完
    while ((readData = fileInputStream.read()) != -1) {
        System.out.print((char)readData);//转成 char 显示
    }
}catch (IOException e) {
	e.printStackTrace();
}finally {
    //关闭文件流，释放资源.
	fileInputStream.close();
}

//使用 read(byte[] b) 读取文件，提高效率
String filePath = "e:\\hello.txt";
byte[] buf = new byte[8]; //一次读取 8 个字节. 
int readLen = 0;
FileInputStream fileInputStream = null;
try {
    //创建 FileInputStream 对象，用于读取 文件
    fileInputStream = new FileInputStream(filePath);
    //从该输入流读取最多 b.length 字节的数据到字节数组。 此方法将阻塞，直到某些输入可用。
    //如果返回-1 , 表示读取完毕
    //如果读取正常, 返回实际读取的字节数
    while ((readLen = fileInputStream.read(buf)) != -1) {
        System.out.print(new String(buf, 0, readLen));//显示
}catch (IOException e) {
	e.printStackTrace();
} finally {
    //关闭文件流，释放资源.
	fileInputStream.close();
}
```

##### FileOutputStream

![image-20240316113714829](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316113714829.png) 

```java
String destFilePath = "e:\\Koala3.jpg";
FileOutputStream fileOutputStream = null;
fileOutputStream = new FileOutputStream(destFilePath);
fileOutputStream.write('1');//一定要使用这个方法
fileOutputStream.close();
```

##### FileReader

![image-20240316114128666](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316114128666.png) 

![image-20240316113955271](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316113955271.png) 

##### FileWriter

![image-20240316114023550](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316114023550.png) 

#### 节点流和处理(包装)流

##### 基本介绍

![image-20240316114208634](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316114208634.png) 

##### 节点流和处理流

![image-20240316114314030](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316114314030.png) 

##### 区别和联系

![image-20240316114510836](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316114510836.png) 

##### 处理流的功能

![image-20240316114643340](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316114643340.png) 

##### BufferedReader &&  BufferedWriter(缓冲流字符流)

![image-20240316114811847](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316114811847.png) 

```java
String filePath = "e:\\a.java";

//创建 bufferedReader
BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath));
String line; //按行读取, 效率高
//说明
//1. bufferedReader.readLine() 是按行读取文件
//2. 当返回 null 时，表示文件读取完
while ((line = bufferedReader.readLine()) != null) {
	System.out.println(line);
}

//关闭流, 这里注意，只需要关闭 BufferedReader ，因为底层会自动的去关闭 节点流
bufferedReader.close();
```

##### BufferedInputStream && BufferedOutputStream（缓冲流字节流）

![image-20240316115104758](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316115104758.png) 

![image-20240316115134437](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316115134437.png) 

```java
String srcFilePath = "e:\\a.java";
bis = new BufferedInputStream(new FileInputStream(srcFilePath));
byte[] buff = new byte[1024];
while ((readLen = bis.read(buff)) != -1) {}
```

##### ObjectInputStream && ObjectOutputStream（对象流）

###### 序列化和反序列化

![image-20240316115455946](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316115455946.png) 

![image-20240316115524224](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316115524224.png) 

###### 对象流介绍

功能：提供了对基本类型或对象类型的序列化和反序列化的方法 

ObjectOutputStream 提供 序列化功能 

ObjectInputStream 提供 反序列化功

![image-20240316115639687](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316115639687.png) 

```java
//序列化后，保存的文件格式，不是存文本，而是按照他的格式来保存
String filePath = "e:\\data.dat";
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath));

//序列化数据到 e:\data.dat
oos.writeInt(100);// int -> Integer (实现了 Serializable)
oos.writeBoolean(true);// boolean -> Boolean (实现了 Serializable)
oos.writeChar('a');// char -> Character (实现了 Serializable)
oos.writeDouble(9.5);// double -> Double (实现了 Serializable)
oos.writeUTF("韩顺平教育");//String
//保存一个 dog 对象
oos.writeObject(new Dog("旺财", 10, "日本","白色"));
oos.close();
```

```java
// 1.创建流对象
ObjectInputStream ois = new ObjectInputStream(new FileInputStream("src\\data.dat"));
// 2.读取， 注意顺序
System.out.println(ois.readInt());
System.out.println(ois.readBoolean());
System.out.println(ois.readChar());
System.out.println(ois.readDouble());
System.out.println(ois.readUTF());
System.out.println(ois.readObject());
System.out.println(ois.readObject());
System.out.println(ois.readObject());
// 3.关闭
ois.close();
```

###### 细节注意

![image-20240316115903209](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316115903209.png) 

##### InputStreamReader && OutputStreamWriter（转换流）

###### 标准输入输出流

![image-20240316120114468](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316120114468.png) 

###### 基本介绍

![image-20240316133551918](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316133551918.png) 

```java
String filePath = "e:\\a.txt";
//解读
//1. 把 FileInputStream 转成 InputStreamReader
//2. 指定编码 gbk
InputStreamReader isr = new InputStreamReader(new FileInputStream(filePath), "gbk");
//3. 把 InputStreamReader 传入 BufferedReader
BufferedReader br = new BufferedReader(isr);
//4. 读取
String s = br.readLine();
//5. 关闭外层流
br.close();

```

##### PrintStream  && PrintWriter（打印流）

![image-20240316133958542](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316133958542.png) 

![image-20240316134011666](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316134011666.png) 

```java
PrintStream out = System.out;
//在默认情况下，PrintStream 输出数据的位置是 标准输出，即显示器
out.print("john, hello");
//因为 print 底层使用的是 write , 所以我们可以直接调用 write 进行打印/输出
out.write("韩顺平,你好".getBytes());
out.close();

//我们可以去修改打印流输出的位置/设备
//1. 输出修改成到 "e:\\f1.txt"
//2. "hello, 韩顺平教育~" 就会输出到 e:\f1.tx
System.setOut(new PrintStream("e:\\f1.txt"));
System.out.println("hello, 韩顺平教育~");
printWriter.close();//flush + 关闭流, 才会将数据写入到文件.
```

#### Properties 类

##### 需求

![image-20240316134605350](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316134605350.png) 

![image-20240316134659565](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316134659565.png) 

##### 基本介绍

![image-20240316134743328](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316134743328.png) 

```java
//使用 Properties 类来读取 mysql.properties 文件

//1. 创建 Properties 对象
Properties properties = new Properties();
//2. 加载指定配置文件
properties.load(new FileReader("src\\mysql.properties"));
//3. 把 k-v 显示控制台
properties.list(System.out);
//4. 根据 key 获取对应的值
String user = properties.getProperty("user");
String pwd = properties.getProperty("pwd");
System.out.println("用户名=" + user);
System.out.println("密码是=" + pwd);
//5.注意保存时，是中文的 unicode 码值
properties.setProperty("user", "汤姆");
properties.setProperty("pwd", "888888");
//6.将 k-v 存储文件中即可
properties.store(new FileOutputStream("src\\mysql2.properties"), null);
```

#### 本章作业

![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316135123389.png) 









## JUnit

### 为什么需要 JUnit

![image-20240312191351768](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312191351768.png) 

### 基本介绍

![image-20240312191419196](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312191419196.png) 

```java
@Test
public void m1() {
	System.out.println("m1 方法被调用");
}

@Test
public void m2() {
	System.out.println("m2 方法被调用");
}
```

## IDE（集成开发环境）—IDEA

1. IDEA 全称 IntelliJ IDEA 
2. 在业界被公认为最好的 Java 开发工具 
3. IDEA 是 JetBrains 公司的产品，总部位于捷克的首都布拉格 
4. 除了支持 Java 开发，还支持 HTML，CSS，PHP，MySQL，Python 等

![image-20240301181316349](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301181316349.png) 

**版本：**IDEA 2020.2

### IDEA 常用快捷键

1. 删除当前行：默认是Ctrl + Y，改为**Ctrl + D**
2. 复制当前行：（搜索duplicate），改为**Ctrl + Alt + 向下箭头**
3. 代码补全：**Alt + /**
4. 添加注释和取消注释： **Ctrl + /** 
5. 导入该行需要的类：**Alt+Enter** 
6. 快速格式化代码： **Ctrl + Alt + L**
7. 快速运行程序：默认是Shift + F10 ，改为**Alt + R**
8. 生成构造器等：**Alt + Insert**
9. 查看一个类的层级关系： **Ctrl + H**
10. 将光标放在一个方法上，输入 **Ctrl + B** （或者**Ctrl + 鼠标左键**）, 可以定位到方法 
11. 自动的分配变量名 , 通过 在后面加 **.var** 
12. 自动的填写输出函数，通过后面加**.sout**
13. 查看快捷键的快捷键：**Ctrl + J**
14. 快速生成迭代器的while：**i t i t**
15. 增强for循环： **I（大写）**
16. 异常处理、同步代码块快捷键：**Ctrl + Alt + T**

### 自定义模板

![image-20240301183836222](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301183836222.png) 

### 断点调试

**断点调试介绍：**

![image-20240303090429018](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303090429018.png) 

**断点调试的快捷键：**

**F7(跳入)** 

**F8(跳过)** 

**shift+F8(跳出)** 

**F9(resume,执行到下一个断点)**

（断点可以在 debug 过程中，动态的下断点）

# **前端笔记**

## HTML

##### 描述：

用于定义网络结构的基本技术

##### 基本语法：

<开始标签>	内容	<结束标签>

![image-20240115105017529](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115105017529.png)

##### 标签：

+ ###### **分区div**

  div是一个纯粹的容器，<div>元素在语义上不表示任何特定类型的内容。然而，其可以将内容分组，从而可以使用**class**或是**id**属性方便的定义内容的格式。

+ ###### **标题h1~h6**

  HTML `<h1>`–`<h6>` 标题 (Heading) 元素呈现了六个不同的级别的标题，`<h1>` 级别最高，而 `<h6>` 级别最低。

+ ###### **段落p**

   **`<p>`** 元素表示文本的一个段落。段落是块级元素。

+ ###### **图像img**

  <img> 元素将一张图像嵌入文档

  ![image-20240115110304202](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115110304202.png) 

  - `src` 属性是**必须的**，它包含了你想嵌入的图片的路径。
  - `alt` 属性包含一条对图像的文本描述，这不是强制性的。如果由于某种原因无法加载图像，普通浏览器也会在页面上显示 `alt` 属性中的备用文本：例如，网络错误、内容被屏蔽或链接过期。

+ ###### **列表ul/ol**

  **`<ul>`** 元素表示一系列无序的列表项目，通常渲染为项目符号列表。

  ![image-20240115110519215](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115110519215.png) 

  **`<ol>` **元素表示有序列表，通常渲染为一个带编号的列表。

  ![image-20240115110655736](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115110655736.png) 

+ ###### **超链接a**

  <a> 元素（或称锚元素）可以通过它的 href 属性创建通向其他网页、文件、电子邮件地址、同一页面内的位置或任何其他 URL 的超链接。

  <a> 中的内容应该指明链接的目标。如果存在 href 属性，当 <a> 元素聚焦时按下回车键就会激活它。

  <a>中的href属性可以使用**文本片段**链接到某一段文字：这时点击a标签会直接跳转到相应的标签

  ![image-20240115111039304](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115111039304.png) 

+ ###### **表单form**

  **`<form>` 元素**表示文档中的一个区域，此区域包含交互控件，用于向 Web 服务器提交信息。

  ```html
  action:处理表单提交的 URL。这个值可被 <button>、<input type="submit"> 或 <input type="image"> 元素上的 formaction 属性覆盖。
  method:浏览器使用这种 HTTP 方式来提交 表单。可能的值有：
  	post：指的是 HTTP POST 方法；表单数据会包含在表单体内然后发送给服务器。
      get：指的是 HTTP GET 方法；表单数据会附加在 action 属性的 URL 中，并以 '?' 作为分隔符，没有副作用 时使用这个方法。
  <form action="" method="get" class="form-example">
    <div class="form-example">
      <label for="name">Enter your name: </label>
      <input type="text" name="name" id="name" required />
    </div>
    <div class="form-example">
      <label for="email">Enter your email: </label>
      <input type="email" name="email" id="email" required />
    </div>
    <div class="form-example">
      <input type="submit" value="Subscribe!" />
    </div>
  </form>
  ```

   ![image-20240115111322271](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115111322271.png)

+ ###### **表格table**

  **table**元素表示表格数据——即在一个由包含数据的行和列组成的二维表格中呈现的信息。

  ```html
  <table>
    <thead>
      <tr>
        <th colspan="2">The table header</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>The table body</td>
        <td>with two columns</td>
      </tr>
    </tbody>
  </table>
  ```

  ![image-20240115111909442](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115111909442.png) 

+ ###### **框架iframe**

​	**HTML 内联框架元素 (`<iframe>`)** ,它能够将另一个 HTML 页面嵌入到当前页面中。目前我还没有用到这个。

##### HTML5特性：

###### 语义化标签：

当接近要使用的标记时，问问自己，“什么元素最能描述/表示我要填充的数据？”例如，它是数据列表吗？有序或无序？是否是一篇具有章节和相关信息旁注的文章？它是否列出了定义？它是需要标题的图形还是图像？除了全局网站范围的页眉和页脚之外，它还应该有页眉和页脚吗？等等。

写语义标记的一些好处如下：

- 搜索引擎将其内容视为影响页面搜索排名的重要关键字。

- 比起搜索无休止的带有或不带有语义/命名空间类的 `div`，找到有意义的代码块显然容易得多。

- 语义命名反映了正确的自定义元素/组件命名。

- 常见的语义化元素

  ```html
  <article>
  <aside>
  <detiales>
  <figcaption>
  <figure>
  <footer>
  <header>
  <main>
  <mark>
  <nav>
  <section>
  <summary>
  <time>
  ```



## 前端基础知识

##### 互联网：

互联网（[internet](https://baike.baidu.com/item/internet/272794?fromModule=lemma_inlink)），又称国际网络，指的是[网络](https://baike.baidu.com/item/网络/143243?fromModule=lemma_inlink)与网络之间所串连成的庞大网络，这些网络以一组通用的[协议](https://baike.baidu.com/item/协议/13020269?fromModule=lemma_inlink)相连，形成逻辑上的单一巨大国际网络。

互联网始于1969年[美国](https://baike.baidu.com/item/美国/125486?fromModule=lemma_inlink)的[阿帕网](https://baike.baidu.com/item/阿帕网/1950726?fromModule=lemma_inlink)。通常[internet](https://baike.baidu.com/item/internet/272794?fromModule=lemma_inlink)泛指互联网，而Internet则特指[因特网](https://baike.baidu.com/item/因特网/114119?fromModule=lemma_inlink)。这种将[计算机网络](https://baike.baidu.com/item/计算机网络/18763?fromModule=lemma_inlink)互相联接在一起的方法可称作“网络互联”，在这基础上发展出覆盖全世界的全球性互联网络称互联网，即是互相连接一起的[网络结构](https://baike.baidu.com/item/网络结构/8259917?fromModule=lemma_inlink)。

##### 域名：

域名（英语：Domain Name），又称网域，是由一串用点分隔的名字组成的[互联网](https://baike.baidu.com/item/互联网/199186?fromModule=lemma_inlink)上某一台[计算机](https://baike.baidu.com/item/计算机/140338?fromModule=lemma_inlink)或计算机组的名称，用于在[数据传输](https://baike.baidu.com/item/数据传输/2987565?fromModule=lemma_inlink)时对计算机的定位标识（有时也指地理位置）。 [1]

由于[IP地址](https://baike.baidu.com/item/IP地址/150859?fromModule=lemma_inlink)不方便记忆并且不能显示地址组织的名称和性质，人们设计出了域名，并通过[域名系统](https://baike.baidu.com/item/域名系统/2251573?fromModule=lemma_inlink)（DNS，Domain Name System）来将域名和IP地址相互[映射](https://baike.baidu.com/item/映射/20402621?fromModule=lemma_inlink)，使人更方便地访问互联网，而不用去记住能够被机器直接读取的IP地址数串。

##### DNS：

DNS（Domain Name System）域名系统，是一个层次化、分散化的互联网连接资源命名系统。DNS 维护着一个[域名](https://developer.mozilla.org/zh-CN/docs/Glossary/Domain_name)列表以及与之相关联的资源（例如 IP 地址）。

DNS 最突出的功能是将易于记忆的域名（例如 mozilla.org）翻译成为数字化的 [IP 地址](https://developer.mozilla.org/zh-CN/docs/Glossary/IP_Address)（例如 151.106.5.172）；这一从域名到 IP 地址的映射过程被称为**DNS 查询**（DNS lookup）。与之对应，**DNS 反向查询**（rDNS）用来找到与 IP 地址对应的域名。

##### 服务器：

服务器是为用户（通常称为客户端）提供服务的软件或硬件。硬件而言的服务器是互联网上的共享计算机，通常性能强劲且位于数据中心。软件而言的服务器（一般是运行在硬件服务器上）是一种向客户端程序或向[用户界面](https://developer.mozilla.org/zh-CN/docs/Glossary/UI)提供服务的程序。

我们一般在局域网或广域网（如互联网）提供服务。传统上，客户端程序和服务器程序通过 [API](https://developer.mozilla.org/zh-CN/docs/Glossary/API) 传递信息进行连接，这种信息使用[协议](https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol)编码。

举个例子：

- 连接到互联网的 Web 服务器向你的浏览器发送一个 [HTML](https://developer.mozilla.org/zh-CN/docs/Glossary/HTML) 文件，这样你就可以浏览页面。
- 用于文件、域名、邮件、打印机和传真机的局域网服务器。
- 数据中心的小型机、大型机和超算。

##### 浏览器：

**浏览器**是一种从 [Web](https://developer.mozilla.org/zh-CN/docs/Glossary/World_Wide_Web) 获取和显示页面的程序，并且让用户通过[超链接](https://developer.mozilla.org/zh-CN/docs/Glossary/Hyperlink)访问更多页面。浏览器是最常见的一种用户代理。

###### DOM事件流：

DOM(文档对象模型)结构是一个树型结构，当一个[HTML元素](https://baike.baidu.com/item/HTML元素/5983313?fromModule=lemma_inlink)产生一个事件时，该事件会在元素节点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为DOM事件流。

DOM同时支持两种事件模型：[捕获型事件](https://baike.baidu.com/item/捕获型事件/0?fromModule=lemma_inlink)和[冒泡型事件](https://baike.baidu.com/item/冒泡型事件/7508003?fromModule=lemma_inlink)，但是，捕获型事件先发生，冒泡型事件后发生。两种事件流会触发DOM中的所有对象，从[document对象](https://baike.baidu.com/item/document对象/6553996?fromModule=lemma_inlink)开始，也在document对象结束。

![image-20240225131301937](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225131301937.png) 

###### 事件委托：

当冒泡和捕获同时存在时，事件触发顺序为：捕获->目标（small就是目标）->冒泡。事件委托，也叫事件代理，一般指的是利用事件冒泡，将一个或者一组DOM的事件处理程序，委托给其父级元素或者更外层元素。**可以通过只指定一个事件处理程序，就可以管理一批同类型的事件处理程序**。

例如：如果需要给列表项添加事件，当列表项数量过多时，会存在频繁操作DOM的情况；并且函数是引用类型, 需要堆内存来存储，占用大量空间。**通过事件委托，可以将事件绑定到其父级元素ul上，这样只需要操作一次DOM，不会引起频繁的重绘。**也不会占用大量的空间。

```html
<!-- 通过事件的具体属性实现通过事件委托也和直接绑定在li上一样的效果--><!DOCTYPE html>
<html lang="en">
<body>
  <ul id='father'>
    <li id="a">A</li>
    <li id="b">B</li>
    <li id="c">C</li>
    <li id="d">D</li>
  </ul>
  <script>
  father.addEventListener('click', function(e) {
    const event = e；
    const target = event.target；
    // 根据事件属性判断当前所在的DOM节点，不同节点处理不同的程序（主要通过e.target,在父节点上定义的事件，可以处理子节点）
    switch(target.id) {
      case "a":
        console.log('a');
        break;
      case "b":
        console.log('b');
        break;
      case "c":
        console.log("c");
        break;
      case "d":
        console.log("d");
        break;
      default:
        console.log('default');
    }
  })
  </script>
</body>
</html>
```

###### 浏览器加载顺序：

1. HTML解析完毕

2. 外部脚本和样式加载完毕

3. 脚本在文档内解析并执行

4. HTML DOM完全构造起来

5. 图片个外部内容加载

6. 网页完全加载

**1-4执行是很快的，5很慢**

###### 浏览器渲染过程：

渲染流程大致可以划分为五个过程：

1. 构建DOM

   <img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240121114811031.png" alt="image-20240121114811031" style="zoom:50%;" /> 

2. 构建CSSOM

   <img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240121114842031.png" alt="image-20240121114842031" style="zoom:50%;" /> 

3. 构建渲染（render）树

   ![image-20240121114959429](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240121114959429.png) 

4. 布局

   获取渲染树的结构，节点位置和大小，然后依据盒子模型来进行布局

5. 绘制

   把渲染树以像素的形式绘制在页面上

![image-20240121114521130](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240121114521130.png) 

**（如果构建DOM的过程中，碰见js，则下载js，如果js没有额外的设置则需要等到CSSOM构建完成后才能执行js文件，js既可以对DOM做修改，也可以对CSSOM做修改）**



##### HTTP：

HTTP（Hyper Text Transformer Protocol，超文本传输协议）是一种通信协议，它允许将超文本标记语言（HTML）文档从Web服务器传送到客户端的浏览器。

它是一个应用层协议，承载于TCP协议之上。

###### HTTP1.0

HTTP/1.0是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。默认采用短连接。

HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。这种无状态性可以借助cookie/session机制来做身份认证和状态记录。

缺点，无连接的特性导致最大的性能缺陷就是无法复用连接。每次发送请求的时候，都需要进行一次TCP的连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率非常低。

###### HTTP1.1

HTTP/1.1版本，持久连接/长连接被默认采用（默认模式使用带流水线的持久连接），并能很好地配合代理服务器工作，还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。

###### HTTP请求方法

1. GET

   请求指定的页面信息，并返回实体主体。

   注：GET也可以将数据提交到服务器，不过一般都是使用POST提交数据到服务器.

2. POST

   POST请求方法的作用：向服务器发送数据。

   POST和GET请求方法的本质区别：

   ​    1、GET用于信息获取，它是安全的（这里安全的含义是指非修改信息），而POST是用于修改服务器上资源的请求；

   ​    2、GET请求的数据会附在URL之后（然后提交到服务器），而POST把提交的数据则放置在HTTP实体的主体里，所以，POST的安全性要比GET的安全性高；

   ​    3、GET方式提交数据和POST方法提交数据并没有限制数据大小。

3. HEAD

   HEAD请求方法作用：只请求头部，允许客户端在未获取资源实体的情况下，对资源的头部检查，了解资源的基本情况，比如类型，是否被修改过等。

   HEAD和GET请求方法的区别：GET请求回来的报文有实体的主体部分，而HEAD请求回来的报文没有实体的主体部分。

###### 状态码

2xx 成功

3xx 重定向

4xx 客户端报错

5xx 服务端报错

###### Cookie

是某些网站为了辨别用户身份，进行[Session](https://baike.baidu.com/item/Session/479100?fromModule=lemma_inlink)跟踪而储存在用户本地终端上的数据（通常经过加密），由用户[客户端](https://baike.baidu.com/item/客户端/101081?fromModule=lemma_inlink)计算机暂时或永久保存的[信息](https://baike.baidu.com/item/信息/111163?fromModule=lemma_inlink) 。

###### HTTPS

HTTPS （全称：Hypertext Transfer Protocol Secure [5]），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和[身份认证](https://baike.baidu.com/item/身份认证/5294713?fromModule=lemma_inlink)保证了传输过程的安全性 。HTTPS 在HTTP 的基础下加入[SSL](https://baike.baidu.com/item/SSL/320778?fromModule=lemma_inlink)，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。

## Git

#### git基础命令笔记：

git remote -v查看配置了的远程连接的名称

git remote add origin https://github.com/RJrowlling/ExerciseProject.git 配置远程连接，连接本地仓库和远程仓库

git remote rm origin 删除配置了的远程连接



git branch 查看分支名称

git branch issue1 新建分支

git branch -d issue1 删除分支

git checkout mian 切换分支



git add README.md 将READNE.md文件添加到索引暂存区

git commit -m "将暂存区里的索引同步到本地数据库上，并设置了message"

git push origin main 将本地仓库的数据推送到远程仓库的main分支中



git revert HEAD撤消上一次提交的更改。

1. 注意这里只是从本地仓库中还原了上一次提交的更改，如果你已经push到远程仓库，则远程仓库不变，除非你再次push
2. Git revert 命令将一个提交作为参数，并**创建一个新的提交来撤消该提交所做的更改**。

#### 把本地项目上传到github上出现了问题？

![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240127160257601.png) 

![image-20240127160239654](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240127160239654.png) 

##### 1. 没有在github上面关联公钥

基础的内容已经配置好了（用户名，电子邮箱，本地钥匙都有），首先进入C:\Users\cjy\\.ssh目录文件下找到id_rsa.pub公钥，打开记事本复制内容到下图（配置好后，github会给你发电子邮件）

![image-20240127160036193](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240127160036193.png) 

##### 2.网络连接问题

ping github.com时，会显示超时，这就是网络连接问题。通过ip查询https://ipaddress.com/website/github.com找到github.com的ip地址，例如（140.82.113.4）

![image-20240127160751778](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240127160751778.png)

此时修改本地 DNS 文件 C:\Windows\System32\drivers\etc 目录下的 hosts 文件，由于该文件在 C 盘中，无法直接打开进行修改，需要使用管理员权限，此处操作方式为，搜索 记事本 软件，右键以管理员身份运行，选择上述 hosts 文件打开，在文件内容最下方加入一行

```
140.82.113.4    github.com
```

## Node.js

定义：node.js是一个开源的，跨平台的JavaScript运行环境

安装：https://blog.csdn.net/zxy15974062965/article/details/121117803

### 包管理工具

包：package，代表了一组功能的源码集合

包管理工具：管理【包】的应用软件，进行下载安装、更新、删除操作

#### npm

npm全称node package Manage【node的包管理工具】

npm是node.js官方**内置的**包管理工具

##### npm 全局安装 ：

```
npm i -g <包名>

npm root -g
```

全局安装的命令不受工作目录位置的影响，**而且安装的位置不是在当前工作目录的node_module，而是在全局安装包的位置**，可以通过**npm root -g** 可以查看全局安装包的位置；而且并不是所有包都适合全局安装。

##### **windows会对全局安装的脚本进行约束，不让它运行？**

可以通过修改windows的执行策略来解决这个问题，具体：输入：set-ExecutionPolicy remoteSigned

![image-20240201094202340](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240201094202340.png)

##### **npm 安装所有依赖**：

```
npm i
npm install
```

通过该命令可以依据package.json和package-lock.json的依赖声明，安装项目所有依赖（**node-modules文件夹大多数情况是不会存入版本库的**），只有安装完所有依赖才能够正常启动项目

##### 安装指定版本的包：

```
npm i <包名@版本号>
例子：
npm i jquery@1.11.2
```

##### 删除依赖：

```
局部删除：
npm remove unip
全局删除：
npm remove -g nodemon
```

##### npm 配置命名别名：

可以通过命名别名可以更简单的执行命令，具体来说，配置package.json中的scripts属性

![image-20240201100222985](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240201100222985.png)

##### cnpm：

cnpm是淘宝构建的npmjs.com的完整镜像，也称为**淘宝镜像**，cnpm服务部署在国内阿里云服务器上，可以提高包的下载速度。

**淘宝镜像源官网：**https://www.npmmirror.com/，这里可以获得第一手的镜像网站

**官方也提供了一个全局工具包cnpm**（不是内置的），操作命令与npm大体相同。

**安装cnpm：**

```
npm install -g cnpm --registry=https://registry.npmmirror.com
```

##### npm配置淘宝镜像：

npm 也可以使用淘宝镜像源，直接配置：



```
 npm config set registry https://registry.npmmirror.com

在配置之前，先 npm config list查看，并保存一下原来的registry，方便后面改回来
"https://registry.npmjs.org/"这是npm原有的数源
```

**使用了淘宝镜像源之后，就不要搭梯子了，关掉梯子，yarn才能正常运行。**

#### Yarn

介绍：yarn是由Facebook推出的JavaScript包管理工具

特点：速度超快，会缓存包，所以下次下载无需重复下载。并行下载

安装：

```
npm i -g yarn
```

##### yarn常用命令

![image-20240201103854636](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240201103854636.png)

##### yarn全局安装

查询 yarn 安装依赖的全局路径 

```
yarn global bin
```

修改 yarn 全局 bin 位置 ，这个就是yarn之后安装全局依赖的位置，**但是注意，要修改环境变量，才能使yarn全局安装的包正常运行**

```
yarn config set prefix "D:\nodejs\node_modules\yarn\bin"
```

##### yarn配置淘宝镜像

```
yarn config set registry https://registry.npmmirror.com

在配置之前，先 yarn config list查看，并保存一下原来的registry，方便后面改回来
```

**使用了淘宝镜像源之后，就不要搭梯子了，关掉梯子，yarn才能正常运行。**

## React



## VScode使用

##### VScode怎么运行js文件？

+ **使用内置终端**

  首先，我们需要打开一个JS文件，然后按下“Ctrl+Shift+`”键，打开终端界面，可以在其中输入“**node 文件名.js**”命令来运行JS文件。

+ **使用Code Runner插件**

​	安装Code Runner插件，打开一个JS文件，然后按下**“Ctrl+Alt+N”键**，Code Runner会自动运行当前打开的JS文件，并在底部显示输出结果。

+ **使用Live Server插件**

​	在VSCode中安装Live Server插件，打开一个HTML文件，然后按下**“Alt+L”键**，此时，Live Server会自动启动一个本地服务器，并在浏览器中打开我们的HTML文件。如果HTML文件中引用了JS文件，Live Server也会自动运行这些JS文件。

##### VScode怎样调试js文件？

1. 首先要加断点

   ![image-20240117163505090](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117163505090.png) 

2. 点击JavaScript调试终端

   ![image-20240117163526777](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117163526777.png) 

3. 在终端里面输入node 文件名.js，回车

​	![image-20240117163613470](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117163613470.png) 

4. 在左侧进行调试

​	<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117163831404.png" alt="image-20240117163831404" style="zoom:50%;" /> 

# 项目笔记 

### 留言板项目：

![image-20240126133325443](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240126133325443.png)

1、在设置点赞的时候，你要用到<button onclick="点赞函数（this）">，这里面的this就是button按钮本身，通过**this.parentNode**,来访问到父级的容器节点，通过在**父级的容器节点.querySelect("点赞数")**，来获取到点赞按钮对应的点赞数。

2、设置了每一次在刷新或是发布评论时，随机更换头像。

### todolist项目：

要求：用前端三件套去实现todolist的基本功能，并结合git实现版本管理

成果图：

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E6%88%90%E6%9E%9C1.png" alt="image-20240128113121971" style="zoom: 80%;" /> 

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E6%88%90%E6%9E%9C2.png" alt="image-20240128113225760" style="zoom:80%;" /> 

心得：

1. 对于每一项任务的删除或完成操作，借鉴了留言板项目的点赞功能，通过this.parentNode找到父级容器，然后运用node.remove()操作进行删除操作
2. 批量操作师根据复选框的checked属性进行if判断的，勾选则checked属性为true，用forEach进行批量操作
3. 不完善的点，每一次计算待办任务和已完成任务的数量，都要重新计算类数组的长度，我觉得可以用监听来实现这一点，只要类数组的长度有变化，就会立即更新待办任务和已完成任务的数量，而不用在每一个需要删除和完成操作的函数最后面进行更新

### 用户中心项目：

完整了解做项目的思路，接触一些企业级的开发技术（尽量少写代码）

#### 企业做项目流程

需求分析=>设计（概要设计，详细设计）=> 技术选型=>初始化项目/引入需要的技术=>写Demo=>写代码（实现业务逻辑）=>测试（单元测试）=>代码提交/代码评审=>部署=>发布

#### 需求分析

1. 登录/注册

2. 数据库设计：

   id（主键）bigint

   username 昵称 varchar

   userAccount 登录账号 

   avatarUrl 头像 varchar

   gender 性别 tinyint

   userPassword 密码 varchar

   phone 电话 varchar

   email 邮箱 varchar

   isValid 是否有效 (比如被封号)tinyint 0 1

   ------

   createTime 创建时间（数据插入时间）datetime

   updateTime 更新时间（数据更新时间）datetime

   isDelete 是否删除0 1（逻辑删除）tinyint

3. 用户管理（仅管理员可见）对用户的查询、修改

4. 用户校验（仅星球用户）

   

   

#### 技术选型

前端：三件套+React+组件库Ant Design+Umi+Ant Design Pro（现成的管理系统）

后端：java + spring + springmvc + mybatis + mybatis-plus+springboot+mysql

部署：服务器+容器（平台）

#### 计划

1. 初始化项目
   1. 前端初始化
      1. 初始化项目
      2. 引入一些组件
      3. 框架介绍/项目瘦身
   2. 后端初始化
      1. 准备环境（MySql之类的）
      2. 引入框架（整合框架）
2. 登录/注册
   1. 前端
   2. 后端
3. 用户管理（仅管理员可见）
   1. 前端
   2. 后端

#### 注册逻辑

1. 用户在前端输入账号和密码，以及校验码
2. 校验用户的账户、密码、验证密码是否符合要求
   1. 非空
   2. 账户的话**不小于**4位
   3. 密码**不小于**8位
   4. 账户不能重复
   5. 账户不包含特殊字符
   6. 密码和验证密码相同
3. 对密码进行加密（密码千万不能直接以明文储存到数据库中）
4. 向数据库插入用户数据

#### 登录接口

接受参数： 用户账户、密码

请求类型：POST

请求体：JSON格式的数据

> 请求参数很长时，不建议用get

返回值：用户信息（**脱敏**） 

#### 登录逻辑

1. 校验用户账户密码是否合法 
   1. 非空
   2. 账户的话**不小于**4位
   3. 密码**不小于**8位
   4. 账户不包含特殊字符
2. 校验密码是否输入正确，要和数据库中的密文密码去比对
3. 返回用户信息（脱敏），隐藏敏感信息，防止数据库中的字段泄露
4. 记录用户的登录态（session），将其存到服务器上（用后端springboot框架封装的服务器tomcat去记录）
5. 返回脱敏后的用户信息

#### 用户管理接口

！！！必须鉴权

1. 查询用户
   1. 允许根据用户名查询
2. 删除用户

#### 如何知道那个用户登录了？（javaweb）

1. 连接服务器端后，得到一个session状态（匿名会话），返回给前端

2. 登陆成功后，得到一个登录成功的session，并给该session设置一些值，比如说用户信息，返回给前端一个设置cookie的命令。

   **session => cookie **

3. 前端接受到后端命令后，奢姿cookie，保存到浏览器内

4. 前端再次请求后端的时候（相同的域名），在请求头带上cookie去请求

5. 后端拿到前端传来的cookie，找到对应的session

6. 后端从session中可以取出基于该session存储的变量（用户的登录信息、登录名）


#### 前后端交互

前端需要向后端发送请求

前端ajax来请求后端

axious封装了ajax

request是ant design项目有封装了一次

#### 代理

正向代理：替客户端向服务器发送请求，

反向代理：替服务器接受请求，

怎么搞代理？

Nginx服务器

node.js服务器

![image-20240207144306714](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240207144306714.png)

#### 问题解决：

1. 前端初始化，在使用官网命令时，没有umi3选项？

   在cmd输入yarn global add create-umi@0.27.0，建个myapp文件夹，在这个文件夹的cmd下输入create-umi。如果在输入create-umi显示是外部命令（这是yarn的小毛病，yarn全局安装的包确实用不了），需要先**yarn global bin**找到yarn的bin目录，然后再把此目录添加进环境变量。

   总结：没有使用官方的命令，而是通过全局下载的create-umi



2. 前端初始化，yarn global add create-umi@0.27.0网络一直ping不通报？

   yarn和npm一样都可以配置淘宝镜像源，配置之后可以通过yarn config list检查。配置成功之后要关掉梯子。



3. 后端初始化，在配置java版本时，最低也只能到java17版本，需要java8？

   原因是springboot官方停止了对springboot2的维护，解决办法就是在IDEA里更改Server URL即可，用阿里云的镜像。

![image-20240202090502436](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240202090502436.png)

4. 连接数据库时，mysql连接不了，经过查找发现是Mysql服务无法启动的问题？

![image-20240202094357389](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240202094357389.png)

![image-20240202100104008](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240202100104008.png) 

直接专业卸载

5. 打开金师播放器后，复制粘连键用不了了？

   win + r 打开命令框，输入 cmd.exe /c echo off | clip （每次打开播放器观看都需要输入）

### 零钱通项目：

 使用 Java 开发 零钱通项目 , 完成收益入账，消费，查看明细，退出系统等功能。面向过程编程、面向对象编程两种方式

![image-20240303110648477](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303110648477.png) 

### 房屋出租系统

实现基于文本界面的《房屋出租软件》。

 能够实现对房屋信息的添加、修改和删除（用数组实现），并能够打印房屋明细表

![image-20240303164142160](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303164142160.png) 

![image-20240303164216502](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303164216502.png) 

**退出系统**

![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303164243311.png) 

**设计分析**

![image-20240303165520739](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303165520739.png) 

# 算法笔记

## 数组专项

### 二分查找

二分查找是先找到一个区间的中间位置middle，和某个target进行比较，可能这个middle就是target；也可能target大于middle，说明target是在左区间，反之target则在右区间，然后循环。

首先要想到一个while循环，循环条件是left和right比大小。其次，也是难点，**要根据区间的分类进行写代码，不同的区间，代码的形式不一样**。区间一般来讲，分为**左闭右闭**，和**左闭右开**。

#### **左闭右闭**

1. left等于0，right等于**arr.length-1**，因为是右闭，**如果right等于arr.length就说明arr.length在我们的范围区间里面**，而这是错误的

2. while的循环条件是(**left <= right**)，因为是左闭右闭，所以存在left等于right的情况，例如：[1,1]这是合理的区间

3. 当arr[middle] > target，说明target在左区间，left不需要改变，但是right需要改变，**此时right等于middle - 1**，**因为是右闭，已经明确得知arr[middle] > target的情况下，说明middle索引的数不等于target，middle不在范围区间里面，所以要middle - 1**

4. 当arr[middle] < target，说明target在右区间，right不需要改变，但是left需要改变，**此时left等于middle + 1**，原因同3

   ```java
   public static int search1(int[] nums, int target) {
           int right = nums.length - 1;
           int left = 0;
           int middle;
           while (left <= right) {
               middle = (left+right) / 2;
               if (nums[middle] > target) {
                   right = middle - 1;
                   continue;
               }
               if (nums[middle] < target) {
                   left = middle + 1;
                   continue;
               }
               return middle;
           }
           return -1;
       }
   ```

#### **左闭右开**

1. left等于0，right等于**arr.length**，因为是右开，**right等于arr.length这个范围区间本来就不包含arr.length这个索引**

2. while的循环条件是(**left < right**)，因为是左闭右开，不存在left等于right的情况，例如：[1,1）这是不合理的区间

```java
 public static int search2(int[] nums, int target) {
        int right = nums.length;
        int left = 0;
        int middle;
        while (left < right) {
            middle = (left+right) / 2;
            if (nums[middle] > target) {
                right = middle;
                continue;
            }
            if (nums[middle] < target) {
                left = middle + 1;
                continue;
            }
            return middle;
        }
        return -1;
    }
```

#### 总结

不管是左闭右闭也好，还是左闭右开也好，当你确定了一个区间分类后，在以后的代码分析中就要坚持这个想法，明确边界的范围。

### 移除元素

这个要求原地移除所有等于Val的数值，并返回新数组的长度。我们知道数组是不能拓展它自身的，除非嫁接到一个新的数组，而题目要求在原地进行操作。所以我们提出来**双指针的算法**来解决这一题。

**双指针算法**：

一个快指针（fast），一个慢指针（slow），它们的作用是：fast指针是通过遍历找到**不等于Val**的索引（这是要删除的，这是不满足新数组的数值），slow指针是在原地把**符合新数组的数值（fast找到的）**拷贝过来，fast指针和slow指针是在同一个数组里面，只是作用不一样。而且最后我们可以发现slow指针所指向的索引是新数组的长度。

```java
public static int removeElement(int[] nums, int val) {
    int slow = 0;
    for (int fast = 0; fast < nums.length; fast++) {
        if (nums[fast] != val) {
            nums[slow] = nums[fast];
            slow++;
        }
    }
    return slow;
}
```

### 有序数组平方

这个题我先开始是用平方，后用冒泡排序做的，但是发现时间复杂度太高，平方哪里遍历了一次所有的数组，然后再是冒泡排序，时间开销很大。

后面，有一种双指针的算法，可以极大的节省时间开销。而且这个题目也很有特点：它是要比较平方之后的大小，**那么越靠近两边的数，平方之后就越大**，因为可能有负数，而中间的数平方之后最小。那么就可以**设计一种双指针，一个指针指向头，一个指针指向尾，然后两个指针平方之后比大小,大的就存放进新数组**，然后进行相应的数据处理。

```java
//双指针的思路，时间复杂度低，但是多用了一个result数组 
public static int[] sortedSquares (int[] nums) {
        int[] result = new int[nums.length];
        int k = nums.length - 1;
        for (int i = 0,j = nums.length - 1; i <= j; ) {
            if (nums[i]*nums[i] > nums[j]*nums[j]) {
                result[k--] = nums[i]*nums[i];
                i++; //i要加一，而j不变，可以看到i和j不因循环次数而改变，只有相应的条件到达才能改变i，j的值
            } else {
                result[k--] = nums[j]*nums[j];
                j--;
            }
        }
        return result;
}
```

```java
//先平方，后用冒泡排序，时间复杂度高，但是是原地排序
public static int[] sortedSquares1 (int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        nums[i] = nums[i] * nums[i];
    }
    for (int i = 0; i < nums.length - 1; i++) {
        for (int j = 0; j < nums.length - 1 - i; j++) {
            if (nums[j] > nums[j+1]) {
                int temp = nums[j];
                nums[j] = nums[j+1];
                nums[j+1] = temp;
            }
        }
    }
    return nums;
}
```

### 长度最小的子数组

先开始想错了，以为可以先排序好，然后从头开始遍历找到最短的子数组满足target。题目要求数组不能动，你要在不懂原数组的基础上面，找到最小的大于等于target的子数组。

可以考虑用到滑动窗口的算法解。滑动窗口首先就要想到两个指针，滑动的区间就是这两个指针之间的区域，问题是怎么滑动这个区间。

首先，一个j指针，从头到尾开始移动，j指针移动到某个条件时，i指针开始滑动。这个条件就是当滑动区间的sum刚好大于或等于target的时候，进入到i指针的动作，i指针会向前移动一位，sum会减小，而且还要比较result和当前滑动区间的长度谁更小。

```java
public static int lengthOfLongestSubstring(int[] nums, int target) {
        int i = 0;
        int sum = 0;
        int result = nums.length;
        for (int j = 0; j < nums.length; j++) {
            sum += nums[j];
            while (sum >= target) { //这里是while而不是if，因为i有可能连续滑动(1,1,1,1,100),target=100
                sum -= nums[i];
                result = Math.min((j-i+1), result);
                i++;
            }
        }
        if (i == 0) {//i==0，说明for循环根本没有进入到while循环里面去，说明一直到滑动完，整个滑动区间的长度都没有大于target的情况
            return 0;
        }
        return result;
    }
}
```

### 螺旋矩阵

这一题是采用模拟的做法做出来的，模拟这个旋转矩阵。

首先就是要确定这个螺旋矩阵，我们模拟旋转的话，会转多少圈？答案是n / 2圈，但是当n为奇数时，我们单独处理中间的位置。

其次，我们要确定走的边的规则是什么，我的规则是左闭右开，那么就应该在4个for循环中都遵循左闭右开原则。

最后注意边界位置。

![image-20240312210028972](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312210028972.png) 

```java
public int[][]  generateMatrix(int n) {
        int[][] matrix = new int[n][n];
        int startX = 0;
        int startY = 0;
        int offset = 1;
        int count = 1;

        int circle = n / 2;
        while(circle-- > 0) {
            for (int j = startY; j < n - offset; j++) {
                matrix[startX][j] = count++;
            }
            for (int i = startX; i < n - offset; i++) {
                matrix[i][n - offset] = count++;
            }
            for (int j = n - offset; j > startY; j--) {
                matrix[n - offset][j] = count++;
            }
            for (int i = n - offset; i > startX; i--) {
                matrix[i][startY] = count++;
            }
            startX++;
            startY++;
            offset++;
        }
        if(n % 2 == 1) {
            matrix[n/2][n/2] = n * n;
        }
        return matrix;
}
```

## 链表专项

### 移除链表元素

#### 原链表删除元素

移除链表元素有两种解法，我采用的原链表删除元素。这里就要考虑到头节点的删除和头结点之外的删除是不一样的。

删除头结点：如果头结点的val满足条件，那么就将head指针移向下一个节点即可；

删除非头结点：先把head指针赋值给current指针，当current.next.val满足条件时，则将current.next 指向current.next.next以此来达到删除的目的

注意，两个都要保证节点部位空。

```java
 public ListNode removeElements(ListNode head, int val) {
        while (head != null && head.val == val) {
            head = head.next;
        }
        ListNode current = head;

        while (current != null && current.next != null) {
            if (current.next.val == val) {
                current.next = current.next.next;
            }
            else {
                current = current.next;
            }

        }
        return head;
 }
```

#### 虚拟头结点删除元素

采用虚拟头结点删除元素可以统一代码形式，而采用原链表删除元素的会有头结点和非头结点的区分。

首先就是要定义一个虚拟头结点，ListNode dummyHead = new ListNode(0,head);

然后就是，定义一个当前节点current，注意，是指向虚拟头结点，而不是虚拟头结点的next，因为头结点也可能被删除；

然后，while循环的条件是，current.next != null，说明还没有遍历到最后一个元素

最后返回的是虚拟头结点的next，而不是head，因为head有可能被删除，就是说链表一个元素都没有，都被删除了，如果此时返回head，那就剩head这个节点。

```java
//虚拟头结点删除元素
    public ListNode removeElements2(ListNode head, int val) {
        ListNode dummyHead = new ListNode(0,head); //先定义一个虚拟头结点
        ListNode current = dummyHead;
        while (current.next != null) {
            if (current.next.val == val) {
                current.next = current.next.next;
            } else {
                current = current.next;
            }
        }
        return dummyHead.next;
}
```

```java
//链表结构
class ListNode {
      int val;
      ListNode next;
      ListNode() {}
      ListNode(int val) { this.val = val; }
      ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}
```

### 设计链表

这题首先要想到用一个**虚拟头结点**来代表整个链表，这样设计的代码结构清晰，逻辑清楚，注意这时候可以只用虚拟头结点，而不需要在使用head指针。至于说，为什么统一，可以看代码，统一了头结点和非头结点的操作。

其次，要想到在这个链表类中，定义一个内部类Node，这样就可以很好的区分LinkedList类，虽然这两个类本质上没有什么区别，但是逻辑上给人很清晰的感觉。

注意，要定义一个全局的size，这样就可以在增删改查时，利用size快速索引出对应的index

```java
public class MyLinkedList {
    class Node {
        int val;
        Node next;
        public Node(int val) {
            this.val = val;
            this.next = null;
        }
    }

    int size;
    Node dummyHead;

    public MyLinkedList() {
        size = 0;
        dummyHead = new Node(0);
    }

    public int get(int index) {
        if (index<0 || index >= size) {
            return -1;
        }

        Node current = dummyHead;
        int i = 0;
        while (true) {
            if (index == i) {
                return current.next.val;
            }
            i++;
            current = current.next;
        }
    }

    public void addAtHead(int val) {
        Node node = new Node(val);
        node.next = dummyHead.next;
        dummyHead.next = node;
        size++;
    }

    public void addAtTail(int val) {
        Node node = new Node(val);

        Node current = dummyHead;
        while (current.next != null) {
            current = current.next;
        }
        current.next = node;
        size++;
    }

    public void addAtIndex(int index, int val) {
        if (index<0 || index >size ) {
            return;
        }
        if (index == size) {
            addAtTail(val);
            return;
        }

        Node node = new Node(val);
        Node current = dummyHead;
        int i = 0;
        while (true) {
            if (i == index) {
                node.next = current.next;
                current.next = node;
                size++;
                return;
            }
            current = current.next;
            i++;
        }
    }

    public void deleteAtIndex(int index) {
        if (index<0 || index >= size) {
            return;
        }
        Node current = dummyHead;
        int i = 0;
        while (true) {
            if (index == i) {
                current.next = current.next.next;
                size--;
                return;
            }
            i++;
            current = current.next;
        }
    }
}

class MyLinkedListTest {
    public static void main(String[] args) {
        MyLinkedList myLinkedList = new MyLinkedList();
        myLinkedList.addAtHead(5);
        myLinkedList.addAtIndex(1, 2);
        myLinkedList.get(1);
        myLinkedList.addAtHead(6);
        myLinkedList.addAtTail(2);
        myLinkedList.get(3);
        myLinkedList.addAtTail(1);
        myLinkedList.get(5);
        myLinkedList.addAtHead(2);
        myLinkedList.get(2);
        myLinkedList.addAtHead(6);
    }
}
```

