# 后端笔记

## java SE

### 02：Java概述

#### Java 重要特点

1. Java 语言是面向对象的(oop)

2. Java 语言是健壮的。Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证
3. Java 语言是跨平台性的。[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台]

3) Java 语言是解释型的[了解] 。

   解释性语言：javascript,PHP, java 

   编译性语言: c / c++ 

   区别是：解释性语言，编译后的代码，不能直接被机器执行,需要解释器来执行, 编译性语言, 编译后的代码, 可以直接被机器执行, c /c+

#### 什么是 JDK，JRE，JVM

1. JDK 的全称（Java Development Kit） Java 开发工具包。JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独 安装 JRE 了。

   **JDK = JRE + java 的开发工具** [java, javac,javadoc,javap 等]

2. JRE的全称（Java Runtime Environment） Java 运行环境。包括 Java 虚拟机(**JVM** Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序， 计算机中只需要安装 JRE 即可。

   **JRE = JVM +Java 的核心类库**

####  Java 开发注意事项和细节说明

![image-20240224162718902](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240224162718902.png)

####  Java 转义字符

![image-20240224162905093](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240224162905093.png)

#### 注释(comment)

用于注解说明解释程序的文字就是注释，注释提高了代码的阅读性（可读性）；注释是一个程序员必须要具有的良 好编程习惯。将自己的思想通过注释先整理出来，再用代码去体现。

```java
//单行注释

/*
多行注释

多行注释
*/

/**
	*文档注释
	*author 陈俊宇
	*version 1.0
	*	
	*见下图
*/
```

![image-20240224163254806](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240224163254806.png)

####  Java 代码规范

![image-20240224163415535](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240224163415535.png)

#### Java编写步骤

1. 编写java的源代码

2. javac编译，得到对应的.class字节码文件

3. java运行，本质就是把.class加载到JVM运行

#### 本章作业

![image-20240224163527124](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240224163527124.png)

### 03：变量

#### 概念

变量相当于内存中一个数据存储空间的表示，你可以把变量看做是一个房间的门牌号，通过门牌号我们可以找到房间，而通过变量名可以访问到变量(值)

**变量 = 变量名 + 值 + 数据类型**

#### 程序中 +号的使用

1. 当左右两边都是数值型时，则做加法运算

2. 当左右两边有一方为字符串,则做拼接运算

![image-20240225113717741](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225113717741.png)

#### 数据类型

每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间(字节)。

![image-20240225145443035](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225145443035.png)

 基本数据类型有 8 中 数值型 byte , short , int , long , float ,double，char , boolean；引用类型有三种：类，接口， 数组。

##### 整型

Java 的整数类型就是用于存放整数值的，比如 12 , 30, 3456 等等。

![image-20240225145649044](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225145649044.png) 

![image-20240225145807635](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225145807635.png) 

**注意：byte a = 10;**

**看似是将默认的int类型转换成了更小的byte类型应该会报错，但是表达式是正确的。因为这里程序所做的事是：判断10这个值是否在-128~127之间，根据这个来看是否符合要求，注意：这里的10一定是一个具体的值，而不能是变量，或者是大于这个范围的值。short类型同样适用。**

##### 浮点型

Java 的浮点类型可以表示一个小数，比如 123.4 ，7.8 ，0.12 等等。

![image-20240225145919616](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225145919616.png) 

![image-20240225150023292](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150023292.png) 

##### 字符型

字符类型可以表示单个字符,字符类型是 char，char 是两个字节(可以存放汉字)，多个字符我们用字符串 String。

![image-20240225150238229](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150238229.png) 

![image-20240225150345863](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150345863.png) 

##### 布尔型

![image-20240225150439440](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150439440.png) 

#### 基本数据类型转换

##### 自动类型转换

![image-20240225150544626](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150544626.png) 

![image-20240225150650565](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150650565.png) 

##### 强制类型转换

自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符 ( )，但可能造成
精度降低或溢出,格外要注意。

![image-20240225150803240](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150803240.png) 

![image-20240225150850098](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150850098.png) 

#### 基本数据类型和 String 类型的转换

![image-20240225151001328](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225151001328.png) 

1. 在将 String 类型转成 基本数据类型时， 要确保String类型能够转成有效的数据，比如 我们可以把 "123" , 转成一个整数，但是不能把 "hello" 转成一个整数

2. 如果格式不正确，就会抛出异常，程序就会终止，

#### 本章作业

![image-20240225151148714](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225151148714.png)

### 04：运算符

运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等

#### 算术运算符

算术运算符是对数值类型的变量进行运算的，在 Java 程序中使用的非常多

![image-20240227145701670](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227145701670.png)

![image-20240227145728090](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227145728090.png)

![image-20240227145749356](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227145749356.png)

#### 比较运算符

关系运算符的结果都是 boolean 型，也就是要么是 true，要么是 false

![image-20240227145853553](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227145853553.png)

关系运算符组成的表达式，我们称为**关系表达式**。 a > b

#### 逻辑运算符

用于连接多个条件（多个关系表达式），最终的结果也是一个 boolean 

![image-20240227150124179](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227150124179.png)

1. **a&b** : & 叫**逻辑与**：规则：当 a 和 b 同时为 true ,则结果为 true, 否则为 false 

2. **a&&b** : && 叫**短路与**：规则：当 a 和 b 同时为 true ,则结果为 true,否则为 false 

3. **a|b** : | 叫**逻辑或**，规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false 

4. **a||b** : || 叫**短路或**，规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false

5. **!a** : 叫**取反**。当 a 为 true, 则结果为 false, 当 a 为 false 是，结果为 true 

6. **a^b**: 叫**逻辑异或**，当 a 和 b 不同时，则结果为 true, 否则为 false

**&& 和 & 使用区别（||和|同）:**

1. &&短路与：**如果第一个条件为 false，则第二个条件不会判断**，最终结果为 false，效率高 
2. & 逻辑与：**不管第一个条件是否为 false，第二个条件都要判断**，效率低

#### 赋值运算符

赋值运算符就是将某个运算后的值，赋给指定的变量。

赋值运算符分为两类：

1. 基本赋值运算符 **=** ：int a = 10
2.  复合赋值运算符**+= ，-= ，*= ， /= ，%=** ：
   a += b  ====》  等价 a = a + b; 

#### 三元运算符

条件表达式    ?     表达式 1    :     表达式2

运算规则： 

1. 如果条件表达式为 true，运算后的结果是表达式 1； 
2. 如果条件表达式为 false，运算后的结果是表达式 2

细节：

表达式 1 和表达式 2 要为可以赋给接收变量的类型(或可以自动转换)

#### 标识符的命名规则和规范

规则：

![image-20240227151129934](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227151129934.png)

规范：

1. 包名：多单词组成时所有字母都小写：aaa.bbb.ccc //比如 com.hsp.crm 
2. 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰] 比如： TankShotGame 
3. 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz [小 驼峰， 简称 驼峰法] 比如： tankShotGame 
4. 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ 比如 ：定义一个所得税率 TAX_RATE 

#### 键盘输入语句

在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。Input.java , 需要一个 扫描器(对象), 就是 Scanner

步骤：

1.  引入/导入 Scanner 类所在的包
   **import java.util.Scanner;**
2. 创建 Scanner 对象 , new 创建一个对象
   **Scanner myScanner = new Scanner(System.in)；**
3. 调用里面的功能
   **String name = myScanner.next(); //接收用户输入字符串**
   int age = myScanner.nextInt(); //接收用户输入 int
   double sal = myScanner.nextDouble(); //接收用户输入 doubl

```java
import java.util.Scanner;
public class Input {
    Scanner myScanner = new Scanner(System.in);
    String name = myScanner.next();
}
```



#### 原码、反码、补码

**进制:**

二进制：0,1 ，满 2 进 1.以 0b 或 0B 开头。 

十进制：0-9 ，满 10 进 1。 

八进制：0-7 ，满 8 进 1. 以数字 0 开头表示。 

十六进制：0-9 及 A(10)-F(15)，满 16 进 1. 以 0x 或 0X

**原码、反码、补码：**

![image-20240227152037830](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227152037830.png)

为什么计算机的计算都是采用补码的方式？

因为可以统一正数和负数的运算

#### 位运算符

java 中有 **7 个**位运算(**&、|、 ^ 、~、>>、<<和 >>>**)

![image-20240227152230556](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227152230556.png)

1. 算术右移 >>：低位溢出,符号位不变,并用符号位补溢出的高位 
2. 算术左移 <<: 符号位不变,低位补 0 
3. **>>>**逻辑右移也叫无符号右移,运算规则是: 低位溢出，高位补 0 
4. 特别说明：没有 <<< 符号

本章作业：

![image-20240227152554047](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227152554047.png)

![image-20240227152604098](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227152604098.png)

### 05：程序控制结构

在程序中，程序运行的流程控制决定程序是如何执行的，是我们必须掌握的，主要有三大流程控制语句：

1. 顺序控制
2. 分支控制 
3. 循环控制

####  顺序控制

![image-20240227184158551](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227184158551.png)

#### 分支控制 

让程序有选择的的执行,分支控制有三种 

1. 单分支 if 
2. 双分支 if-else 
3. 多分支 if-else if -....-else

##### 单分支

![image-20240227184323395](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227184323395.png)

![image-20240227190203640](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227190203640.png) 

##### 双分支

![image-20240227190255856](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227190255856.png)

![image-20240227190411393](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227190411393.png) 

##### 多分支

![image-20240227191732315](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227191732315.png) 

![image-20240227191751330](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227191751330.png) 

##### 嵌套分支

在一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支的结构称为内层分支外面的分支结构称为外 层分支。

老师建议: 不要超过 3层（可读性不好）

##### switch 分支结构

![image-20240227193344488](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227193344488.png)

![image-20240227193358043](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227193358043.png)

![image-20240227193956153](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227193956153.png)

##### switch 和 if 的比较

1. 如果判断的具体数值不多，而且符合 byte、 short 、int、 char, enum[枚举], String 这 6 种类型。虽然两个语句都可 以使用，建议使用 swtich 语句。 
2. 其他情况：对区间判断，对结果为 boolean 类型判断，使用 if，if 的使用范围更广

#### 循环控制

##### for 循环

![image-20240227194619183](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227194619183.png)

![image-20240227194634788](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227194634788.png)

1.  循环条件是返回一个布尔值的表达式 
2. for(;循环判断条件;) 中的初始化和变量迭代可以写到其它地方，但是两边的分号不能省略。 
3. 循环初始值**可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开**，循环变量迭代也可以有多条变量迭代 语句，中间用逗号隔开。

##### while 循环

![image-20240227195208401](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227195208401.png) 

![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227195217459.png) 

1. 循环条件是返回一个布尔值的表达式 
2. while 循环是先判断再执行语句

#####  do..while 循环

![image-20240227195605308](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227195605308.png) 

![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227195722863.png) 

1. 先执行，再判断，也就是说，一定会至少执行一次 
2. **最后 有一个 分号 ;** 

##### 多重循环

1. 将一个循环放在另一个循环体内，就形成了嵌套循环。其中，for ,while ,do…while 均可以作为外层循环和内层循环。 【**建议一般使用两层，最多不要超过 3 层**, 否则，代码的可读性很差】 
2. 实质上，**嵌套循环就是把内层循环当成外层循环的循环体**。当只有内层循环的循环条件为 false 时，才会完全跳出内 层循环，才可结束外层的当次循环，开始下一次的循环

3. 设外层循环次数为 m 次，内层为 n 次，则内层循环体实际上需要执行 m*n 次。

![image-20240227200302757](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227200302757.png) 

#### 跳转控制

##### break

break 语句用于终止某个语句块的执行，一般使用在 switch 或者循环[for , while , do-while]中

![image-20240227202403904](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227202403904.png) 

![image-20240227202419529](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227202419529.png)

##### continue

1. continue 语句用于结束本次循环，继续执行下一次循环。 
2. continue 语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环 , 这个和前面的标签的 使用的规则一样

![image-20240227202548239](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227202548239.png) 

##### return

return 使用在方法，表示跳出所在的方法。如果 return 写在 main 方法中，则退出程序。

![image-20240227202706376](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227202706376.png) 

#### 本章作业

![image-20240227202734212](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227202734212.png)

![image-20240227202741313](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227202741313.png) 

### 06：数组、排序和查找

数组可以存放多个同一类型的数据。数组也是一种数据类型，是引用类型。

**数(数据)组(一组)就是一组数据**

#### 数组的使用

```java
//**使用方式一：动态初始化**
int a[] = new int[3];

//**使用方式二：动态初始化**
//先申明数组、再创建数组
int a[];
a = new int[3];

//**使用方式三：静态初始化**
int a[] = {2,3,4};
```

![image-20240228162344823](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228162344823.png) 

#### 数组的细节

1. 数组是多个**相同类型数据的组合**，实现对这些数据的统一管理

2) 数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用。
3) 数组创建后，**如果没有赋值，有默认值**
   int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \u0000，boolean false，String null

4) 使用数组的步骤 
   1) 声明数组并开辟空间 
   2) 给数组各个元素赋值 
   3) 使用数组
5) 数组的**下标是从** **0** **开始的**
6) 数组下标必须在指定范围内使用，否则报错：下标越界异常
7) 数组属**引用类型**，数组型数据是对象(object)

#### 数组赋值机制

1. 基本数据类型赋值，这个值就是具体的数据，而且相互不影响。int n1 = 2; int n2 = n1;

2) 数组在**默认情况下是引用传递，赋的值是地址**。

![image-20240228162932571](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228162932571.png) 

#### 排序

排序是将多个数据，依指定的顺序进行排列的过程。

排序分为：内部排序和外部排序

1. 内部排序：指将需要处理的所有数据都加载到内部存储器中进行排序。包括(交换式排序法、选择式排序法和插入式排序法)
2. 外部排序：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括(合并排序法和直接合并排序法)

#### 冒泡排序法

冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从后向前（从下标较大的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。

**思路：**

![image-20240228163400974](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228163400974.png) 

#### 二维数组

```java
//**使用方式1：动态初始化**
int a[3][3] = new int[3][3];

//**使用方式2：动态初始化**
//先声明、再开辟空间
int a[][];
a = new int[3][3]
    
//**使用方式 3: 动态初始化-列数不确定**
/**
0
00
000
*/
int a[][] = new a[10][];//先开辟行数的空间
for(int i = 0; i < a.length; i++) {
    a[i] = new int[i+1]; //再动态开辟列数的空间
}

int a[][];
a

//**使用方式 4: 静态初始化**
int a[][] = {{1,2,3},{4,5,6},{7,8,9}};
```

**储存细节：**

![image-20240228163846781](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228163846781.png) 

#### 二维数组细节

1) 一维数组的声明方式有:
   int[] x 或者 int x[]

2) 二维数组的声明方式有:
   ![image-20240228164437857](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228164437857.png)

3. 二维数组实际上是由多个一维数组组成的，它的各个一维数组的长度可以相同，也可以不相同。
4. 还是要注意数据类型的自动转换

![image-20240228164546217](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228164546217.png) 

#### 本章作业

![image-20240228164725724](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228164725724.png) 

![image-20240228164742609](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228164742609.png) 

### 07：面向对象编程

#### 类与对象

```java
Cat cat1 = new Cat();

class Cat {
	String name; 
	int age; 
	String color; 
}
```

##### 类和对象的区别和联系

1. 类是抽象的，概念的，代表一类事物,比如人类,猫类.., 即它是数据类型
2. 对象是具体的，实际的，代表一个具体事物, 即 是实例
3. 类是对象的模板，对象是类的一个个体，对应一个实例

##### 对象在内存中存在形式

![image-20240229150533210](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229150533210.png)

##### 属性/成员变量

从概念或叫法上看： 成员变量 = 属性 = field(字段)

属性是类的一个组成部分，一般是基本数据类型,也可是引用类型(对象，数组)。

**属性细节：**

1. 属性的定义语法同变量，
   示例：访问修饰符 属性类型 属性名(**public int name**); 
2. 访问修饰符： 控制属性的访问范围 有四种访问修饰符 public, proctected, 默认, private 
3. 属性的定义类型可以为任意类型，包含基本类型或引用类型 
4. 属性如果不赋值，有默认值，规则和数组一致。
   具体说: int 0，short 0, byte 0, long 0, float 0.0,
   double 0.0，char \u0000， boolean false，String null

##### 创建对象

```java
//1. 先声明再创建
Cat cat; //声明对象 cat
cat = new Cat(); //创建

//1. 直接创建
Cat cat = new Cat();
```

##### 访问属性

```java
cat.name;
cat.age;
cat.color;
```

##### 类和对象的内存分配机制

**Java 内存的结构分析:** 

1. 栈： 一般存放基本数据类型(局部变量) 
2. 堆： 存放对象(Cat cat , 数组等) 
3. 方法区：常量池(常量，比如字符串)， 类加载信息

```java
//简单流程分析
Person p = new Person();
p.name = “jack”;
p.age = 1

/**
1) 先加载 Person 类信息(属性和方法信息, 只会加载一次)
2) 在堆中分配空间, 进行默认初始化(看规则)
3) 把地址赋给 p , p 就指向对象
4) 进行指定初始化，比如 p.name =”jack” p.age = 10  
*/

```

![image-20240229152024847](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229152024847.png)

#### 成员方法

在某些情况下，我们要需要定义成员方法(简称方法)。比如人类:除了有一些属性外( 年龄，姓名..),我们人类还有一 些行为比如:可以说话、跑步..,通过学习。这时就要用成员方法才能完成。

##### 基本使用

```java
//1. 方法写好后，如果不去调用(使用)，不会输出
//2. 先创建对象 ,然后调用方法即可
Person p1 = new Person();
p1.speak(); //调用方法

class Person {
	String name;
	int age;
    
    public void speak() {
        System.out.println("我是一个好人");
    }
    
    public int getSum(int num1, int num2) {
        int res = num1 + num2;
        return res;
    }
}
```

##### 方法的调用机制原理

![image-20240229152600039](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229152600039.png)

##### 成员方法的定义

![image-20240229152732957](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229152732957.png) 

1. **访问修饰符**： (作用是控制 方法使用的范围) 如果不写默认访问，[有四种: public, protected, 默认, private]

2.  **返回数据类型**：

   1. 一个方法最多有一个返回值 [如果返回多个结果 **返回数组** ]
   2. 返回类型可以为任意类型，包含基本类型或引用类型(数组，对象)
   3.  如果方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值; 而且要求返回值类型必须和 return 的 值类型一致或兼容
   4. 如果方法是 void，则方法体中可以没有 return 语句，或者 只写 **return ;**

3. **方法名**：遵循驼峰命名法，最好见名知义，表达出该功能的意思即可

4. **参数列表**：

   ![image-20240229153308376](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229153308376.png) 

##### 方法调用细节

![image-20240229153450642](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229153450642.png)

#### 成员方法传参机制

**基本数据类型的传参机制**

![image-20240229153624402](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229153624402.png) 

**引用数据类型的传参机制**

引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参

#### 方法递归调用

递归就是方法**自己调用自己**,每次调用时传入不同的变量.递归有助于编程者解决复杂问题,同时可以让代码变 得简洁

**递归重要规则**

![image-20240229153906120](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229153906120.png)

![image-20240229154053516](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229154053516.png)

#### 方法重载

java 中允许同一个类中，多个同名方法的存在，但要求 形参列表不一致！

**好处：**

1) 减轻了起名的麻烦 
2) 减轻了记名的麻烦

```java
class MyCalculator {
    //一个整数，一个 double 的和
    public double calculate(int n1, double n2) {
    	return n1 + n2;
    }
    //一个 double ,一个 Int 和
    public double calculate(double n1, int n2) {
        System.out.println("calculate(double n1, int n2) 被调用..");
        return n1 + n2;
    }
}
```

**细节:**

![image-20240301084526792](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301084526792.png) 

![image-20240301084546628](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301084546628.png) 

####  可变参数

java 允许将**同一个类中多个同名同功能但参数个数不同**的方法，封装成一个方法。 就可以通过可变参数实现。

**基本语法：**

![image-20240301084725289](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301084725289.png) 

```java
public int sum(int... nums) {
    //System.out.println("接收的参数个数=" + nums.length);
    int res = 0;
    for(int i = 0; i < nums.length; i++) {
    	res += nums[i];
    }
    return res;
}
```

**细节：**

![image-20240301084907686](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301084907686.png) 

```java
//细节: 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后
public void f2(String str, double... nums) {
}

//细节: 一个形参列表中只能出现一个可变参数
//下面的写法是错的. 
public void f3(int... nums1, double... nums2) {
}
```

#### 作用域

![image-20240301085201052](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301085201052.png) 

**注意事项和细节使用:**

![image-20240301085248768](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301085248768.png) 

#### 构造方法

构造方法又叫构造器(constructor)，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。它有几个特点：

1) 方法名和类名相同 
2) 没有返回值 
3) 在创建对象时，系统会自动的调用该类的构造器完成对象的初始化。

**基本语法：**

![image-20240301085351515](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301085351515.png) 

1) 构造器的修饰符可以默认， 也可以是 public protected private 
2) 构造器没有返回值 
3) 方法名 和类名字必须一样 
4) 参数列表 和 成员方法一样的规则 
5) 构造器的调用, 由系统完成

**注意事项和使用细节：**

![image-20240301085756408](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301085756408.png) 

```java
public class ConstructorDetail {
	//编写一个 main 方法
    public static void main(String[] args) {
        Person p1 = new Person("king", 40);//第 1 个构造器
        Person p2 = new Person("tom");//第 2 个构造器
        Dog dog1 = new Dog();//使用的是默认的无参构造器
    }
}

class Dog {
    //如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器(也叫默认构造器)
}

class Person {
    String name;
    int age; //默认0
    
    //第 1 个构造器
	public Person(String pName, int pAge) {
        name = pName;
        age = pAge;
	}
    
   //第 2 个构造器, 只指定人名，不需要指定年龄
    public Person(String pName) {
    	name = pName;
    }
}
    
```

#### 对象创建的流程分析

![image-20240301090245190](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301090245190.png) 

####  this 关键字

简单的说，那个对象调用，this就代表那个对象。

1. this 关键字可以用来访问本类的属性、方法、构造器 
2. this 用于区分当前类的属性和局部变量 
3. **访问成员方法的语法：this.方法名(参数列表)**
4. **访问构造器语法：this(参数列表)**; 注意:只能在构造器中使用(即**只能在构造器中**访问另外一个构造器, **必须放在第一 条语句**)
5. this 不能在类定义的外部使用，只能在类定义的方法中使用

#### 本章作业

![image-20240301090818873](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301090818873.png) 

![image-20240301090832365](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301090832365.png) 

![image-20240301090848648](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301090848648.png) 

![image-20240301090904456](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301090904456.png) 

![image-20240301090915425](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301090915425.png) 

### 08：面向对象编程(中级)

#### 包

**作用：**

![image-20240302082554681](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302082554681.png) 

**语法：**

![image-20240302082641790](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302082641790.png) 

**本质：**

![image-20240302082724253](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302082724253.png) 

**命名：**

![image-20240302082824346](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302082824346.png) 

**细节：**

![image-20240302083016432](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302083016432.png) 

![image-20240302082932774](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302082932774.png) 

#### 访问修饰符

java 提供四种访问控制修饰符号，用于控制方法和属性(成员变量)的访问权限（范围）：

1) 公开级别:用 **public** 修饰,对外公开 
2) 受保护级别:用 **protected** 修饰,对子类和同一个包中的类公开 
3) 默认级别:**没有修饰符号**,向同一个包的类公开
4) 私有级别:用 **private** 修饰,只有类本身可以访问,不对外公开

![image-20240302094024820](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302094024820.png) 

**注意事项：**

![image-20240302083342543](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302083342543.png) 

#### 封装

![image-20240302103331943](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302103331943.png) 

**好处：**

![image-20240302103402079](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302103402079.png) 

**实现步骤：**

![image-20240302103503236](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302103503236.png) 

**将构造器和 setXxx 结合：**

![image-20240302103609067](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302103609067.png) 

#### 继承

继承可以解决代码复用,让我们的编程更加靠近人类思维.**当多个类存在相同的属性(变量)和方法时,可以从这些类中 抽象出父类**,在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 **extends 来 声明**继承父类即可。

![image-20240302103743228](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302103743228.png) 

**继承的基本语法：**

![image-20240302103821353](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302103821353.png) 

**好处：**

1) 代码的复用性提高了 
2) 代码的扩展性和维护性提高了

**继承细节：**

1. 子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访 问，要通过父类提供公共的方法去访问
2. 子类**必须调用父类的构造器**， 完成父类的初始化
3. 当创建子类对象时，不管使用子类的哪个构造器，**默认情况下总会去调用父类的无参构造器**，如果**父类没有提供无参构造器，则必须在子类的构造器中用 super 去指定**使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过
4. 如果希望指定去调用父类的某个构造器，则显式的调用一下 : **super(参数列表）**
5. super 在使用时，**必须放在构造器第一行(super 只能在构造器中使用)**
6. super() 和 this() 都只能放在构造器第一行，因此这**两个方法不能共存在一个构造器**
7. java 所有类都是 Object 类的子类, Object 是所有类的基类
8. 父类构造器的调用不限于直接父类，将一直往上追溯直到 Object 类(顶级父类）
9. 子类最多只能继承一个父类(指直接继承)，即 **java 中是单继承机制**
10. 不能滥用继承，**子类和父类之间必须满足 is-a 的逻辑关系**

**继承的本质分析：**

![image-20240302104358566](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302104358566.png) 

**查找关系：**

1. 首先看子类是否有该属性
2. 如果子类有这个属性，并且可以访问，则返回信息
3. 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..)
4. 如果父类没有就按照(3)的规则，继续找上级父类，直到 Object..

**内存布局：**

![image-20240302104638634](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302104638634.png) 

#### super关键字

super 代表父类的引用，用于访问**父类的属性、方法、构造器**

**语法：**

![image-20240302113723098](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302113723098.png) 

```java
System.out.println(n1);
System.out.println(this.n1);
//n1 和 this.n1 查找的规则是
//(1) 先找本类，如果有，则调用
//(2) 如果没有，则找父类(如果有，并可以调用，则调用)
//(3) 如果父类没有，则继续找父类的父类,整个规则，就是一样的,直到 Object 类
// 提示：如果查找属性的过程中，找到了，但是不能访问， 则报错, cannot access
// 如果查找属性的过程中，没有找到，则提示属性不存在
    
System.out.println(super.n1);
//找 n1 (super.n1) 的顺序是直接查找父类属性，其他的规则一样
```

**细节：**

![image-20240302114122709](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302114122709.png) 

#### super 和 this 的比较

![image-20240302114230453](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302114230453.png) 

#### 方法重写

![image-20240302114331887](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302114331887.png) 

**细节：**

![image-20240302114413515](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302114413515.png) 

**方法重写与方法重载区别：**

![image-20240302134050595](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302134050595.png) 

#### 多态

方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。

##### 多态的具体体现

1. 方法的多态：重写和重载体现多态
2. 对象的多态：

 ![image-20240302161158753](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302161158753.png)

##### 多态注意事项和细节

1. 多态的前提是：两个对象(类)存在继承关系

2. 多态的**向上转型**
   ![image-20240302161318650](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302161318650.png)

   为什么不能调用子类的特有成员？因为在编译阶段，能调用哪些成员,是由编译类型来决定的。

   最终运行效果看子类(运行类型)的具体实现, 即调用方法时，按照从子类(运行类型)开始查找方法，然后调用规则我前面我们讲的方法调用规则一致

3. 多态**向下转型**
   ![image-20240302161406048](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302161406048.png)

4. **instanceOf 比较操作符**，用于判断对象的**运行类型**是否为 XX 类型或 XX 类型的子类型

![image-20240302161851944](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302161851944.png) 

##### java 的动态绑定机制

![image-20240302162152620](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302162152620.png) 

##### 多态的应用

1. 多态数组：数组的定义类型为父类类型，里面保存的实际元素类型为子类类型
   应用实例:现有一个继承结构如下，要求创建 1 个 Person 对象、2 个 Student 对象和 2 个 Teacher 对象, 统一放在数组 中，并调用每个对象 say 方法

   ```java
   Person[] persons = new Person[5];
   
   persons[0] = new Person("jack", 20);
   persons[1] = new Student("mary", 18, 100);
   persons[2] = new Student("smith", 19, 30.1);
   persons[3] = new Teacher("scott", 30, 20000);
   persons[4] = new Teacher("king", 50, 25000);
   ```

2. 多态参数
   ![image-20240302162658189](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302162658189.png)

#### Object 类详解

##### equals 方法

==和 equals 的对比：

![image-20240302190357187](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302190357187.png) 

![image-20240303155917455](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303155917455.png)

##### hashCode 方法

![image-20240302190736043](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302190736043.png) 

1. 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的
2. 两个引用，如果指向的是不同对象，则哈希值是不一样的 
3. 哈希值主要根据地址号来的，不能完全将哈希值等价于地址

##### toString 方法

1. 基本介绍：

   默认返回：全类名+@+哈希值的十六进制，【查看 Object 的 toString 方法】

   子类往往重写 toString 方法，用于返回对象的属性信息

2. 重写 toString 方法，打印对象或拼接对象时，都会自动调用该对象的 toString 形式

3. **当直接输出一个对象时，toString 方法会被默认的调用**, 比如 System.out.println(monster)； 就会默认调用 monster.toString()

##### finalize 方法

1. 当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作
2. 什么时候被回收：当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来 销毁该对象，在销毁该对象前，会先调用 finalize 方法。 
3. 垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法), 也可以通过 **System.gc()** 主动触发垃圾回收机制
4.  **我们在实际开发中，几乎不会运用 finalize , 所以更多就是为了应付面试.**

#### 本章作业：

![image-20240303111746815](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303111746815.png) 

![image-20240303111800007](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303111800007.png) 

![image-20240303151844489](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303151844489.png) 

![image-20240303111843504](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303111843504.png) 

![image-20240303111906766](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303111906766.png) 

### 10：面向对象编程(高级)

#### 类变量和类方法

##### 类变量

![image-20240305155410347](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305155410347.png) 

**定义：**

![image-20240305155451552](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305155451552.png) 

**访问类变量:**

![image-20240305155627145](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305155627145.png) 

```java
class AA {
    public static void num;
}

AA.num;
//或者
new AA().num;
```

**细节：**

![image-20240305155841863](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305155841863.png) 

##### 类方法

![image-20240305160024564](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305160024564.png) 

![image-20240305160055714](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305160055714.png) 

如果我们希望不创建实例，也可以调用某个方法(即当做工具来使用），这时，把方法做成静态方法时非常合适。

**类方法经典的使用场景：**

![image-20240305160248348](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305160248348.png) 

**细节：**

![image-20240305160332732](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305160332732.png) 

#### main方法

**理解 main 方法：**

![image-20240305160726592](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305160726592.png) 

**特别提示：**

1) 在 main()方法中，我们可以直接调用 main 方法所在类的静态方法或静态属性。 
2) 但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员

**在idea中传递参数：**

![image-20240305160928734](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305160928734.png) 

#### 代码块

##### 基本介绍

![image-20240305161018264](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305161018264.png) 

##### 基本语法

![image-20240305161102528](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305161102528.png) 

##### 代码块的好处

 ![image-20240305161233498](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305161233498.png) 

##### 代码块的细节讨论

![image-20240305161346185](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305161346185.png) 

![image-20240305161525158](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305161525158.png) 

![image-20240305161643324](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305161643324.png) 

![image-20240305161710575](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305161710575.png) 

#### 单例模式

**什么是设计模式：**

![image-20240305200508550](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305200508550.png) 

**什么是单例模式：**

![image-20240305200419112](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305200419112.png) 

##### **饿汉式：**

```java
//步骤[单例模式-饿汉式]
//1. 将构造器私有化
//2. 在类的内部直接创建对象(该对象是 static)
//3. 提供一个公共的 static 方法，返回 gf 对象
class GirlFriend {
	private String name;
    //2. 在类的内部直接创建对象(该对象是 static)
    private static GirlFriend gf = new GirlFriend("小红红");
    //1. 将构造器私有化
    private GirlFriend(String name) {
		System.out.println("構造器被調用.");
		this.name = name;
	}
    //3. 提供一个公共的 static 方法，返回 gf 对象
    public static GirlFriend getInstance() {
		return gf;
    }
}
```

##### **懒汉式：**

```java
//步骤[单例模式-懒式]
//1. 将构造器私有化
//2. 在类的内部定义一个对象(该对象是 static)
//3. 提供一个公共的 static 方法，返回 Cat 对象
//4. 只有当用户调用getInstance这个公用方法时，才会真正创建Cat对象
class Cat {
    private String name;
    public static int n1 = 999;
    //2. 在类的内部定义一个对象(该对象是 static)
    private static Cat cat ; //默认是 null
    //1. 将构造器私有化
    private Cat(String name) {
        this.name = name;
    }
    //3. 提供一个公共的 static 方法，返回 Cat 对象
    public static Cat getInstance() {
        if(cat == null) {//如果还没有创建cat对象，就创建一个
        	cat = new Cat("小可愛");
        }
        return cat;
   	}
}
```

##### 饿汉式 VS 懒汉式

![image-20240305201445529](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305201445529.png) 

#### final关键字

**基本介绍：**

![image-20240305205312151](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305205312151.png) 

**细节：**

![image-20240305205404737](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305205404737.png) 

![image-20240305205506115](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305205506115.png) 

#### 抽象类

**理解：**

![image-20240306085546788](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306085546788.png) 

父类方法不确定性的问题 ===> 考虑将该方法设计为抽象(abstract)方法 ===> 所谓抽象方法就是没有实现的方法 ===> 所谓没有实现就是指，没有方法体 ===> 当一个类中存在抽象方法时，需要将该类声明为 abstract 类 ==> 一般来说，抽象类会被继承，有其子类来实现抽象方法

**介绍：**

![image-20240306085841810](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306085841810.png) 

**细节：**

![image-20240306085933576](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306085933576.png) 

![image-20240306090007586](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306090007586.png) 

![image-20240306090038794](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306090038794.png) 

不能用static是因为static声明的静态成员可以直接被类调用，而抽象类就只有被继承的能力。

#### 模板设计模式

**基本介绍：**

![image-20240306093306421](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306093306421.png) 

**模板设计模式能解决的问题：**

![image-20240306093354767](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306093354767.png) 

```java
abstract public class Template { //抽象类-模板设计模式
    public abstract void job();//抽象方法
    
    public void calculateTime() {//实现方法，调用 job 方法
        //得到开始的时间
        long start = System.currentTimeMillis();
        job(); //动态绑定机制
        //得的结束的时间
        long end = System.currentTimeMillis();
        System.out.println("任务执行时间 " + (end - start));
  	}
}
 
class AA extends Template {
    @Override
    public void job() { //实现 Template 的抽象方法 job
        long num = 0;
        for (long i = 1; i <= 800000; i++) {
        	num += i;
        }
    }
}

class BB extends Template {
    @Override
    public void job() { //实现 Template 的抽象方法 job
        long num = 0;
        for (long i = 1; i <= 600000; i++) {
        	num += i;
        }
    }
}      
```

#### 接口

##### 为什么有接口

![image-20240306105841413](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306105841413.png) 

##### 基本介绍

![image-20240306105933451](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306105933451.png) 

##### 注意事项和细节

![image-20240306110040799](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306110040799.png) 

![image-20240306110118438](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306110118438.png) 

##### 实现接口 vs 继承

![image-20240306110244415](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306110244415.png) 

小结: 

1. 当子类继承了父类，就自动的拥有父类的功能

2. 如果子类需要扩展功能，可以通过实现接口的方式扩展.（可以理解 实现接口 是 对 java 单继承机制的一种补充）

```java
//猴子
class Monkey {
    public String name;
    public Monkey(String name) {
    	this.name = name;
    }
    public void climbing() {
    System.out.println(name + " 会爬树...");
    }
}
//鱼
interface Fishable {
	void swimming();
}
//鸟
interface Birdable {
	void flying();
} 

//小猴子继承了猴子的爬树，小猴子实现了与鱼的游泳和鸟的飞翔
class LittleMonkey extends Monkey implements Fishable,Birdable {
    public LittleMonkey(String name) {
		super(name);
	}
    @Override
    public void swimming() {
    	System.out.println(getName() + " 通过学习，可以像鱼儿一样游泳...");
    }
    @Override
    public void flying() {
    	System.out.println(getName() + " 通过学习，可以像鸟儿一样飞翔...");
    }
}
```

![image-20240306110811731](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306110811731.png) 

##### 接口的多态特性

![image-20240306110901095](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306110901095.png) 

##### 接口练习

```java
interface A {
	int x = 0;
}
class B {
	int x = 1;
}
class C extends B implements A {
    public void pX() {
		System.out.println(x); //错误，x是A的还是B的，模糊
        // 改
        System.out.println(A.x + " " + super.x);
        //可以明确的指定 x
        //访问接口的 x 就使用 A.x
        //访问父类的 x 就使用 super.x
    }
}
```

#### 内部类

1. 如果**定义在局部位置**(方法中/代码块) :
   1. 局部内部类（有类名）
   2. 匿名内部类（**没有类名，重点！！！**）

2. 定义在成员位置
   1. 成员内部类
   2. 静态内部类（有static修饰）

##### 基本介绍

![image-20240306143853579](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306143853579.png) 

##### 基本语法

![image-20240306143954630](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306143954630.png) 

##### 局部内部类

![image-20240306144054269](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306144054269.png) 

```java
class Outer02 {//外部类
    private int n1 = 100;
    private void m2() {
    	System.out.println("Outer02 m2()");
	}//私有方法
    public void m1() {//方法
        ////2.不能添加访问修饰符,但是可以使用 final 修饰
        final class Inner02 {//局部内部类(本质仍然是一个类)
            private int n1 = 800;
            public void f1() {
                //7.如果外部类和局部内部类的成员重名时,使用 外部类名.this.成员去访问
                System.out.println("n1=" + n1 + " 外部类的 n1=" + Outer02.this.n1);
                //4.局部内部类可以直接访问外部类的成员
                m2();
            }
            //5.外部类在方法中，可以创建 Inner02 对象，然后调用方法即可
            Inner02 inner02 = new Inner02;
            inner02.f1();
        }
    }
}     
```

##### 匿名内部类

![image-20240306145355085](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306145355085.png) 

![image-20240306145446514](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306145446514.png) 

```java
//需求是Tiger类只是使用一次，后面再不使用,可以使用匿名内部类来简化开发

class Outer04 { //外部类
	private int n1 = 10;//属性
    public void method() {//方法
        //基于接口的匿名内部类
        IA tiger = new IA() {
        //tiger 的编译类型 是 IA，
        //tiger 的运行类型是匿名内部类 Outer04$1(系统自动生成的)
            @Override
            public void cry() {
            	System.out.println("老虎叫唤...");
            }
        }
        //jdk 底层在创建匿名内部类 Outer04$1,然后立即马上就创建了 Outer04$1,并把地址返回给tiger
      	//**********************************************
        //类似于
        class Outer04$1 implements IA {
            @Override
            public void cry() {
            	System.out.println("老虎叫唤...");
            }
     	}
        //**********************************************
        System.out.println("tiger 的运行类型=" + tiger.getClass())
    	tiger.cry();
    }
}
   
interface IA {//接口
	public void cry();
} 
```

**最佳实践：当做实参直接传递，简洁高效。**

```java
public class InnerClassExercise01 {
	public static void main(String[] args) {
        //当做实参直接传递，简洁高效
        f1(new IL() {
        	@Override
        	public void show() {
       			System.out.println("这是一副名画~~...");
        	}
		});
    }
}
//接口
interface IL {
	void show();
}
```

##### 成员内部类

![image-20240306151747626](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306151747626.png) 

![image-20240306151802370](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306151802370.png) 

![image-20240306151831810](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306151831810.png) 

**外部其他类 使用成员内部类：**

```java
class Outer08 { //外部类
	public class Inner08 {//成员内部类
        public void say() {
            System.out.println("你好");
        }
    }
}
public class Test {//外部类其他类
    public static void main(String[] args) {
        //方式 1
		//outer08.new Inner08(); 相当于把 new Inner08()当成outer08的成员
        // 这就是一个语法，不要特别的纠结
        Outer08.Inner08 inner08 = outer08.new Inner08();
        inner08.say();
        //方式 2
		//编写一个方法，可以返回成员内部类的对象实例.
    }
}
```

##### 静态内部类

![image-20240306151901882](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306151901882.png) 

**外部其他类 使用静态内部类：**

```java
class Outer10 { //外部类
    static class Inner10 {
        public void say() {
            System.out.println("你好");
        }
    }
}
public class Test {//外部类其他类
    public static void main(String[] args) {
        //方式 1
		//因为静态内部类，是可以通过类名直接访问(前提是满足访问权限)
        Outer10.Inner10 inner10 = new Outer10.Inner10();
        inner10.say();
        //方式 2
		//编写一个方法，可以返回静态内部类的对象实例.
    }
}
```

### 11：枚举和注解

#### 枚举

1) 枚举对应英文(enumeration, 简写 enum) 
2) 枚举是一组常量的集合
3) 可以这里理解：枚举属于一种特殊的类，里面只包含一组有限的特定的对象。

**枚举的二种实现方式：**

1) 自定义类实现枚举 
2) 使用 enum 关键字实现枚举

##### 增强for循环

```java
int[] nums = {1,2,3,4,5,6};

//执行流程是 依次从 nums 数组中取出数据，赋给 i, 如果取出完毕，则退出 for
for (int i : nums) {
    System.out.println("i=" + i);
}
```

##### 自定义枚举

![image-20240307101028951](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307101028951.png) 

**步骤：**

1. 将构造器私有化,目的防止 直接 new 
2. 去掉 setXxx 方法, 防止属性被修该
3. 在 Season 内部，直接创建固定的对象 
4. 优化，可以加入 final 修饰符

```java
class Season {
    private String name;
    private String desc;//描述
    
    //3.在 Season 内部，直接创建固定的对象 
    //4.优化，可以加入 final 修饰符
    public static final Season SPRING = new Season("春天", "温暖");
    public static final Season WINTER = new Season("冬天", "寒冷");
    public static final Season AUTUMN = new Season("秋天", "凉爽");
    public static final Season SUMMER = new Season("夏天", "炎热");
    
    //1.将构造器私有化,目的防止 直接 new 
    private Season(String name, String desc) {
        this.name = name;
        this.desc = desc;
	}
```

**进行自定义类实现枚举，有如下特点：**

1) 构造器私有化 
2) 本类内部创建一组对象[四个 春夏秋冬]
3) 对外暴露对象（通过为对象添加 public final static 修饰符）
4) 可以提供 get 方法，但是不要提供 set

##### enum 枚举

###### enum 来实现枚举

1. 使用关键字 enum 替代 class
2. public static final Season SPRING = new Season("春天", "温暖")   ====》**SPRING("春天", "温暖")** 解读 常量名(实参列表) 
3. **如果有多个常量(对象)， 使用 ,号间隔即可**
4.  **常量对象的定义要写在最前面** 
5. 如果我们使用的是无参构造器，创建常量对象，则可以省略 **括号（）**

```java
//1.使用关键字 enum 替代 class
enum Season2 {
    //2.public static final Season SPRING = new Season("春天", "温暖")   ====》SPRING("春天", "温暖")
    //解读 常量名(实参列表) 
	SPRING("春天", "温暖"), 
    WINTER("冬天", "寒冷"), //3.如果有多个常量(对象)， 使用 ,号间隔
    AUTUMN("秋天", "凉爽"),
    SUMMER("夏天", "炎热");
    //4. 常量对象的定义要写在最前面
    
    //What() ==> what;  5.如果我们使用的是无参构造器，创建常量对象，则可以省略 括号（）
    
    private String name;
	private String desc;//描述
    
    //默认是私有的
    Season2(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }
    
    private Season2() {//无参构造器
	}
}
```

###### **注意事项**

1. 当我们使用 enum 关键字开发一个枚举类时，**默认会继承 Enum 类**, **而且是一个 final 类**,可以使用 javap 工 具来演示 
2. 传统的 public static final Season2 SPRING = new Season2("春天", "温暖"); **简化成 SPRING("春天", "温暖")**， 这里必须知道，它调用的是哪个构造器. 
3. 如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略
4. 当有多个枚举对象时，使用,间隔，**最后有一个分号结尾** 
5. **枚举对象必须放在枚举类的行首**

![image-20240307102849743](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307102849743.png) 

###### enum 常用方法

说明：使用关键字 enum 时，会隐式继承 Enum 类, 这样我们就可以使用 Enum 类相关的方法。

1) **toString**:Enum 类已经重写过了，返回的是当前对象 名,子类可以重写该方法，用于返回对象的属性信息 
2) **name**：返回当前对象名（常量名），子类中不能重写
   System.out.println(==autumn.name()==);
3) **ordinal**：返回当前对象的位置号，默认从 0 开始
   System.out.println(==autumn.ordinal()==);
4) **values**：返回当前枚举类中所有的常量
   Season2[] values = ==Season2.values()==;
5) **valueOf**：将字符串转换成枚举对象，要求字符串必须 为已有的常量名，否则报异常！
   Season2 autumn1 = ==Season2.valueOf("AUTUMN")==;
6) **compareTo**：比较两个枚举常量，比较的就是编号！
   System.out.println(==Season2.AUTUMN.compareTo(Season2.SUMMER)==)

###### enum 实现接口

1. 使用 enum 关键字后，就不能再继承其它类了，**因为 enum 会隐式继承 Enum，而 Java 是单继承机制**。 

2. 枚举类和普通类一样，可以实现接口，如下形式。 
   **enum 类名 implements 接口 1，接口 2{}**

   ```java
   interface IPlaying {//接口
   	public void playing();
   }
   
   enum Music implements IPlaying {//枚举类实现接口
       CLASSICMUSIC;
       @Override
       public void playing() {
       	System.out.println("播放好听的音乐...");
       }
   }
   ```

#### 注解

##### 注解的理解

1) 注解(Annotation)，**用于修饰解释** 包、类、方法、属性、构造器、局部变量等数据信息。
2) 和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，**相当于嵌入在代码中的补充信息**。
3) 注解是以"@注释名"在代码中存在的，还可以添加一些参数值 , 例如:@SuppressWarnings(value="unchecked")

##### 内置注解

###### @Override

![image-20240307105801970](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307105801970.png) 

![image-20240307105835684](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307105835684.png) 

###### @Deprecated

@Deprecated: 用于表示某个程序元素(类, 方法等)已过时

![image-20240307105919709](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307105919709.png) 

###### @SuppressWarnings

@SuppressWarnings: 抑制编译器警告

![image-20240307110004803](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307110004803.png) 

##### 元注解

元注解的作用就是负责注解其他注解 , Java定义了4个标准的meta-annotation类型,他们被用来提供 对其他annotation类型作说明 .

这些类型和它们所支持的类在java.lang.annotation包中可以找到 .( @Target , @Retention , @Documented , @Inherited )

**@Target** : 用于描述注解的使用范围(即:被描述的注解可以用在什么地方) 

**@Retention** : 表示需要在什么级别保存该注释信息 , 用于描述注解的生命周期 (SOURCE < CLASS < RUNTIME) 

**@Document**：说明该注解将被包含在javadoc中 

**@Inherited**：说明子类可以继承父类中的该注解

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}

@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
    String[] value();
}

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})
public @interface Deprecated {
}
```

##### 自定义注解

使用 @interface自定义注解时 , 自动继承了java.lang.annotation.Annotation接口。

1. @ interface用来声明一个注解 , 格式 : **public @ interface 注解名 { 定义内容 }** 

2. 配置参数，虽然带有括号，但是本质上是一个变量而不是方法，格式：**类型 变量名();**

4. @Target()和@Retention()，**这两个元注解是必须要写的**，而且一般自定义的注解都是全部保存到，即**RetentionPolicy.RUNTIME**

5. 可以通过default来声明参数的默认值 ，格式：**类型 变量名() default 默认值**;
   注解元素必须要有值 , 我们定义注解元素时 , 经常使用空字符串,0作为默认值 .

6. 如果**只有一个参数成员 , 一般参数名为value** ，这有一个好处，当使用这个自定义注解传入参数时，value可以省略不写，如果是别的参数名，就必须要写

```java
public class Test01 {
    //显示定义值 / 不显示值就是默认值
    @MyAnnotation(name="陈俊宇",age=23,id=1,schools = {"湖北大学"})
    public void test() {

    }

    //只有一个参数, 默认名字一般是value.使用可省略不写
    @MyAnnotation2("aaa")
    public void test2() {

    }

}

@Target(value = {ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation {
    String name() default "";
    int age() default 0;
    int id() default -1; //String indexOf("abc") -1 , 不存在,找不到
    String[] schools() default {"清华大学"};
}

@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation2 {
    String[] value();
}
```





#### 本章作业

![image-20240307110345574](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307110345574.png) 

![image-20240307110359777](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307110359777.png) 

### 12：异常

#### 异常介绍

![image-20240307174052378](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307174052378.png) 

#### 异常体系图

![image-20240307174200505](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307174200505.png) 

![image-20240307174225877](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307174225877.png) 

#### 运行时异常

对于运行时异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。

**常见的运行时异常：**

1) NullPointerException 空指针异常 
   当应用程序试图在**需要对象的地方使用null时**，抛出该异常
2) ArithmeticException 数学运算异常 
   当出现异常的运算条件时，抛出此异常。例如，**一个整数“除以零”**时，抛出此类的一个实例
3) ArrayIndexOutOfBoundsException 数组下标越界异常
   **用非法索引访问数组时抛出的异常**。如果索引为负或大于等于数组大小，则该索引为非法索引
4) ClassCastException 类型转换异常 
   当**试图将对象强制转换为不是实例的子类时**，抛出该异常，例如：在向上转型和向下转型的时候
5) NumberFormatException 数字格式不正确异常
   当应用程序**试图将字符串转换成一种数值类型**，但该字符串不能转换为适当格式时，抛出该异常

#### 编译异常

编译异常是指在编译期间，就必须处理的异常，否则代码不能通过编译。

**常见的编译异常：**

![image-20240307175609545](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307175609545.png) 

#### 异常处理

异常处理就是当异常发生时，对异常处理的方式。

**异常处理的方式：**

1. try-catch-finally

2. throws

   ![image-20240307175805347](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307175805347.png) 

##### try-catch 异常处理

![image-20240307175857673](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307175857673.png) 

**try-catch 方式处理异常说明：**

![image-20240307180020062](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180020062.png) 

**try-catch 方式处理异常-注意事项：**

![image-20240307180104995](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180104995.png) 

![image-20240307180120345](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180120345.png) 

![image-20240307180148754](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180148754.png) 

##### throws异常处理

**介绍：**

![image-20240307180240788](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180240788.png) 

![image-20240307175938523](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307175938523.png) 

**使用细节：**

![image-20240307180330439](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180330439.png) 

#### 自定义异常

**基本概念：**

![image-20240307180428334](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180428334.png) 

**步骤：**

![image-20240307180446022](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180446022.png) 

```java
class AgeException extends RuntimeException {
    public AgeException(String message) {//构造器
		super(message);
	}
}

throw new AgeException("年龄需要在 18~120 之间");
```

#### throw 和 throws 区别

![image-20240307180635727](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180635727.png) 

#### 本章作业

![image-20240307180731664](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180731664.png) 

![image-20240307180748657](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180748657.png) 

### 13：常用类

#### 包装类

##### 包装类的分类

1) 针对八种基本数据类型相应的引用类型—包装类 
2) 有了类的特点，就可以调用类中的方法。

![image-20240308170618202](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308170618202.png) 

##### 包装类和基本数据

![image-20240308170741778](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308170741778.png) 

**手动装箱：**

```java
//手动装箱 int->Integer
int n1 = 100;
Integer integer = new Integer(n1);
Integer integer1 = Integer.valueOf(n1);

//手动拆箱 Integer -> int
int i = integer.intValue();
```

**自动装箱：**

```java
//jdk5 后，就可以自动装箱和自动拆箱
//自动装箱 int->Intege
int n2 = 200;
Integer integer2 = n2;//底层使用的是 Integer.valueOf(n2)

//自动拆箱 Integer->int
int n3 = integer2; //底层仍然使用的是 intValue()方法
```

##### 包装类和 String 类

```java
//包装类(Integer)->String
Integer i = 100;//自动装箱
//方式 1
String str1 = i + "";
//方式 2
String str2 = i.toString();
//方式 3
String str3 = String.valueOf(i);

//String -> 包装类(Integer)
String str4 = "12345";
Integer i2 = Integer.parseInt(str4);//使用到自动装箱
Integer i3 = new Integer(str4);//构造
```

####  String 类

##### String 类的理解

![image-20240308171619508](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308171619508.png) 

![image-20240308171701632](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308171701632.png) 

```java
//1.String 对象用于保存字符串，也就是一组字符序列

//2. "jack" 字符串常量, 双引号括起的字符序列

//3. 字符串的字符使用 Unicode 字符编码，一个字符(不区分字母还是汉字)占两个字节

//4. String 类有很多构造器，构造器的重载
// 常用的有 String s1 = new String(); //
//String s2 = new String(String original);
//String s3 = new String(char[] a);
//String s4 = new String(char[] a,int startIndex,int count)
//String s5 = new String(byte[] b)

//5. String 类实现了接口 Serializable【String 可以串行化:可以在网络传输】，接口 Comparable [String 对象可以比较大小]

//6. String 是 final 类，不能被其他的类继承

//7. String 有属性 private final char value[]; 用于存放字符串内容

//8. 一定要注意：value 是一个 final 类型， 不可以修改(需要功力)：即 value 不能指向新的地址，但是单个字符内容是可以变
```

##### 创建 String 对象

![image-20240308172017598](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172017598.png) 

**两种创建 String 对象的区别：**

![image-20240308172052241](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172052241.png) 

![image-20240308172114853](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172114853.png) 

##### String 类的常见方法

**String缺点：**

![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172216821.png) 

**String 类的常见方法一览：**

![image-20240308172255299](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172255299.png) 

![image-20240308172331604](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172331604.png) 

#####  StringBuffer 类

###### **基本介绍：**

![image-20240308172504823](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172504823.png) 

```java
//1. StringBuffer 的直接父类 是 AbstractStringBuilder

//2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化

//3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final该 value 数组存放 字符串内容，引出存放在堆中的

//4. StringBuffer 是一个 final 类，不能被继承

//5. 因为 StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除)

// 不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String
StringBuffer stringBuffer = new StringBuffer("hello");
```

######  **String VS StringBuffer：**

![image-20240308172848918](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172848918.png) 

###### **String 和 StringBuffer 相互转换：**

![image-20240308172914816](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172914816.png) 

```java
//看 String——>StringBuffer
String str = "hello tom";
//方式 1 使用构造器
//注意： 返回的才是 StringBuffer 对象，对 str 本身没有影响
StringBuffer stringBuffer = new StringBuffer(str);
//方式 2 使用的是 append 方法
StringBuffer stringBuffer1 = new StringBuffer();
stringBuffer1 = stringBuffer1.append(str);

//看 StringBuffer ->String
StringBuffer stringBuffer3 = new StringBuffer("韩顺平教育");
//方式 1 使用 StringBuffer 提供的 toString 方法
String s = stringBuffer3.toString();
//方式 2: 使用构造器来搞定
String s1 = new String(stringBuffer3)
```

######  StringBuffer 类常见方法

```java
StringBuffer s = new StringBuffer("hello");
//增
s.append(',');// "hello,
s.append("张三丰");//"hello,张三丰"
s.append("赵敏").append(100).append(true).append(10.5);//"hello,张三丰赵敏 100true10.5"

//删
s.delete(11, 14);//"hello,张三丰赵敏 true10.5

//改
s.replace(9, 11, "周芷若");//"hello,张三丰周芷若 true10.5

//插
s.insert(9, "赵敏");//"hello,张三丰赵敏周芷若 true10.5

//长度
s.length()
```

##### StringBuilder 类

###### **基本介绍**

![image-20240308174956149](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308174956149.png) 

```java
//1. StringBuffer 的直接父类 是 AbstractStringBuilder

//2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化

//3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final该 value 数组存放 字符串内容，引出存放在堆中的

//4. StringBuffer 是一个 final 类，不能被继承

//5. 因为 StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除),不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String

StringBuffer stringBuffer = new StringBuffer("hello");

//6. StringBuilder 的方法，没有做互斥的处理,即没有 synchronized 关键字,因此在单线程的情况下使用
```

######  String、StringBuffer 和 StringBuilder 的比较

![image-20240308175326835](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308175326835.png) 

###### String、StringBuffer 和 StringBuilder 的选择

![image-20240308175436067](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308175436067.png) 

####  Math 类

Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。

**方法一览(均为静态方法)：**

```java
//1.abs 绝对值
int abs = Math.abs(-9);
System.out.println(abs);//9
//2.pow 求幂
double pow = Math.pow(2, 4);//2 的 4 次方
System.out.println(pow);//16
//3.ceil 向上取整,返回>=该参数的最小整数(转成 double);
double ceil = Math.ceil(3.9);
System.out.println(ceil);//4.0
//4.floor 向下取整，返回<=该参数的最大整数(转成 double)
double floor = Math.floor(4.001);
System.out.println(floor);//4.0
//5.round 四舍五入 Math.floor(该参数+0.5)
long round = Math.round(5.51);
System.out.println(round);//6
//6.sqrt 求开方
double sqrt = Math.sqrt(9.0);
System.out.println(sqrt);//3.0

//7.random 求随机数
// random 返回的是 0 <= x < 1 之间的一个随机小数
// 思考：请写出获取 a-b 之间的一个随机整数,a,b 均为整数 ，比如 a = 2, b=7
// 即返回一个数 x 2 <= x <= 7
// 老韩解读 Math.random() * (b-a) 返回的就是 0 <= 数 <= b-a
// (1) (int)(a) <= x <= (int)(a + Math.random() * (b-a +1) )
// (2) 使用具体的数给小伙伴介绍 a = 2 b = 7
// (int)(a + Math.random() * (b-a +1) ) = (int)( 2 + Math.random()*6)
// Math.random()*6 返回的是 0 <= x < 6 小数
// 2 + Math.random()*6 返回的就是 2<= x < 8 小数

//8.max , min 返回最大值和最小值
int min = Math.min(1, 9);
int max = Math.max(45, 90);
System.out.println("min=" + min);
System.out.println("max=" + max);
```

####  Arrays 类

**Arrays 类常见方法：**

![image-20240309110000976](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309110000976.png) 

![image-20240309110031519](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309110031519.png) 

```java
3)binarySearch 通过二分搜索法进行查找，要求必须排好
//1. 使用 binarySearch 二叉查找
//2. 要求该数组是有序的. 如果该数组是无序的，不能使用 binarySearch
//3. 如果数组中不存在该元素，就返回 return -(low + 1) // key not found.
```



#### System 类

![image-20240309110213285](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309110213285.png) 

```java
2）arraycopy()
// srcPos： 从源数组的哪个索引位置开始拷贝
// dest : 目标数组，即把源数组的数据拷贝到哪个数组
// destPos: 把源数组的数据拷贝到 目标数组的哪个索引
// length: 从源数组拷贝多少个数据到目标数组
```

#### 大数类

**BigInteger 、BigDecimal 类：**

![image-20240309110808224](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309110808224.png) 

**常见方法：**注意这些大数类不能直接+-*/哦，要调用方法

![image-20240309110839015](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309110839015.png) 

```java
long l = 23788888899999999999999999999l; // 编译会报错
BigInteger bigInteger = new BigInteger("23788888899999999999999999999");
System.out.println(bigInteger);

//1. 在对 BigInteger 进行加减乘除的时候，需要使用对应的方法，不能直接进行 + - * /
//2. 可以创建一个 要操作的 BigInteger 然后进行相应操作
BigInteger add = bigInteger.add(bigInteger2);

//当我们需要保存一个精度很高的数时，double 不够
double d = 1999.11111111111999999999999977788d; //输出时，会截断后面的很多小数
BigDecimal bigDecimal = new BigDecimal("1999.11111111111999999999999977788");

//1. 如果对 BigDecimal 进行运算，比如加减乘除，也需要使用对应的方法
//2. 创建一个需要操作的 BigDecimal 然后调用相应的方法即可
System.out.println(bigDecimal.divide(bigDecimal2));//可能抛出异常 ArithmeticExceptio
//在调用 divide 方法时，指定精度即可. BigDecimal.ROUND_CEILING
//如果有无限循环小数，就会保留 分子 的精度
System.out.println(bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING))
```

#### 日期类

#####  第一代日期类

![image-20240309111356647](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309111356647.png) 

```java
//1. 获取当前系统时间
//2. 这里的 Date 类是在 java.util 包
//3. 默认输出的日期格式是国外的方式, 因此通常需要对格式进行转换

Date d1 = new Date(); 
Date d2 = new Date(9234567);  //通过指定毫秒数得到时间

//1. 创建 SimpleDateFormat 对象，可以指定相应的格式
//2. 这里的格式使用的字母是规定好，不能乱写
SimpleDateFormat sdf = new SimpleDateFormat("yyyy 年 MM 月 dd 日 hh:mm:ss E");
String format = sdf.format(d1); // format:将日期转换成指定格式的字符串
System.out.println("当前日期=" + format);
```



#####  第二代日期类

![image-20240309111430624](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309111430624.png) 

```java
//1. Calendar 是一个抽象类， 并且构造器是 private
//2. 可以通过 getInstance()
//3. 提供大量的方法和字段提供给程序员
//4. Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活)
//5. 如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR ==改成=> Calendar.HOUR_OF_DAY

Calendar c = Calendar.getInstance();
System.out.println("c=" + c);

System.out.println("年：" + c.get(Calendar.YEAR));
// 这里为什么要 + 1, 因为 Calendar 返回月时候，是按照 0 开始编号
System.out.println("月：" + (c.get(Calendar.MONTH) + 1));
//Calender 没有专门的格式化方法，所以需要程序员自己来组合显示
System.out.println(c.get(Calendar.YEAR) + "-" + (c.get(Calendar.MONTH) + 1) + "-" +
					c.get(Calendar.DAY_OF_MONTH) +" " + c.get(Calendar.HOUR_OF_DAY) + ":" + 									c.get(Calendar.MINUTE) + ":" + c.get(Calendar.SECOND) )
```

#####  第三代日期类

**前两代的不足：**

![image-20240309112129814](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309112129814.png) 

**第三代日期类：**

![image-20240309112237443](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309112237443.png) 

```java
//1. 使用 now() 返回表示当前日期时间的 对象
LocalDateTime ldt = LocalDateTime.now(); //LocalDate.now();//LocalTime.now()
System.out.println(ldt);

//2. 使用 DateTimeFormatter 对象来进行格式化
// 创建 DateTimeFormatter 对象
DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
String format = dateTimeFormatter.format(ldt);
System.out.println("格式化的日期=" + format);

System.out.println("年=" + ldt.getYear());
System.out.println("月=" + ldt.getMonth());
System.out.println("月=" + ldt.getMonthValue());
System.out.println("日=" + ldt.getDayOfMonth());
System.out.println("时=" + ldt.getHour());
System.out.println("分=" + ldt.getMinute());
System.out.println("秒=" + ldt.getSecond());

//3.提供 plus 和 minus 方法可以对当前时间进行加或者减
//看看 890 天后，是什么时候 把 年月日-时分秒
LocalDateTime localDateTime = ldt.plusDays(890);
//看看在 3456 分钟前是什么时候，把 年月日-时分秒
LocalDateTime localDateTime2 = ldt.minusMinutes(3456);
```

#####  DateTimeFormatter

![image-20240309112551648](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309112551648.png) 

#####  Instant 时间戳

![image-20240309112619261](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309112619261.png) 

#### 本章作业

![image-20240309112659936](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309112659936.png) 

![image-20240309112726941](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309112726941.png)  

### 14：集合

#### 数组的缺点

前面我们保存多个数据使用的是数组，而数组有不足的地方

![image-20240309162809195](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309162809195.png) 

#### 集合

**介绍：**

![image-20240309162853015](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309162853015.png) 

**集合框架体系：**

Java 的集合类很多，主要分为两大类，集合主要是两组(**单列集合** , **双列集合**），Collection 接口有两个重要的子接口 **List** 和**Set** , 他们的实现子类都是单列集；Map 接口的实现子类 是双列集合，存放的 **K-V**

1. **Collection**

   ![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309162947303.png) 

2. **Map**

   ![image-20240309163045641](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309163045641.png) 

#### Collection 接口

#####  **特点**

![image-20240309163352481](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309163352481.png) 

##### 使用 Iterator遍历

![image-20240309163614699](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309163614699.png) 

![image-20240309163647889](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309163647889.png) 

![image-20240309163713779](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309163713779.png) 

```java
Collection col = new ArrayList();
col.add(new Book("三国演义", "罗贯中", 10.1));
col.add(new Book("小李飞刀", "古龙", 5.1));
col.add(new Book("红楼梦", "曹雪芹", 34.6));

//1. 先得到 col 对应的 迭代器
Iterator iterator = col.iterator();
//2. 使用 while 循环遍历
while (iterator.hasNext()) {//判断是否还有数据
    Object obj = iterator.next();    //返回下一个元素，类型是 Object
    System.out.println("obj=" + obj);
}

//3. 当退出 while 循环后 , 这时 iterator 迭代器，指向最后的元素
iterator.next();//NoSuchElementException

//4. 如果希望再次遍历，需要重置我们的迭代器
iterator = col.iterator();
```

##### 使用增强for 遍历

![image-20240309164237070](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309164237070.png) 

#### List 接口

 **List 接口基本介绍：**

![image-20240309164428358](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309164428358.png) 

**List 的三种遍历方式：**

![image-20240309164555204](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309164555204.png) 

#### ArrayList类

#####  ArrayList 注意事项

![image-20240309164720678](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309164720678.png) 

##### 底层操作机制

![image-20240309164804936](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309164804936.png) 

##### 源码分析

![image-20240309165014622](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309165014622.png)

#### Vector类

**Vector 的基本介绍:**

![image-20240309165133485](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309165133485.png) 

**Vector 和 ArrayList 的比较:**

![image-20240309165240707](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309165240707.png) 

#### LinkedList类

 **LinkedList说明：**

![image-20240309165344385](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309165344385.png) 

**LinkedList 的底层操作机制：**

![image-20240309165456367](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309165456367.png) 

**ArrayList 和 LinkedList 比较：**

![image-20240309165557406](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309165557406.png) 

#### Set 接口

**基本介绍：**

![image-20240310154100791](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310154100791.png) 

**常用方法：**

和 List 接口一样, Set 接口也是 Collection 的子接口，因此，常用方法和 Collection 接口一样

**遍历方式：**

![image-20240310154225134](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310154225134.png) 

#### HashSet类

##### 介绍

![image-20240310154355827](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310154355827.png) 

##### 底层机制

**HashMap底层：**

![image-20240310154508648](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310154508648.png) 

**运行流程：**

![image-20240310154526665](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310154526665.png) 

![image-20240310154555876](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310154555876.png) 

**扩容和树化流程：**

![image-20240310154651452](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310154651452.png) 

#### LinkedHashSet类

**介绍：**

![image-20240310154940416](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310154940416.png) 

**底层机制：**

![image-20240310155038426](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310155038426.png) 

#### TreeSet类

```java
//1. 当我们使用无参构造器，创建 TreeSet 时，仍然是无序的
TreeSet treeSet = new TreeSet();
//2. 老师希望添加的元素，按照字符串大小来排序
//3. 使用 TreeSet 提供的一个构造器，可以传入一个比较器(匿名内部类)， 并指定排序规则
TreeSet treeSet = new TreeSet(new Comparator() {
    @Override
    public int compare(Object o1, Object o2) {
        return ((String) o1).length() - ((String) o2).length();
    }
}
```



#### Map 接口

##### 介绍

![image-20240310155148144](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310155148144.png) 

![image-20240310155251575](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310155251575.png) 

##### 遍历方法

![image-20240310155358780](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310155358780.png) 

![image-20240310155415049](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310155415049.png) 

#### HashMap类

##### 介绍

![image-20240310155658702](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310155658702.png) 

##### 底层机制

![image-20240310155644731](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310155644731.png) 

![image-20240310155732414](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310155732414.png) 

#### Hashtable类

**介绍：**

![image-20240310155843663](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310155843663.png) 

**Hashtable 和 HashMap对比：**

![image-20240310155941192](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310155941192.png) 

#### Properties类

**介绍：**

![image-20240310160024459](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310160024459.png) 

#### TreeMap类

```java
//1. 当我们使用无参构造器，创建 TreeMap 时，仍然是无序的
TreeMap treeMap = new TreeMap();
//2. 老师希望添加的元素，按照字符串大小来排序
//3. 使用 TreeSet 提供的一个构造器，可以传入一个比较器(匿名内部类)， 并指定排序规则
TreeMap treeMap = new TreeMap(new Comparator() {
    @Override
    public int compare(Object o1, Object o2) {
		return ((String) o2).length() - ((String) o1).length()
    }
}
```

#### 如何选择集合实现类

![image-20240310160133720](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310160133720.png) 

#### Collections 工具类

**介绍:**

![image-20240310160826860](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310160826860.png) 

**排序操作：（均为 static 方法)**

![image-20240310160910975](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310160910975.png) 

**查找、替换操作：**

![image-20240310161004044](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310161004044.png) 

#### 本章作业

![image-20240310183453137](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310183453137.png) 

![image-20240310183505143](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310183505143.png) 

![image-20240310161235533](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240310161235533.png) 

### 15：泛型

**使用传统方法的问题分析：**

![image-20240312163904885](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312163904885.png) 

```java
//使用传统的方法来解决，在Arraylist中添加了三个Dog对象
ArrayList arrayList = new ArrayList();
arrayList.add(new Dog("旺财", 10));
arrayList.add(new Dog("发财", 1));
arrayList.add(new Dog("小黄", 5));
    
//假如我们的程序员，不小心，添加了一只猫
arrayList.add(new Cat("招财猫", 8));

//遍历时就会出错，而且有向下转型的时空间开销
for (Object o : arrayList) {
    //向下转型 Object ->Dog
    Dog dog = (Dog) o;
    System.out.println(dog.getName() + "-" + dog.getAge());
}
```

**泛型快速体验：**

![image-20240312164258141](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312164258141.png) 

```java
//1. 当我们 ArrayList<Dog> 表示存放到 ArrayList 集合中的元素是 Dog 类型
//2. 如果编译器发现添加的类型，不满足要求，就会报错
//3. 在遍历的时候，可以直接取出 Dog 类型而不是 Object

ArrayList<Dog> arrayList = new ArrayList<Dog>();
arrayList.add(new Dog("旺财", 10));
arrayList.add(new Dog("发财", 1));
arrayList.add(new Dog("小黄", 5);

//假如我们的程序员，不小心，添加了一只猫
arrayList.add(new Cat("招财猫", 8));//会编译报错

//直接取出 Dog 类型而不是 Object，意思就是不用向下转型，提高了效率
for (Dog dog : arrayList) {
System.out.println(dog.getName() + "-" + dog.getAge());
}
```

#### 泛型的好处

![image-20240312164738223](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312164738223.png) 

#### 泛型介绍

![image-20240312164834821](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312164834821.png) 

```java
class Person<E> {
    E s;//可以在类声明时通过一个标识表示类中某个属性的类型
    
    public Person(E s) {//E 也可以是参数类型
    	this.s = s;
    }
    
    public E f() {//返回类型也可以使用 E
    	return s;
    }
}
```

#### 泛型语法

##### 泛型的声明

![image-20240312164958429](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312164958429.png) 

##### 泛型的实例化

![image-20240312165040545](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312165040545.png) 

##### 泛型使用举例

![image-20240312165423938](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312165423938.png) 

```java
HashSet<Student> studentHashSet = new HashSet<Student>();
studentHashSet.add(new Student("陈俊宇",23));
studentHashSet.add(new Student("小明",24));
studentHashSet.add(new Student("小红",25));

for (Student student : studentHashSet) {
    System.out.println(student.getName() + "-" + student.getAge());
}

HashMap<String, Student> studentHashMap = new HashMap<>();
studentHashMap.put("陈俊宇",new Student("陈俊宇",23));
studentHashMap.put("小明",new Student("小明",23));
studentHashMap.put("小红",new Student("小红",23));

//先取entrySet，再取itrator，最后取iterator.next()
Set<Map.Entry<String, Student>> entries = studentHashMap.entrySet();
Iterator<Map.Entry<String, Student>> iterator = entries.iterator();
while (iterator.hasNext()) {
    Map.Entry<String, Student> next = iterator.next();
    System.out.println(next.getKey()+"-"+next.getValue().getAge());
}
```

##### 泛型使用的注意事项

![image-20240312171808800](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312171808800.png) 

```java
自定义泛型
//1.给泛型指向数据类型是，要求是引用类型，不能是基本数据类型
List<Integer> list = new ArrayList<Integer>(); //OK
List<int> list2 = new ArrayList<int>();//错误

//2. B是A的子类
//在给泛型指定具体类型后，可以传入该类型或者其子类类型
Pig<A> aPig = new Pig<A>(new A());
Pig<A> aPig2 = new Pig<A>(new B());

//3. 泛型的使用形式，在实际开发中，我们往往简写
ArrayList<Integer> list1 = new ArrayList<Integer>();
List<Integer> list2 = new ArrayList<Integer>();
//等价于
ArrayList<Integer> list3 = new ArrayList<>();
List<Integer> list4 = new ArrayList<>();

//4. 如果是这样写 泛型默认是 Object
ArrayList arrayList = new ArrayList();
//等价于
ArrayList<Object> arrayList = new ArrayList<Object>()
```

#### 自定义泛型

##### 自定义泛型类

![image-20240312185141247](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312185141247.png) 

```java
class Tiger<T, R, M> {
    String name;
	R r; //属性使用到泛型
    T[] ts = new T[10];//错误，因为数组在 new 不能确定 T 的类型，就无法在内存开空间。使用泛型的数组，不能初始化
    static R r2; //错误，因为静态是和类相关的，在类加载时，对象还没有创建。所以，如果静态方法和静态属性使用了泛型，JVM 就无法完成初始化。
    
    public Tiger(R r) {//构造器使用泛型
        this.r = r;
    }
    public void setR(R r) {//方法使用到泛型
    	this.r = r;
    }
}

Tiger<Double,String,Integer> g = new Tiger<>("john");
Tiger g2 = new Tiger("john~~");//OK T=Object R=Object M=Object
```

##### 自定义泛型接口

![image-20240312190108785](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312190108785.png) 

```java
interface IUsb<U, R> {
    int n = 1;
    U name; //不能这样使用
    //普通方法中，可以使用接口泛型
	R get(U u);
}

//在继承接口 指定泛型接口的类型
interface IA extends IUsb<String, Double> {
}
```

##### 自定义泛型方法

![image-20240312190648901](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312190648901.png) 

####  泛型的继承和通配符

![image-20240312190752691](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312190752691.png) 

```java
List<?> list = new ArrayList<>();
List<? extends AA> c list = new ArrayList<>();
List<? super AA> c list = new ArrayList<>();

public static void printCollection3(List<? super AA> c) {};
public static void printCollection1(List<?> c) {};
public static void printCollection2(List<? extends AA> c) {};
```

#### 本章作业

![image-20240312191252043](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312191252043.png) 

### 16：坦克大战

#### java 绘图坐标体系

![image-20240313105756958](C:\Users\cjy\AppData\Roaming\Typora\typora-user-images\image-20240313105756958.png) 

**坐标体系-像素:**

![image-20240313105851236](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240313105851236.png) 

#### 绘图原理

![image-20240313110022641](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240313110022641.png) 

**Graphics 类:**

![image-20240313110105199](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240313110105199.png) 

#### 绘出坦克

![image-20240313110152617](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240313110152617.png) 

![image-20240313110210579](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240313110210579.png) 

#### java 事件处理机制

##### 基本说明

![image-20240313110316761](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240313110316761.png) 

##### 示意图

![image-20240313110345490](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240313110345490.png) 

##### 机制分析

![image-20240313110408373](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240313110408373.png) 

##### 深入理解

![image-20240313110436330](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240313110436330.png) 

![image-20240313110508870](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240313110508870.png) 

![image-20240313110523591](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240313110523591.png) 

#### 本章作业

![image-20240313110615410](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240313110615410.png) 

### 17：多线程基础

#### 进程基本概念

1. 正在运行的程序（软件）就是一个独立的进程
2. 线程是属于进程的，一个进程中可以同时运行很多个线程
3. 进程中的多个线程其实是并发和并行执行的

**并发的含义：**

进程中的线程是由CPU负责调度执行的，但CPU能同时处理线程的数量有限，为了保证全部线程都能往前执行，**CPU会轮询为系统的每个线程服务**，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。

**并行的理解：**

在同一个时刻上，同时有多个线程在被CPU调度执行。

所以说，**多线程是并发和并行同时进行的。**

#### 线程基本概念

**什么是线程：**

![image-20240314111445419](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314111445419.png) 

**什么是多线程：**

![image-20240314111539060](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314111539060.png)

#### 线程的生命周期

1. 线程的生命周期是线程从生到死的过程中，经历的**各种状态及状态转换**。
2. Java总共定义了6种状态，6种状态都定义在Thread类的内部枚举类中。
   ![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314155917176.png) 

3. 线程的6种状态转换
   ![image-20240314160109740](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314160109740.png)

4. 线程六种状态总结
   ![image-20240314160228236](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314160228236.png) 

#### 创建多线程

**Java是通过java.lang.Thread 类的对象来代表线程的**。Java有三种方式创建多线程，分别为：继承Thread类、实现Runnable接口、实现Callable接口。

##### 继承Thead类

**步骤：**

1. 定义一个子类MyThread继承线程类java.lang.Thread，重写run()方法
2. 创建MyThread类的对象
3. 调用线程对象的start()方法启动线程（启动后还是执行run方法的）
   （注意：这里调用start()方法——>start0()方法——>底层调用run()方法，这里是JVM的调用）

```java
//1.定义一个子类MyThread继承线程类java.lang.Thread，重写run()方法
public class MyThread extends Thread {
    @Override
    public void run() {
        for (int i = 1; i <= 3; i++) {
            System.out.println("您好");
        }
    }
}
//2.创建MyThread类的对象
Thread t1 = new MyThread();
//3.调用线程对象的start()方法启动线程
t1.start();
```

**注意事项：**

1. 启动线程必须是调用start方法，不是调用run方法。
   1. 直接调用run方法会当成普通方法执行，此时相当于还是单线程执行。
   2. 只有调用start方法才是启动一个新的线程执行。
2. 不要把主线程任务放在启动子线程之前。因为这样主线程一直是先跑完的，相当于是一个单线程的效果了。

**优缺点：**

优点：编码简单

缺点：线程类已经继承Thread，无法继承其他类，不利于功能的扩展。

##### 实现Runnable接口

**步骤：**

1. 定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法
2. 创建MyRunnable**任务对象**
3. 把MyRunnable任务对象交给Thread处理。
   ![image-20240314112803624](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314112803624.png) 
4. 调用**线程对象**的start()方法启动线程

```java
//1.定义一个线程任务类MyRunnable实现Runnable接口，重写run()方法
public class MyRunnable implements Runnable {
    @Override
    public void run() {
		for (int i = 1; i <= 3; i++) {
            System.out.println("您好");
        }
    }
}
//2.创建MyRunnable任务对象
Runnable runnable = new MyRunnable();
//3.把MyRunnable任务对象交给Thread处理。4.调用线程对象的start()方法启动线程
new Thread(runnable).start();

//用匿名内部类优化
new Thread(new Runnable {
    @Override
    public void run() {
        System.out.println("您好");
    }
}).start();
```

**优缺点:**

优点：任务类只是实现接口，**可以继续继承其他类、实现其他接口，扩展性强**。

缺点：需要多一个Runnable对象。

##### 实现Callable接口

**前两个方式的问题：**

![image-20240314113849925](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314113849925.png) 

**利用Callable接口、FutureTask类来实现的步骤：**

1. 创建任务对象
   1. 定义一个类实现Callable接口，重写call方法，封装要做的事情，和要返回的数据。
   2. **把Callable类型的对象**封装成FutureTask（**线程任务对象**）。
      ![image-20240314115043019](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314115043019.png)
2. 把线程任务对象交给**Thread对象**。
3. 调用Thread对象的start方法启动线程。
4. 线程执行完毕后，通过**FutureTask对象的的get方法**去获取线程任务执行的结果。

```java
//1.1 定义一个类实现Callable接口，重写call方法，封装要做的事情，和要返回的数据。
public class MyCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        System.out.println("您好");
        return "您好";
    }
}
MyCallable myCallable = new MyCallable();
//1.2 把Callable类型的对象封装成FutureTask（线程任务对象）。
FutureTask<String> stringFutureTask = new FutureTask<>(myCallable);
//2. 把线程任务对象交给Thread对象。
Thread thread = new Thread(stringFutureTask);
//3. 调用Thread对象的start方法启动线程。
thread.start();
//4. 线程执行完毕后，通过FutureTask对象的的get方法去获取线程任务执行的结果
String s = stringFutureTask.get();
```

**优缺点:**

优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强；可以在线程执行完毕后去获取线程执行的结果。

缺点：编码复杂一点。

![image-20240314115151846](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314115151846.png) 

#### Thread常用方法

![image-20240314140152345](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314140152345.png) 

```java
public class MyThread extends Thread{
    public MyThread(String name){
        super(name); //1.执行父类Thread(String name)构造器，为当前线程设置名字了
    }
    @Override
    public void run() {
        //2.currentThread() 哪个线程执行它，它就会得到哪个线程对象。
        Thread t = Thread.currentThread();
        for (int i = 1; i <= 3; i++) {
            //3.getName() 获取线程名称
            System.out.println(t.getName() + "输出：" + i);
        }
    }
}
```

#### 线程安全

多个线程，同时操作同一个共享资源的时候，可能会出现业务安全问题。

![image-20240314140627270](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314140627270.png) 

#### 线程同步

解决线程安全问题的方案。

线程同步的思想是**让多个线程实现先后依次访问共享资源**，这样就解决了安全问题。

线程同步的常见方案是**加锁**：每次只允许一个线程加锁，加锁后才能进入访问，访问完毕后自动解锁，然后其他线程才能再加锁进来。

线程同步有三种方式分别是：同步代码块、同步方法、Lock锁

##### 同步代码块

**作用：**

把访问共享资源的核心代码给上锁，以此保证线程安全。对出现问题的核心代码**使用synchronized进行加锁**，每次只能一个线程占锁进入访问

![image-20240314141114951](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314141114951.png)  

**原理：**

每次只允许一个线程加锁后进入，执行完毕后自动解锁，其他线程才可以进来执行。

**注意事项：**

1. 对于当前同时执行的线程来说，**同步锁必须是同一把（同一个对象）**，否则会出bug。
2. 锁对象**不能随便选择一个唯一的对象**，因为会影响其他无关线程的执行。
3. 建议使用共享资源作为锁对象，对于**实例方法建议使用this作为锁对象**。
4. 对于**静态方法建议使用字节码（类名.class）对象作为锁对象**。

```java
// 小明 小红线程同时过来的
public void drawMoney(double money) {
    String name = Thread.currentThread().getName();    // 先搞清楚是谁来取钱？
    //1. 对于实例方法建议使用this作为锁对象
    synchronized (this) {
        if(this.money >= money){
            System.out.println(name + "来取钱" + money + "成功！");
            this.money -= money;
            System.out.println(name + "来取钱后，余额剩余：" + this.money);
        }else {
            System.out.println(name + "来取钱：余额不足~");
        }
    }
}

//静态方法
public static void drawMoney(double money) {
    String name = Thread.currentThread().getName();    // 先搞清楚是谁来取钱？
    //2. 静态方法建议使用字节码（类名.class）对象作为锁对象
    synchronized (drawMoney.class) {
        if(this.money >= money){
            System.out.println(name + "来取钱" + money + "成功！");
            this.money -= money;
            System.out.println(name + "来取钱后，余额剩余：" + this.money);
        }else {
            System.out.println(name + "来取钱：余额不足~");
        }
    }
}
```

##### 同步方法

其实同步方法，**就是把整个方法给锁住**，一个线程调用这个方法，另一个线程调用的时候就执行不了，只有等上一个线程调用结束，下一个线程调用才能继续执行。

![image-20240314142120207](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314142120207.png) 

**底层原理：**

1. 同步方法其实底层也是有隐式锁对象的，只是锁的范围是整个方法代码。
2. 如果方法是实例方法：同步方法默认用this作为的锁对象。
3. 如果方法是静态方法：同步方法默认用类名.class作为的锁对象。

**同步代码块VS同步方法：**

范围上：同步代码块锁的范围更小，同步方法锁的范围更大。

可读性：同步方法更好。

```java
// 同步方法
public synchronized void drawMoney(double money) {
    // 先搞清楚是谁来取钱？
    String name = Thread.currentThread().getName();
    // 1、判断余额是否足够
    if(this.money >= money){
        System.out.println(name + "来取钱" + money + "成功！");
        this.money -= money;
        System.out.println(name + "来取钱后，余额剩余：" + this.money);
    }else {
        System.out.println(name + "来取钱：余额不足~");
    }
}
```

##### Lock锁

Lock锁是JDK5版本专门提供的一种锁对象，通过这个锁对象的方法来达到加锁，和释放锁的目的，使用起来更加灵活。

Lock是接口，不能直接实例化，可以采用它的实现类ReentrantLock来构建Lock锁对象。

![image-20240314142543119](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314142543119.png) 

```java
1.首先在成员变量位子，需要创建一个Lock接口的实现类对象（这个对象就是锁对象）
	private final Lock lk = new ReentrantLock();
2.在需要上锁的地方加入下面的代码
	 lk.lock(); // 加锁
	 //...中间是被锁住的代码...
	 lk.unlock(); // 解锁
```

```java
// 先创建了一个锁对象
private final Lock lk = new ReentrantLock();

public void drawMoney(double money) {
        // 先搞清楚是谁来取钱？
        String name = Thread.currentThread().getName();
        try {
            lk.lock(); // 加锁
            // 1、判断余额是否足够
            if(this.money >= money){
                System.out.println(name + "来取钱" + money + "成功！");
                this.money -= money;
                System.out.println(name + "来取钱后，余额剩余：" + this.money);
            }else {
                System.out.println(name + "来取钱：余额不足~");
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            lk.unlock(); // 解锁
        }
    }
}
```

#### 线程池

##### 线程池工作原理

线程池就是一个可以**复用线程的技术**。如果不使用线程池，用户每发起一个请求，后台就需要创建一个新线程来处理，下次新任务来了肯定又要创建新线程处理的，  而创建新线程的开销是很大的，并且请求过多时，肯定会产生大量的线程出来，这样会严重影响系统的性能。

![image-20240314160532753](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314160532753.png) 

##### 创建线程池

JDK 5.0起提供了代表线程池的**接口：ExecutorService**。有两种方式创建线程池对象分别是：

方式一、使用ExecutorService的实现类**ThreadPoolExecutor**自创建一个线程池对象；
![image-20240314160820300](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314160820300.png) 

方式二、使用**Executors**（线程池的工具类）调用方法返回不同特点的线程池对象。

##### ThreadPoolExecutor

**ThreadPoolExecutor构造器：**

![image-20240314160957384](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314160957384.png)

![image-20240314161022252](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314161022252.png) 

```java
ExecutorService pool = new ThreadPoolExecutor(
    3,	//核心线程数有3个
    5,  //最大线程数有5个。   临时线程数=最大线程数-核心线程数=5-3=2
    8,	//临时线程存活的时间8秒。 意思是临时线程8秒没有任务执行，就会被销毁掉。
    TimeUnit.SECONDS,//时间单位（秒）
    new ArrayBlockingQueue<>(4), //任务阻塞队列，没有来得及执行的任务在，任务队列中等待
    Executors.defaultThreadFactory(), //用于创建线程的工厂对象
    new ThreadPoolExecutor.CallerRunsPolicy() //拒绝策略
);
```

**新任务拒绝策略：**

![image-20240314161456630](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314161456630.png) 

**注意事项：**

![image-20240314161159124](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314161159124.png) 

##### 执行Runnable任务

创建好线程池之后，接下来我们就可以使用线程池执行任务了。线程池执行的任务可以有两种，**一种是Runnable任务；一种是callable任务**。

![image-20240314161353570](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314161353570.png) 

下面的execute方法可以用来执行Runnable任务。

先准备一个线程任务类

```java
public class MyRunnable implements Runnable{
    @Override
    public void run() {
        // 任务是干啥的？
        System.out.println(Thread.currentThread().getName() + " ==> 输出666~~");
        //为了模拟线程一直在执行，这里睡久一点
        try {
            Thread.sleep(Integer.MAX_VALUE);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

下面是执行Runnable任务的代码，注意阅读注释，对照着前面的7个参数理解。

```java
ExecutorService pool = new ThreadPoolExecutor(
    3,	//核心线程数有3个
    5,  //最大线程数有5个。   临时线程数=最大线程数-核心线程数=5-3=2
    8,	//临时线程存活的时间8秒。 意思是临时线程8秒没有任务执行，就会被销毁掉。
    TimeUnit.SECONDS,//时间单位（秒）
    new ArrayBlockingQueue<>(4), //任务阻塞队列，没有来得及执行的任务在，任务队列中等待
    Executors.defaultThreadFactory(), //用于创建线程的工厂对象
    new ThreadPoolExecutor.CallerRunsPolicy() //拒绝策略
);

Runnable target = new MyRunnable();
pool.execute(target); // 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！
pool.execute(target); // 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！
pool.execute(target); // 线程池会自动创建一个新线程，自动处理这个任务，自动执行的！
//下面4个任务在任务队列里排队
pool.execute(target);
pool.execute(target);
pool.execute(target);
pool.execute(target);

//下面2个任务，会被临时线程的创建时机了
pool.execute(target);
pool.execute(target);
// 到了新任务的拒绝时机了！
pool.execute(target);
```

![image-20240314162411893](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314162411893.png) 

##### 执行Callable任务

callable任务相对于Runnable任务来说，就是多了一个返回值。执行Callable任务需要用到下面的submit方法

先准备一个Callable线程任务

```java
public class MyCallable implements Callable<String> {
    private int n;
    public MyCallable(int n) {
        this.n = n;
    }

    // 2、重写call方法
    @Override
    public String call() throws Exception {
        // 描述线程的任务，返回线程执行返回后的结果。
        // 需求：求1-n的和返回。
        int sum = 0;
        for (int i = 1; i <= n; i++) {
            sum += i;
        }
        return Thread.currentThread().getName() + "求出了1-" + n + "的和是：" + sum;
    }
}
```

再准备一个测试类，在测试类中创建线程池，并执行callable任务。

```java
public class ThreadPoolTest2 {
    public static void main(String[] args) throws Exception {
        // 1、通过ThreadPoolExecutor创建一个线程池对象。
        ExecutorService pool = new ThreadPoolExecutor(
            3,
            5,
            8,
            TimeUnit.SECONDS, 
            new ArrayBlockingQueue<>(4),
            Executors.defaultThreadFactory(),
            new ThreadPoolExecutor.CallerRunsPolicy());

        // 2、使用线程处理Callable任务。
        Future<String> f1 = pool.submit(new MyCallable(100));
        Future<String> f2 = pool.submit(new MyCallable(200));
        Future<String> f3 = pool.submit(new MyCallable(300));
        Future<String> f4 = pool.submit(new MyCallable(400));

        // 3、执行完Callable任务后，需要获取返回结果。
        System.out.println(f1.get());
        System.out.println(f2.get());
        System.out.println(f3.get());
        System.out.println(f4.get());
    }
}
```

##### Executors

线程池工具类（Executors）

有同学可能会觉得前面创建线程池的代码参数太多、记不住，有没有快捷的创建线程池的方法呢？有的。Java为开发者提供了一个创建线程池的工具类，叫做Executors，它提供了方法可以创建各种不能特点的线程池。如下图所示 

![image-20240314162940886](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314162940886.png) 

```java
// 1、通过Executors创建一个线程池对象。
ExecutorService pool = Executors.newFixedThreadPool(17);

// 计算密集型的任务：核心线程数量 = CPU的核数 + 1
// IO密集型的任务：核心线程数量 = CPU核数 * 2
```

Executors创建线程池这么好用，为什么不推荐同学们使用呢？原因在这里：看下图，这是《阿里巴巴Java开发手册》提供的强制规范要求。

![image-20240314163109093](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240314163109093.png) 

### 18：IO流

#### 文件

**文件概念：**

![image-20240316111657696](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316111657696.png) 

**文件流：**

![image-20240316111724161](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316111724161.png) 

#### 文件操作

##### 创建文件对象

![image-20240316111835857](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316111835857.png) 

```java
//方式一
String filePath = "e:\\news1.txt";
File file = new File(filePath);
//方式二
File parentFile = new File("e:\\");
String fileName = "news2.txt";
File file = new File(parentFile, fileName);
//方式三
String parentPath = "e:\\";
String fileName = "news4.txt";
File file = new File(parentPath,fileName);

file.createNewFile();//如果路径没有该文件，就创建。
```

##### 获取文件的相关信息

![image-20240316112244798](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316112244798.png) 

```java
System.out.println("文件名字=" + file.getName());

System.out.println("文件绝对路径=" + file.getAbsolutePath());

System.out.println("文件父级目录=" + file.getParent();
                   
System.out.println("文件大小(字节)=" + file.length());
                   
System.out.println("文件是否存在=" + file.exists());
                   
System.out.println("是不是一个文件=" + file.isFile());
                   
System.out.println("是不是一个目录=" + file.isDirectory());               
```

##### 目录的操作

![image-20240316112526329](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316112526329.png) 

#### IO 流原理及流的分类

##### Java IO 流原理

![image-20240316112607182](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316112607182.png) 

##### 流的分类

![image-20240316112659411](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316112659411.png) 

#### IO 流体系

##### IO 流体系图

![image-20240316112809966](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316112809966.png) 

##### FileInputStream

```java
//单个字节的读取，效率比较低
String filePath = "e:\\hello.txt";
int readData = 0;
FileInputStream fileInputStream = null;

try {
    //创建 FileInputStream 对象，用于读取 文件
    fileInputStream = new FileInputStream(filePath);
    //从该输入流读取一个字节的数据。 如果没有输入可用，此方法将阻止,如果返回-1 , 表示读取完
    while ((readData = fileInputStream.read()) != -1) {
        System.out.print((char)readData);//转成 char 显示
    }
}catch (IOException e) {
	e.printStackTrace();
}finally {
    //关闭文件流，释放资源.
	fileInputStream.close();
}

//使用 read(byte[] b) 读取文件，提高效率
String filePath = "e:\\hello.txt";
byte[] buf = new byte[8]; //一次读取 8 个字节. 
int readLen = 0;
FileInputStream fileInputStream = null;
try {
    //创建 FileInputStream 对象，用于读取 文件
    fileInputStream = new FileInputStream(filePath);
    //从该输入流读取最多 b.length 字节的数据到字节数组。 此方法将阻塞，直到某些输入可用。
    //如果返回-1 , 表示读取完毕
    //如果读取正常, 返回实际读取的字节数
    while ((readLen = fileInputStream.read(buf)) != -1) {
        System.out.print(new String(buf, 0, readLen));//显示
}catch (IOException e) {
	e.printStackTrace();
} finally {
    //关闭文件流，释放资源.
	fileInputStream.close();
}
```

##### FileOutputStream

![image-20240316113714829](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316113714829.png) 

```java
String destFilePath = "e:\\Koala3.jpg";
FileOutputStream fileOutputStream = null;
fileOutputStream = new FileOutputStream(destFilePath);
fileOutputStream.write('1');//一定要使用这个方法
fileOutputStream.close();
```

##### FileReader

![image-20240316114128666](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316114128666.png) 

![image-20240316113955271](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316113955271.png) 

##### FileWriter

![image-20240316114023550](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316114023550.png) 

#### 节点流和处理(包装)流

##### 基本介绍

![image-20240316114208634](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316114208634.png) 

##### 节点流和处理流

![image-20240316114314030](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316114314030.png) 

##### 区别和联系

![image-20240316114510836](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316114510836.png) 

##### 处理流的功能

![image-20240316114643340](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316114643340.png) 

##### BufferedReader &&  BufferedWriter(缓冲流字符流)

![image-20240316114811847](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316114811847.png) 

```java
String filePath = "e:\\a.java";

//创建 bufferedReader
BufferedReader bufferedReader = new BufferedReader(new FileReader(filePath));
String line; //按行读取, 效率高
//说明
//1. bufferedReader.readLine() 是按行读取文件
//2. 当返回 null 时，表示文件读取完
while ((line = bufferedReader.readLine()) != null) {
	System.out.println(line);
}

//关闭流, 这里注意，只需要关闭 BufferedReader ，因为底层会自动的去关闭 节点流
bufferedReader.close();
```

##### BufferedInputStream && BufferedOutputStream（缓冲流字节流）

![image-20240316115104758](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316115104758.png) 

![image-20240316115134437](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316115134437.png) 

```java
String srcFilePath = "e:\\a.java";
bis = new BufferedInputStream(new FileInputStream(srcFilePath));
byte[] buff = new byte[1024];
while ((readLen = bis.read(buff)) != -1) {}
```

##### ObjectInputStream && ObjectOutputStream（对象流）

###### 序列化和反序列化

![image-20240316115455946](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316115455946.png) 

![image-20240316115524224](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316115524224.png) 

###### 对象流介绍

功能：提供了对基本类型或对象类型的序列化和反序列化的方法 

ObjectOutputStream 提供 序列化功能 

ObjectInputStream 提供 反序列化功能

![image-20240316115639687](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316115639687.png) 

```java
//序列化后，保存的文件格式，不是存文本，而是按照他的格式来保存
String filePath = "e:\\data.dat";
ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath));

//序列化数据到 e:\data.dat
oos.writeInt(100);// int -> Integer (实现了 Serializable)
oos.writeBoolean(true);// boolean -> Boolean (实现了 Serializable)
oos.writeChar('a');// char -> Character (实现了 Serializable)
oos.writeDouble(9.5);// double -> Double (实现了 Serializable)
oos.writeUTF("韩顺平教育");//String
//保存一个 dog 对象
oos.writeObject(new Dog("旺财", 10, "日本","白色"));
oos.close();
```

```java
// 1.创建流对象
ObjectInputStream ois = new ObjectInputStream(new FileInputStream("src\\data.dat"));
// 2.读取， 注意顺序
System.out.println(ois.readInt());
System.out.println(ois.readBoolean());
System.out.println(ois.readChar());
System.out.println(ois.readDouble());
System.out.println(ois.readUTF());
System.out.println(ois.readObject());
System.out.println(ois.readObject());
System.out.println(ois.readObject());
// 3.关闭
ois.close();
```

###### 细节注意

![image-20240316115903209](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316115903209.png) 

##### InputStreamReader && OutputStreamWriter（转换流）

###### 标准输入输出流

![image-20240316120114468](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316120114468.png) 

###### 基本介绍

![image-20240316133551918](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316133551918.png) 

```java
String filePath = "e:\\a.txt";
//解读
//1. 把 FileInputStream 转成 InputStreamReader
//2. 指定编码 gbk
InputStreamReader isr = new InputStreamReader(new FileInputStream(filePath), "gbk");
//3. 把 InputStreamReader 传入 BufferedReader
BufferedReader br = new BufferedReader(isr);
//4. 读取
String s = br.readLine();
//5. 关闭外层流
br.close();

```

##### PrintStream  && PrintWriter（打印流）

![image-20240316133958542](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316133958542.png) 

![image-20240316134011666](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316134011666.png) 

```java
PrintStream out = System.out;
//在默认情况下，PrintStream 输出数据的位置是 标准输出，即显示器
out.print("john, hello");
//因为 print 底层使用的是 write , 所以我们可以直接调用 write 进行打印/输出
out.write("韩顺平,你好".getBytes());
out.close();

//我们可以去修改打印流输出的位置/设备
//1. 输出修改成到 "e:\\f1.txt"
//2. "hello, 韩顺平教育~" 就会输出到 e:\f1.tx
System.setOut(new PrintStream("e:\\f1.txt"));
System.out.println("hello, 韩顺平教育~");
printWriter.close();//flush + 关闭流, 才会将数据写入到文件.
```

#### Properties 类

##### 需求

![image-20240316134605350](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316134605350.png) 

![image-20240316134659565](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316134659565.png) 

##### 基本介绍

![image-20240316134743328](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316134743328.png) 

```java
//使用 Properties 类来读取 mysql.properties 文件

//1. 创建 Properties 对象
Properties properties = new Properties();
//2. 加载指定配置文件
properties.load(new FileReader("src\\mysql.properties"));
//3. 把 k-v 显示控制台
properties.list(System.out);
//4. 根据 key 获取对应的值
String user = properties.getProperty("user");
String pwd = properties.getProperty("pwd");
System.out.println("用户名=" + user);
System.out.println("密码是=" + pwd);
//5.注意保存时，是中文的 unicode 码值
properties.setProperty("user", "汤姆");
properties.setProperty("pwd", "888888");
//6.将 k-v 存储文件中即可
properties.store(new FileOutputStream("src\\mysql2.properties"), null);
```

#### 本章作业

![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240316135123389.png) 

### 19：网络编程

#### 网络的相关概念

##### 网络通信

![image-20240317091817534](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240317091817534.png) 

##### 网络

![image-20240317091900023](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240317091900023.png) 

##### ip 地址

![image-20240317091935669](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240317091935669.png) 

##### ipv4 地址分类

![image-20240317092031840](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240317092031840.png) 

##### 域名

![image-20240317092117158](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240317092117158.png) 

#### 网络通信协议

![image-20240317092230751](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240317092230751.png) 

![image-20240317092302910](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240317092302910.png) 

![image-20240317092332184](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240317092332184.png) 

#### TCP 和 UDP

![ ](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240317092357589.png) 

#### InetAddress 类

![image-20240317092508089](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240317092508089.png) 

```java
//获取本机 InetAddress 对象 getLocalHost
InetAddress localHost = InetAddress.getLocalHost();

//根据指定主机名/域名获取 ip 地址对象 getByName
InetAddress host2 = InetAddress.getByName("ThinkPad-PC");
System.out.println(host2);
InetAddress host3 = InetAddress.getByName("www.baidu.com");
System.out.println(host3);

//获取 InetAddress 对象的主机名 getHostName
String host3Name = host3.getHostName();
System.out.println(host3Name);

//获取 InetAddress 对象的地址 getHostAddress
String host3Address = host3.getHostAddress();
System.out.println(host3Address);
```

#### Socket

![image-20240317092815153](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240317092815153.png) 

![image-20240317092842287](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240317092842287.png) 

#### TCP 网络通信编程

##### 基本介绍

![image-20240317092922695](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240317092922695.png) 

##### 案例1：使用字节流

![image-20240317093158380](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240317093158380.png) 

**步骤：**

1. **服务器端：**

   ```java
   //1. 在本机 的 9999 端口监听, 等待连接
   //2. 当没有客户端连接 9999 端口时，程序会 阻塞, 等待连接
   //3. 通过 socket.getInputStream() 读取客户端写入到数据通道的数据, 显示
   //4. IO 读取
   //5. 通过输出流，写入数据到 数据通道
   //6.关闭流和 socket
   ```

   ```java
   //1. 在本机 的 9999 端口监听, 等待连接
   // 细节: 要求在本机没有其它服务在监听 9999
   // 细节：这个 ServerSocket 可以通过 accept() 返回多个 Socket[多个客户端连接服务器的并发]
   ServerSocket serverSocket = new ServerSocket(9999);
   System.out.println("服务端，在9999端口监听，等待连接");
   
   //2. 当没有客户端连接 9999 端口时，程序会 阻塞, 等待连接
   // 如果有客户端连接，则会返回 Socket 对象，程序继续
   Socket socket = serverSocket.accept();
   System.out.println("服务器 socket = " + socket.getClass());
   
   //3. 通过 socket.getInputStream() 读取客户端写入到数据通道的数据, 显示
   InputStream inputStream = socket.getInputStream();
   
   //4. IO 读取
   byte[] bytes = new byte[1024];
   int readLen = 0;
   while ((readLen = inputStream.read(bytes)) != -1) {
       System.out.println(new String(bytes,0,readLen));//根据读取到的实际长度，显示内容
   }
   
   //5. 通过输出流，写入数据到 数据通道
   OutputStream outputStream = socket.getOutputStream();
   outputStream.write("hello, client".getBytes());
   socket.shutdownOutput();// 设置结束标记
   
   //6.关闭流和 socket
   outputStream.close();
   inputStream.close();
   socket.close();
   serverSocket.close();
   System.out.println("服务器端退出....");
   ```

2. **客户端：**

   ```java
   //1. 连接服务端 (ip , 端口）
   //2. 连接上后，生成 Socket, 通过 socket.getOutputStream,得到 和 socket 对象关联的输出流对
   //3. 通过输出流，写入数据到 数据通道
   //4. 通过输入流，从 数据通道 读取数据
   //5. 关闭流对象和 socket, 必须关闭
   ```

   ```java
   //1. 连接服务端 (ip , 端口）
   //解读: 连接本机的 9999 端口, 如果连接成功，返回 Socket 对
   Socket socket = new Socket(InetAddress.getLocalHost(),9999);
   System.out.println("客户端 socket 返回=" + socket.getClass());
   
   //2. 连接上后，生成 Socket, 通过 socket.getOutputStream,得到 和 socket 对象关联的输出流对
   OutputStream outputStream = socket.getOutputStream();
   
   //3. 通过输出流，写入数据到 数据通道
   outputStream.write("hello, server".getBytes());
   socket.shutdownOutput();// 设置结束标记
   
   //4. 通过输入流，从 数据通道 读取数据
   InputStream inputStream = socket.getInputStream();
   byte[] bytes = new byte[1024];
   int readLen;
   while ((readLen = inputStream.read(bytes)) != -1) {
       System.out.println(new String(bytes,0,readLen));
   }
   
   //5. 关闭流对象和 socket, 必须关闭
   inputStream.close();
   outputStream.close();
   socket.close();
   System.out.println("客户端退出.....");
   ```

##### 案例2：使用字符流

![image-20240317093217779](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240317093217779.png) 

1. **服务器端：**

   ```java
   ServerSocket serverSocket = new ServerSocket(9999);
   System.out.println("服务器端已启动，正在监听9999端口....");
   Socket socket = serverSocket.accept();
   
   InputStream inputStream = socket.getInputStream();
   //转换流
   InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
   //缓冲流
   BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
   String Line = bufferedReader.readLine();
   System.out.println(Line);
   
   
   BufferedWriter bufferedWriter = new BufferedWriter(new OutputStreamWriter(socket.getOutputStream()));
   bufferedWriter.write("hello, client");
   bufferedWriter.newLine();//插入一个换行符，表示写入的内容结束, 注意，要求对方使用 readLine()!!!!
   bufferedWriter.flush();// 如果使用的字符流，需要手动刷新，否则数据不会写入数据通道
   
   bufferedWriter.close();
   bufferedReader.close();
   socket.close();
   serverSocket.close();
   ```

2. **客户端：**

   ```java
    Socket socket = new Socket(InetAddress.getLocalHost(),9999);
   
   OutputStream outputStream = socket.getOutputStream();
   OutputStreamWriter outputStreamWriter = new OutputStreamWriter(outputStream);
   BufferedWriter bufferedWriter = new BufferedWriter(outputStreamWriter);
   bufferedWriter.write("Hello, Server");
   bufferedWriter.newLine();//插入一个换行符，表示写入的内容结束, 注意，要求对方使用 readLine()!!!!
   bufferedWriter.flush();// 如果使用的字符流，需要手动刷新，否则数据不会写入数据通道
   
   BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(socket.getInputStream()));
   String Line = bufferedReader.readLine();
   System.out.println(Line);
   
   bufferedReader.close();
   bufferedWriter.close();
   socket.close();
   ```

#### netstat 指令

![image-20240317093401309](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240317093401309.png) 

**netstat -anb 在管理员状态下的dos中输入，可以看到对应的应用程序**

#### TCP 网络细节

![image-20240317093537193](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240317093537193.png) 

#### UDP网络通信编程

##### 基本介绍

![image-20240317093637430](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240317093637430.png) 

##### 基本流程

![image-20240317093711299](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240317093711299.png) 

##### 应用案例

![image-20240317093754124](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240317093754124.png) 

#### 本章作业

![image-20240317093828267](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240317093828267.png)  

### 20：反射机制

#### 静态 VS 动态语言

**动态语言：**

1. 是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的 函数可以被删除或是其他结构上的变化。通俗点说就是**在运行时代码可以根据某些条件改变自 身结构**。
2. 主要动态语言：Object-C、C#、JavaScript、PHP、Python等。

**静态语言：**

1. 与动态语言相对应的，**运行时结构不可变的语言就是静态语言**。如Java、C、C++。
2. Java不是动态语言，但Java可以称之为“**准动态语言**”。即Java有一定的动态性，我们可以**利用 反射机制获得类似动态语言的特性**。Java的动态性让编程的时候更加灵活！

#### Java Reflection

Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取 得任何类的内部信息，并能直接操作任意对象的内部属性及方法。

```java
Class c = Class.forName("java.lang.String")
```

加载完类之后，在堆内存的**方法区中就产生了一个Class类型的对象**（一个类只有一个Class对象，**类对象**），这 个类对象就包含了完整的类的结构信息。我们可以通过这个类对象看到类的结构。**这个类对象就像一面镜子， 透过这个镜子看到类的结构，所以，我们形象的称之为：反射**

![image-20240321114210448](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240321114210448.png) 

**Java反射机制提供的功能：**

* 在运行时判断任意一个对象所属的类 
* 在运行时构造任意一个类的对象 
* 在运行时判断任意一个类所具有的成员变量和方法 
* 在运行时获取泛型信息 
* 在运行时调用任意一个对象的成员变量和方法 
* 在运行时处理注解 
* 生成动态代理 ........

**Java反射优点和缺点:**

优点：可以实现动态创建对象和编译，体现出很大的灵活性 ! 

缺点：对性能有影响。**使用反射基本上是一种解释操作**，我们可以告诉JVM，我们希望做什么并且它满 足我们的要求。**这类操作总是慢于 直接执行相同的操作**。

#### 反射相关的主要API

* java.lang.Class : 代表一个类 
* java.lang.reflect.Method : 代表类的方法 
* java.lang.reflect.Field : 代表类的成员变量 
* java.lang.reflect.Constructor : 代表类的构造器 .......

#### Class类

在Object类中定义了以下的方法，此方法将被所有子类继承

```java
public final Class getClass();
```

以上的方法返回值的类型是一个**Class类型**，**此类是Java反射的源头**，实际上所谓反射从程序的运行结果来 看也很好理解，即：可以通过对象反射求出类的名称。

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240321114927097.png" alt="image-20240321114927097" style="zoom:50%;" /> 

对象照镜子后可以得到的信息：某个类的属性、方法和构造器、某个类到底实现了哪些接口。对于每个 类而言，JRE 都为其保留一个不变的 Class 类型的对象。

* Class 本身也是一个类 
* Class 对象只能由系统建立对象 
* 一个加载的类在 JVM 中只会有一个Class实例 
* 一个Class对象对应的是一个加载到JVM中的一个.class文件 
* 每个类的实例都会记得自己是由哪个 Class 实例所生成 
* 通过Class可以完整地得到一个类中的所有被加载的结构 
* Class类是Reflection的根源，针对任何你想动态加载、运行的类，唯有先获得相应的Class对象

##### 获得Class对象的方式

```java
		Person person = new Person();

        System.out.println("这个人是:"+person.name);

        //获得class办法一:通过对象获得
        Class c1 = person.getClass();
        System.out.println(c1);

        //获得class办法二:通过类的静态成员class获得（这是最快的）
        Class c2 = Person.class;
        System.out.println(c2);

        //获得class办法三:通过字符串获得(包名+类名) （这是最常用的）
        Class c3 = Class.forName("com.cjy.reflection_.Student");
        System.out.println(c3);

        //获得class办法四:只针对内置的基本数据类型
        Class c4 = Integer.TYPE;
        System.out.println(c4);

        //获得父类类型，c3是student类，它的父类是person
        Class c5 = c3.getSuperclass();
        System.out.println(c5);
```

a）若已知具体的类，通过类的class属性获取，该方法最为安全可靠，程序性能最高。 

```java
Class clazz = Person.class;
```

b）已知某个类的实例，调用该实例的getClass()方法获取Class对象 

```java
Class clazz = person.getClass();
```

c）已知一个类的全类名，且该类在类路径下，可通过Class类的静态方法forName()获取，可能抛出 ClassNotFoundException 

```java
Class clazz = Class.forName("demo01.Student");
```

d）内置基本数据类型可以直接用类名.Type 

e）还可以利用ClassLoader我们之后讲解

##### Class类的常用方法

通过反射可以获取运行时类的完整结构，如下：

Field、Method、Constructor、Superclass、Interface、Annotation

虽然在实际的操作中，取得类的信息的操作代码，并不会经常开发，但是一定要熟悉java.lang.reflect包的作用，反射机制。

![image-20240321120337587](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240321120337587.png) 

```java
		Class userClass = Class.forName("com.cjy.reflection_.User");
        //调用缺省构造函数，返回Class对象的一个实例
        User user = (User)userClass.newInstance();
        System.out.println(user);

        //返回此Class对象所表示的实体的名称
        String name = userClass.getName();
        System.out.println(name);

        //返回当前Class对象的父类的class对象
        Class superclass = userClass.getSuperclass();
        System.out.println(superclass);

        //获取当前Class对象的接口
        Class[] interfaces = userClass.getInterfaces();
        for (Class anInterface : interfaces) {
            System.out.println(anInterface);
        }

        //返回该类的类加载器
        ClassLoader classLoader = userClass.getClassLoader();
        System.out.println(classLoader);

        //返回一个包含默写Constructor对象的数组
        Constructor[] constructors = userClass.getConstructors();
        for (Constructor constructor : constructors) {
            System.out.println(constructor);
        }

        //返回一个Method对象，此对象的形参类型为paramType
        Method setId = userClass.getMethod("setId", Integer.TYPE);
        System.out.println(setId);

        //返回Field对象的一个数组（Declared说明就算是private属性，也可以获取）
        Field[] declaredFields = userClass.getDeclaredFields();
        for (Field declaredField : declaredFields) {
            System.out.println(declaredField);
        }
        //返回Field对象的一个数组（没有Declared，那就只能获取public的属性）
        Field[] fields = userClass.getFields();
        for (Field field : fields) {
            System.out.println(field);
        }
```



##### Class对象的类型

哪些类型可以有Class对象？

* class：外部类，成员内部类，静态内部类，局部内部类，匿名内部类。 
* interface：接口 
* []：数组
* enum：枚举 
* annotation：注解@interface 
* primitive type：基本数据类型 
* void

```java
Class<Object> objectClass = Object.class;
Class<Comparator> comparatorClass = Comparator.class;
Class<String[]> aClass = String[].class;
Class<ElementType> elementTypeClass = ElementType.class;
Class<Override> overrideClass = Override.class;
Class<Integer> integerClass = int.class;
Class<Void> voidClass = void.class;
```

#### Java内存分析

![image-20240321142846382](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240321142846382.png) 

##### 类的加载过程

![image-20240321142946317](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240321142946317.png) 

##### 类的加载理解

**加载：** 
将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构， 然后**生成一个代表这个类的java.lang.Class对象**.

**链接：**
将Java类的二进制代码合并到JVM的运行状态之中的过程。

* 验证：确保加载的类信息符合JVM规范，没有安全方面的问题
* 准备：**正式为类变量（static）分配内存并设置类变量默认初始值或为常量赋值的阶段**，，这些内存都将在方 法区中进行分配。
* 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程。

**初始化：**

* 执行类构造器()方法的过程。类构造器()方法**是由编译期自动收集类中所有类变量的赋值动作 和静态代码块中的语句合并产生的**。（类构造器是构造类信息的，**不是构造该类对象的构造 器**，即：类构造器 != 类的构造器 ）。
* 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化。
* 虚拟机会保证一个类的()方法在多线程环境中被正确加锁和同步。

##### 类初始化的时机

**类的主动引用（一定会发生类的初始化）：**

* 当虚拟机启动，先初始化main方法所在的类
* new一个类的对象
* 调用类的静态成员（除了final常量）和静态方法
* 使用java.lang.reflect包的方法对类进行反射调用
* 当初始化一个类，如果其父类没有被初始化，则先会初始化它的父类

**类的被动引用（不会发生类的初始化）：**

* 当访问一个静态域时，只有真正声明这个域的类才会被初始化。如：当通过子类引用父类的静 态变量，不会导致子类初始化
* 通过数组定义类引用，不会触发此类的初始化
* 引用常量（final）不会触发此类的初始化（常量在链接阶段就存入调用类的常量池中了）

##### 类加载器的作用

**类加载的作用：**
将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数 据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入 口。

**类缓存：**
标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持 加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象

![image-20240321144115403](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240321144115403.png) 

**类加载器：**

类加载器作用是用来把类(class)装载进内存的。JVM 规范定义了如下类型的类的加载器

![image-20240321144222334](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240321144222334.png) 

#### Class对象的作用

##### 调用指定的构造函数

**创建类的对象：**调用Class对象的newInstance()方法 

1. 类必须有一个无参数的构造器。 

2. 类的构造器的访问权限需要足够

**思考：难道没有无参的构造器就不能创建对象了吗？**

只要在操作的时候明确的调用类中的构造器， 并将参数传递进去之后，就可以实例化操作，没有无参的构造器也可以创建对象。

**步骤如下：**

1. 通过Class类的getDeclaredConstructor(Class … parameterTypes)取得本类的指定形参类型 的构造器
2. 向构造器的形参中传递一个对象数组进去，里面包含了构造器中所需的各个参数。
3. 通过Constructor实例化对象

##### 调用指定的方法

通过反射，调用类中的方法，通过**Method类**完成。

1. 通过Class类的getMethod(String name,Class…parameterTypes)方法取得一个Method对 象，并设置此方法操作时所需要的参数类型。
2. 之后使用Object **invoke**(Object obj, Object[] args)进行调用，并向方法中传递要设置的obj对 象的参数信息。

![image-20240321152613218](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240321152613218.png) 

* invoke的**第一个参数，要填实例对象**，是调用这个对象的方法；若原方法**若为静态方法，则第一个参数填null**，第一个参数一定要有值，不管是实例对象或是null，否则会编译错误。
* 若原方法形参列表为空，则Object[] args可以省略，或者填null
* 若原方法声明为private,则需要在调用此invoke()方法前，显式调用方法对象的 setAccessible(true)方法，将可访问private的方法。

```java
		Class<?> userClass = Class.forName("com.cjy.reflection_.User");
        User user = (User)userClass.newInstance();
        System.out.println(user);

        //调用有形参的方法
        Method setName = userClass.getMethod("setName", String.class);
        setName.invoke(user,"陈俊宇");
        System.out.println(user);

        //调用没有形参的方法
        Method getName = userClass.getMethod("getName");
        System.out.println(getName.invoke(user));

        //调用静态方法
        Method sayHello = userClass.getMethod("sayHello");
        sayHello.invoke(null);
```

#### setAccessible

* Method和Field、Constructor对象都有setAccessible()方法。
* setAccessible作用是启动和禁用访问安全检查的开关。
* 参数值为true则指示反射的对象在使用时应该取消Java语言访问检查。
* 提高反射的效率。如果代码中必须用反射，而该句代码需要频繁的被调用，那么请设置为true
* 使得原本无法访问的私有成员也可以访问
* 参数值为false则指示反射的对象应该实施Java语言访问检查

**性能大比拼：**

```java
        Class<?> userClass = Class.forName("com.cjy.reflection_.User");

        User user = new User(1,"陈俊宇",22);


        //直接用user.getName的形式调用方法1亿次（2ms）
        long startTime = System.currentTimeMillis();
        for (int i = 0; i < 100000000; i++) {
            user.getName();
        }
        long endTime = System.currentTimeMillis();
        System.out.println(endTime - startTime+ "ms");

        //用类对象获取指定方法后，激活这个方法执行1亿次（104ms）
        Method getName = userClass.getMethod("getName");
        startTime = System.currentTimeMillis();
        for (int i = 0; i < 100000000; i++) {
            getName.invoke(user);
        }
        endTime = System.currentTimeMillis();
        System.out.println(endTime - startTime+ "ms");

        //用类对象获取指定方法后，在激活之前调用setAccessible禁用安全检查机关，然后激活这个方法执行1亿次（60ms）
        startTime = System.currentTimeMillis();
        getName.setAccessible(true);
        for (int i = 0; i < 100000000; i++) {
            getName.invoke(user);
        }
        endTime = System.currentTimeMillis();
        System.out.println(endTime - startTime+ "ms");
```

#### 反射读取注解

**什么是ORM？**
Object Relationship Mapping --> 对象关系映射

**使用反射读取注解信息三步:** 
1.定义注解 , 2.在类中使用注解 , 3. 使用反射获取注解 , 一般都是现成框架实现 , 我们手动实现

![image-20240321160228697](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240321160228697.png) 

**自定义注解：**

```java
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@interface Table {
    String tableName();//表名
}

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@interface Field {
    String column();//列名
    String type();//类型
    int length();//长度
}
```

**学生类：**

```java
@Table(tableName = "学生表")
class Student {
    @Field(column = "id",type = "int",length = 3)
    private int id;

    @Field(column = "姓名",type = "varchar",length = 10)
    private String name;

    @Field(column = "年龄",type = "int",length = 3)
    private int age;

    @Override
    public String toString() {
        return "Student{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```

**测试类：**

```java
Class<?> studentClass = Class.forName("com.cjy.reflectANDannotation.Student");

//获得这个类的注解（虽然只有Table这一个注解）
Annotation[] annotations = studentClass.getAnnotations();
for (Annotation annotation : annotations) {
    System.out.println(annotation);
}

//获得类的Table注解的tableName的值
Table annotation = studentClass.getAnnotation(Table.class);
System.out.println(annotation.tableName());

//获得类指定注解的值
java.lang.reflect.Field name = studentClass.getDeclaredField("id");
Field Annotation_ = name.getAnnotation(Field.class);
System.out.println(Annotation_.column());
System.out.println(Annotation_.type());
System.out.println(Annotation_.length());
```

### 21：函数式编程

#### 概述

**为什么学？**

- 能够看懂公司里的代码
- 大数量下处理集合效率高
- 代码可读性高
- 消灭嵌套地狱

```java
//查询未成年作家的评分在70以上的书籍 由于洋流影响所以作家和书籍可能出现重复，需要进行去重
List<Book> bookList = new ArrayList<>();
Set<Book> uniqueBookValues = new HashSet<>();
Set<Author> uniqueAuthorValues = new HashSet<>();
for (Author author : authors) {
    if (uniqueAuthorValues.add(author)) {
        if (author.getAge() < 18) {
            List<Book> books = author.getBooks();
            for (Book book : books) {
                if (book.getScore() > 70) {
                    if (uniqueBookValues.add(book)) {
                        bookList.add(book);
                    }
                }
            }
        }
    }
}
System.out.println(bookList);
```

```java
List<Book> collect = authors.stream()
    .distinct()
    .filter(author -> author.getAge() < 18)
    .map(author -> author.getBooks())
    .flatMap(Collection::stream)
    .filter(book -> book.getScore() > 70)
    .distinct()
    .collect(Collectors.toList());
System.out.println(collect);
```

**函数式编程思想：**

面向对象思想需要关注用什么对象完成什么事情。而函数式编程思想就类似于我们数学中的函数。它主要**关注的是对数据进行了什么操作**。

**优点：**

* 代码简洁，开发快速
* 接近自然语言，易于理解
* 易于"并发编程"

#### Lambda表达式

**概述：**

Lambda是JDK8中一个语法糖。他可以对某些匿名内部类的写法进行简化。它是函数式编程思想的一个重要体现。让我们不用关注是什么对象。而是更关注我们对数据进行了什么操作。

**核心原则：**

可推导可省略

**基本格式：**

(参数列表) -> {代码}

**省略规则：**

* 参数类型可以省略
* 方法体只有一句代码时大括号return和唯一一句代码的分号可以省略
* 方法只有一个参数时小括号可以省略
* 以上这些规则都记不住也可以省略不记，直接在匿名内部类上面**按ALT + Enter**即可

**心得体会：**

在你不熟悉一个函数接口的具体用法时，最好先用匿名内部类先推一边流程，根据重写方法的**方法名、返回值、形参**大概猜一下这个方法的作用是什么，**结合这个作用去写方法体**，然后直接用idea的快捷键快速生成Lambda表达式。

注意，这个能把匿名内部类简化为箭头函数的方式，只针对**只含单一方法的”接口“。**

**实例分析：**

1. 我们在创建线程并启动时可以使用匿名内部类的写法：

   ```java
   new Thread(new Runnable() {
               @Override
               public void run() {
                   System.out.println("执行");
               }
           }).start();
   ```

   可以使用Lambda的格式对其进行修改。修改后如下：

   ```java
   new Thread(() -> System.out.println("执行")).start();
   ```

2. 现有方法定义如下，其中IntBinaryOperator是一个接口。先使用匿名内部类的写法调用该方法。

   ```java
   public static int calculateNum(IntBinaryOperator operator){
           int a = 10;
           int b = 20;
           return operator.applyAsInt(a, b);
       }
   
   public static void main(String[] args) {
       int i = calculateNum(new IntBinaryOperator() {
           @Override
           public int applyAsInt(int left, int right) {
               return left + right;
           }
       });
       System.out.println(i);
   }
   ```

   Lambda写法：

   ```java
   int i = calculateNum((left, right) -> left + right);
   ```

3. 现有方法定义如下，其中IntPredicate是一个接口。先使用匿名内部类的写法调用该方法。

   ```java
   public static void printNum(IntPredicate predicate){
           int[] arr = {1,2,3,4,5,6,7,8,9,10};
           for (int i : arr) {
               if(predicate.test(i)){
                   System.out.println(i);
               }
           }
       }
       public static void main(String[] args) {
           printNum(new IntPredicate() {
               @Override
               public boolean test(int value) {
                   return value%2==0;
               }
           });
       }
   ```

   Lambda写法：

   ```java
   printNum(value -> value > 5);
   ```

4. 现有方法定义如下，其中Function是一个接口。先使用匿名内部类的写法调用该方法。

   ```java
   public static <R> R typeConver(Function<String,R> function){
           String str = "1235";
           R result = function.apply(str);
           return result;
       }
   public static void main(String[] args) {
       Integer result = typeConver(new Function<String, Integer>() {
           @Override
           public Integer apply(String s) {
               return Integer.valueOf(s);
           }
       });
       System.out.println(result);
   }
   ```

   Lambda写法：

   ```java
   Integer integer = typeConver(s -> Integer.valueOf(s));
   ```

#### Stream流

##### 基本介绍

Java8的Stream使用的是函数式编程模式，如同它的名字一样，它可以被用来对集合或数组进行链状流式的操作。可以更方便的让我们对集合或数组操作。

Stream是 Java 8新增加的类，用来补充集合类。

Stream代表数据流，流中的数据元素的数量可能是有限的，也可能是无限的。

Java Stream提供了提供了串行和并行两种类型的流，保持一致的接口，提供函数式编程方式，以管道方式提供中间操作和最终执行操作，为Java语言的集合提供了现代语言提供的类似的高阶函数操作，简化和提高了Java集合的功能。

##### 案例数据准备

~~~xml
    <dependencies>
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.16</version>
        </dependency>
    </dependencies>
~~~

~~~java
@Data
@NoArgsConstructor
@AllArgsConstructor
@EqualsAndHashCode//用于后期的去重使用
public class Author {
    //id
    private Long id;
    //姓名
    private String name;
    //年龄
    private Integer age;
    //简介
    private String intro;
    //作品
    private List<Book> books;
}
~~~

~~~java
@Data
@AllArgsConstructor
@NoArgsConstructor
@EqualsAndHashCode//用于后期的去重使用
public class Book {
    //id
    private Long id;
    //书名
    private String name;

    //分类
    private String category;

    //评分
    private Integer score;

    //简介
    private String intro;

}
~~~

~~~java
private static List<Author> getAuthors() {
        //数据初始化
        Author author = new Author(1L,"蒙多",33,"一个从菜刀中明悟哲理的祖安人",null);
        Author author2 = new Author(2L,"亚拉索",15,"狂风也追逐不上他的思考速度",null);
        Author author3 = new Author(3L,"易",14,"是这个世界在限制他的思维",null);
        Author author4 = new Author(3L,"易",14,"是这个世界在限制他的思维",null);

        //书籍列表
        List<Book> books1 = new ArrayList<>();
        List<Book> books2 = new ArrayList<>();
        List<Book> books3 = new ArrayList<>();

        books1.add(new Book(1L,"刀的两侧是光明与黑暗","哲学,爱情",88,"用一把刀划分了爱恨"));
        books1.add(new Book(2L,"一个人不能死在同一把刀下","个人成长,爱情",99,"讲述如何从失败中明悟真理"));

        books2.add(new Book(3L,"那风吹不到的地方","哲学",85,"带你用思维去领略世界的尽头"));
        books2.add(new Book(3L,"那风吹不到的地方","哲学",85,"带你用思维去领略世界的尽头"));
        books2.add(new Book(4L,"吹或不吹","爱情,个人传记",56,"一个哲学家的恋爱观注定很难把他所在的时代理解"));

        books3.add(new Book(5L,"你的剑就是我的剑","爱情",56,"无法想象一个武者能对他的伴侣这么的宽容"));
        books3.add(new Book(6L,"风与剑","个人传记",100,"两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢？"));
        books3.add(new Book(6L,"风与剑","个人传记",100,"两个哲学家灵魂和肉体的碰撞会激起怎么样的火花呢？"));

        author.setBooks(books1);
        author2.setBooks(books2);
        author3.setBooks(books3);
        author4.setBooks(books3);

        List<Author> authorList = new ArrayList<>(Arrays.asList(author,author2,author3,author4));
        return authorList;
    }
~~~

##### 创建流

单列集合： `集合对象.stream()`

~~~java
List<Author> authors = getAuthors();
Stream<Author> stream = authors.stream();
~~~

数组：`Arrays.stream(数组) `或者使用`Stream.of`来创建

~~~java
Integer[] arr = {1,2,3,4,5};
Stream<Integer> stream = Arrays.stream(arr);
Stream<Integer> stream2 = Stream.of(arr);
~~~

双列集合：转换成单列集合后再创建

~~~java、
Map<String,Integer> map = new HashMap<>();
map.put("蜡笔小新",19);
map.put("黑子",17);
map.put("日向翔阳",16);

Stream<Map.Entry<String, Integer>> stream = map.entrySet().stream();
~~~

##### 中间操作

###### filter

可以对流中的元素进行条件过滤，符合过滤条件的才能继续留在流中。

例如：

​	打印所有姓名长度大于1的作家的姓名

~~~java
List<Author> authors = getAuthors();
authors.stream()
        .filter(author -> author.getName().length() > 1)
        .forEach(author -> System.out.println(author.getName()));
~~~

###### map

可以把对流中的元素进行计算或转换。

例如：

​	打印所有作家的姓名

~~~java
List<Author> authors = getAuthors();
authors.stream()
        .map(author -> author.getName())
        .forEach(name -> System.out.println(name));
~~~

###### distinct

可以去除流中的重复元素。

例如：

​	打印所有作家的姓名，并且要求其中不能有重复元素。

~~~java
 List<Author> authors = getAuthors();
        authors.stream()
                .distinct()
                .map(author -> author.getName())
                .forEach(name -> System.out.println(name));
~~~

**注意：distinct方法是依赖Object的equals方法来判断是否是相同对象的。所以需要注意重写equals方法。**

###### sorted

可以对流中的元素进行排序。

例如：

​	对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素。

~~~java
//调用有参的sorted()方法
List<Author> authors = getAuthors();
authors.stream()
        .distinct()
        .map(author -> author.getAge())
        .sorted((o1, o2) -> o2 - o1)
        .forEach(age -> System.out.println(age));
~~~

**注意：如果调用空参的sorted()方法，需要流中的元素是实现了Comparable。**

###### limit

可以设置流的最大长度，超出的部分将被抛弃。

例如：

​	对流中的元素按照年龄进行降序排序，并且要求不能有重复的元素,然后打印其中年龄最大的两个作家的姓名。

~~~java
List<Author> authors = getAuthors();
authors.stream()
        .distinct()
        .sorted((o1, o2) -> o2.getAge() - o1.getAge())
        .limit(2)
        .forEach(author -> System.out.println(author.getName()));
~~~

###### peek

`peek`方法方法会使用一个Consumer消费流中的元素，但是返回的流还是包含原来的流中的元素。

~~~java
String[] arr = new String[]{"a","b","c","d"};
Arrays.stream(arr)
        .peek(System.out::println) //a,b,c,d
        .count();
~~~



###### skip

跳过流中的前n个元素，返回剩下的元素

例如：

​	打印除了年龄最大的作家外的其他作家，要求不能有重复元素，并且按照年龄降序排序。

~~~java
 List<Author> authors = getAuthors();
authors.stream()
        .distinct()
        .sorted((author1, author2) -> author2.getAge() - author1.getAge())
        .skip(1)
        .forEach(author -> System.out.println(author.getName()));
~~~

###### flatMap

map只能把一个对象转换成另一个对象来作为流中的元素。而flatMap可以把一个对象转换成多个对象作为流中的元素。

例一：

​	打印所有书籍的名字。要求对重复的元素进行去重。

~~~java
List<Author> authors = getAuthors();
authors.stream()
        .distinct()
        .flatMap( author -> author.getBooks().stream())
        .distinct()
        .forEach(book -> System.out.println(book.getName()));
~~~

例二：

​	打印现有数据的所有分类。要求对分类进行去重。不能出现这种格式：哲学,爱情

~~~java
authors.stream()
        .distinct()
        .flatMap(author -> author.getBooks().stream())
        .distinct()
        .flatMap(book -> Arrays.stream(book.getCategory().split(",")))
        .distinct()
        .forEach(name -> System.out.println(name));
~~~

##### 终结操作

###### forEach

对流中的元素进行遍历操作，我们通过传入的参数去指定对遍历到的元素进行什么具体操作。

###### count

可以用来获取当前流中元素的个数。

例子：

​	打印这些作家的所出书籍的数目，注意删除重复元素。

~~~java
List<Author> authors = getAuthors();
long count = authors.stream()
        .distinct()
        .flatMap(author -> author.getBooks().stream())
        .map(book -> book.getName())
        .distinct()
        .count();
System.out.println(count);
~~~

###### max&min

可以用来或者流中的最值。

例子：

​	分别获取这些作家的所出书籍的最高分和最低分并打印。

~~~java
List<Author> authors = getAuthors();
Optional<Book> max = authors.stream()
        .distinct()
        .flatMap(author -> author.getBooks().stream())
        .max(new Comparator<Book>() {
            @Override
            public int compare(Book o1, Book o2) {
                return o1.getScore() - o2.getScore();
            }
        });
System.out.println(max.get());

Optional<Book> min = authors.stream()
        .distinct()
        .flatMap(author -> author.getBooks().stream())
        .min((o1, o2) -> o1.getScore() - o2.getScore());
System.out.println(min.get());
~~~

###### collect

​	把当前流转换成一个集合。

例子：

​	获取一个存放所有作者名字的List集合。

~~~java
List<Author> authors = getAuthors();
List<Author> list = authors.stream()
        		.collect(Collectors.toList());
~~~

​	获取一个所有书名的Set集合。

~~~java
 Set<Author> set = authors.stream()
                .collect(Collectors.toSet());
~~~

​	获取一个Map集合，map的key为作者名，value为List<Book>

~~~java
Map<String, List<Book>> map = authors.stream()
                .distinct()
                .collect(Collectors.toMap(author -> author.getName(), author  -> author.getBooks()));
~~~

###### anyMatch

可以用来判断是否有任意符合匹配条件的元素，结果为boolean类型。

例子：

​	判断是否有年龄在29以上的作家

~~~java
List<Author> authors = getAuthors();
boolean b = authors.stream()
        .distinct()
        .anyMatch(author -> author.getAge() > 29);
System.out.println(b);
~~~

###### allMatch

​	可以用来判断是否都符合匹配条件，结果为boolean类型。如果都符合结果为true，否则结果为false。

例子：

​	判断是否所有的作家都是成年人

~~~java
List<Author> authors = getAuthors();
boolean b = authors.stream()
        .distinct()
        .allMatch(author -> author.getAge() >= 18);
System.out.println(b);
~~~

###### findAny

​	获取流中的任意一个元素。该方法没有办法保证获取的一定是流中的第一个元素。

例子：

​	获取任意一个年龄大于18的作家，如果存在就输出他的名字

~~~java
List<Author> authors = getAuthors();
Optional<Author> someOne = authors.stream()
        .distinct()
        .filter(author -> author.getAge() > 18)
        .findAny();
System.out.println(someOne);
~~~

###### findFirst

​	获取流中的第一个元素。

例子：

​	获取一个年龄最小的作家，并输出他的姓名。

~~~java
List<Author> authors = getAuthors();
Optional<Author> first = authors.stream()
        .distinct()
        .sorted((o1, o2) -> o1.getAge() - o2.getAge())
        .findFirst();
System.out.println(first);
~~~

###### reduce归并

对流中的数据按照你指定的计算方式计算出一个结果。（缩减操作）

reduce的作用是把stream中的元素给组合起来，我们可以传入一个初始值，它会按照我们的计算方式依次拿流中的元素和初始化值进行计算，计算结果再和后面的元素计算。

reduce两个参数的重载形式内部的计算方式如下：

~~~java
T result = identity;
for (T element : this stream)
	result = accumulator.apply(result, element)
return result;
~~~

其中identity就是我们可以通过方法参数传入的初始值，accumulator的apply具体进行什么计算也是我们通过方法参数来确定的。

例子：

​	使用reduce求所有作者年龄的和

~~~java
List<Author> authors = getAuthors();
Integer reduce = authors.stream()
        .distinct()
        .map(author -> author.getAge())
        .reduce(0, (integer, integer2) -> integer + integer2);
System.out.println(reduce);
~~~

##### 注意事项

* 惰性求值（如果没有终结操作，没有中间操作是不会得到执行的）
* 流是一次性的（一旦一个流对象经过一个终结操作后。这个流就不能再被使用,所以这时候你应该重新定义流）
* 不会影响原数据（我们在流中可以多数据做很多处理。但是正常情况下是不会影响原来集合中的元素的。这往往也是我们期望的）

##### 流和其它集合的区别

1. **不存储数据**。流是基于数据源的对象，它本身不存储数据元素，而是通过管道将数据源的元素传递给操作。
2. **函数式编程**。流的操作不会修改数据源，例如`filter`不会将数据源中的数据删除。
3. **惰性求值**。流的很多操作如filter,map等中间操作是延迟执行的，只有到终点操作才会将操作顺序执行。
4. **可以解绑**。对于无限数量的流，有些操作是可以在有限的时间完成的，比如`limit(n)` 或 `findFirst()`，这些操作可是实现"短路"(Short-circuiting)，访问到有限的元素后就可以返回。
5. **纯消费**。流的元素只能访问一次，类似Iterator，操作没有回头路，如果你想从头重新访问流的元素，对不起，你得重新生成一个新的流。

流的操作是以管道的方式串起来的。流管道包含一个数据源，接着包含零到N个中间操作，最后以一个终点操作结束。

#### Optional

##### 基本介绍

我们在编写代码的时候出现最多的就是空指针异常。所以在很多情况下我们需要做各种非空的判断。

例如：

~~~~java
        Author author = getAuthor();
        if(author!=null){
            System.out.println(author.getName());
        }
~~~~

尤其是对象中的属性还是一个对象的情况下。这种判断会更多。而过多的判断语句会让我们的代码显得臃肿不堪。所以在JDK8中引入了Optional,养成使用Optional的习惯后你可以写出更优雅的代码来避免空指针异常。

并且在很多函数式编程相关的API中也都用到了Optional，如果不会使用Optional也会对函数式编程的学习造成影响。

##### 1. 创建对象

Optional就好像是包装类，可以把我们的具体数据封装Optional对象内部。然后我们去使用Optional中封装好的方法操作封装进去的数据就可以非常优雅的避免空指针异常。

1. 我们一般使用**Optional**的**静态方法ofNullable**来把数据封装成一个Optional对象。无论传入的参数是否为null都不会出现问题。

```java
    Author author = getAuthor();
    Optional<Author> authorOptional = Optional.ofNullable(author);
```

你可能会觉得还要加一行代码来封装数据比较麻烦。但是如果**改造下getAuthor方法，让其的返回值就是封装好的Optional**的话，我们在使用时就会方便很多。

而且在实际开发中我们的数据很多是从数据库获取的。Mybatis从3.5版本可以也已经支持Optional了。我们可以直接把dao方法的返回值类型定义成Optional类型，MyBastis会自己把数据封装成Optional对象返回。封装的过程也不需要我们自己操作。

2. 如果你**确定一个对象不是空**的则可以使用**Optional**的**静态方法of**来把数据封装成Optional对象。

~~~~java
        Author author = new Author();
        Optional<Author> authorOptional = Optional.of(author);
~~~~

但是一定要注意，如果使用of的时候传入的参数必须不为null。（尝试下传入null会出现什么结果）

3. 如果一个方法的返回值类型是Optional类型。而如果我们经判断发现某次计算得到的返回值为null，这个时候就需要把null封装成Optional对象返回。这时则可以使用**Optional**的**静态方法empty**来进行封装。

~~~~java
		Optional.empty()
~~~~

通过查看ofNullable的源码我们可以得知：

~~~java
	return Value == null ? empty() : of(Value);
~~~

##### 2. 安全消费值

我们获取到一个Optional对象后肯定需要对其中的数据进行使用。这时候我们可以使用其**ifPresent**方法对来消费其中的值。这个方法会**判断其内封装的数据是否为空，不为空时才会执行具体的消费代码**。这样使用起来就更加安全了。

例如,以下写法就优雅的避免了空指针异常。

```java
    Optional<Author> authorOptional = Optional.ofNullable(getAuthor());
    authorOptional.ifPresent(author -> System.out.println(author.getName()));
```

##### 3. 获取值

如果我们想获取值自己进行处理**可以使用get方法获取，但是不推荐**。因为当Optional内部的数据为空的时候会出现异常。

##### 4. 安全获取值

如果我们期望安全的获取值。我们不推荐使用get方法，而是使用Optional提供的以下方法。

* **orElseGet**
  获取数据并且设置数据为空时的默认值。如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建对象作为默认值返回。

  ~~~java
   		Optional<Author> authorOptional = Optional.ofNullable(getAuthor());
          Author author1 = authorOptional.orElseGet(() -> new Author());
  ~~~

* **orElseThrow**
  获取数据，如果数据不为空就能获取到该数据。如果为空则根据你传入的参数来创建异常抛出。

  ~~~java
  		Optional<Author> authorOptional = Optional.ofNullable(getAuthor());
  		Author author = authorOptional.orElseThrow(() -> new RuntimeException("author为空"));
          System.out.println(author.getName());
  ~~~

##### 5. **过滤**

我们可以使用filter方法对数据进行过滤。如果原本是有数据的，但是不符合判断，也会变成一个无数据的Optional对象。

~~~java
Optional<Author> authorOptional = Optional.ofNullable(getAuthor());
authorOptional.filter(author -> author.getAge()>100)
    								.ifPresent(author -> System.out.println(author.getName()));
~~~

##### 6. 数据转换

Optional还提供了map可以让我们的对数据进行转换，并且转换得到的数据也还是被Optional包装好的，保证了我们的使用安全。

例如我们想获取作家的书籍集合。

~~~java
private static void testMap() {
    Optional<Author> authorOptional = getAuthorOptional();
    Optional<List<Book>> optionalBooks = authorOptional.map(author -> author.getBooks());
    optionalBooks.ifPresent(books -> System.out.println(books));
}
~~~

#### 函数式接口

**只有一个抽象方法**的接口我们称之为函数接口。

JDK的函数式接口都加上了**@FunctionalInterface** 注解进行标识。但是无论是否加上该注解只要接口中只有一个抽象方法，都是函数式接口。

#### 方法引用

我们在使用lambda时，如果方法体中只有一个方法的调用的话（包括构造方法）,我们可以用方法引用进一步简化代码。

**推荐用法：**

我们在使用lambda时不需要考虑什么时候用方法引用，用哪种方法引用，方法引用的格式是什么。我们只需要在写完lambda方法发现方法体只有一行代码，并且是方法的调用时使用快捷键尝试是否能够转换成方法引用即可。

当我们方法引用使用的多了慢慢的也可以直接写出方法引用。

**基本格式:**

类名或者对象名::方法名

#### 并行流

当流中有大量元素时，我们可以使用并行流去提高操作的效率。其实并行流就是把任务分配给多个线程去完全。如果我们自己去用代码实现的话其实会非常的复杂，并且要求你对并发编程有足够的理解和认识。而如果我们使用Stream的话，我们只需要修改一个方法的调用就可以使用并行流来帮我们实现，从而提高效率。

**parallel方法可以把串行流转换成并行流。**

~~~java
 private static void test28() {
    Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10);
    Integer sum = stream.parallel()
            .peek(new Consumer<Integer>() {
                @Override
                public void accept(Integer num) {
                    System.out.println(num+Thread.currentThread().getName());
                }
            })
            .filter(num -> num > 5)
            .reduce((result, ele) -> result + ele)
            .get();
    System.out.println(sum);
}
~~~

**也可以通过parallelStream直接获取并行流对象。**

~~~java
List<Author> authors = getAuthors();
authors.parallelStream()
        .map(author -> author.getAge())
        .map(age -> age + 10)
        .filter(age->age>18)
        .map(age->age+2)
        .forEach(System.out::println);
~~~

## Java并发编程

### JUC

JUC其实就是JDK中的三个包:

java.util.concurrent 并发相关的

java.util.concurrent.atomic 原子性

java.util.concurrent.locks lock锁

![image-20240326195120006](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240326195120006.png) 

### Java并发理论基础

#### 多线程并发不安全

如果**多个线程对同一个共享数据进行访问而不采取同步操作**的话，那么操作的结果是不一致的。例如：有500个线程同时对conut进行++的操作，最后的结果很count很可能小于500。

![image-20240330143447383](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240330143447383.png) 

**并发出现问题的根源：**

那么结果为什么不是500？并发出现问题的根源是什么？

##### **1. 可见性**

**线程本地内存（theadlocal）**引起的。

什么叫做具有可见性？ 是**指一个线程对共享变量的修改，另一个线程能够立即看得到**。
![image-20240330143917540](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240330143917540.png) 

假如执行线程1的是Cpu1，执行线程2的是Cpu2。
当线程1执行i = 5这句时，会先把i的初始值加载到线程的“本地内存”，然后赋值为5，那么此时线程1的“本地内存”中的i的值就被修改为5了。但是**还没有来得及把“本地内存”中的i传递给主内存中**。

此时，线程2执行了j = i，这里的i是从主内存中取的，主内存的i的值仍然为1没有改变，这就会会带来错误。也就是说，**线程1对共享变量i的修改对于线程2而言，不具有可见性**。

##### **2. 原子性**

**分时复用**引起的

原子性即一个操作或者多个操作要么全部执行并且执行的过程不会被打断，要么不执行。
![image-20240330144859012](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240330144859012.png) 

这里需要注意的是：**`i += 1`需要三条CPU指令**

1. 将变量i从内存读取到CPU寄存器
2. 在CPU寄存器中执行 i + 1 操作
3. 将最后的结果写入内存中

​	由于CPU的分时复用（线程切换）的存在，线程1在执行第一条指令后，就切换到线程2执行，那么很有可能最后写入内存中的值不是3而是2。

##### **3. 有序性**

**指令重排序引起的**

有序性即程序的执行顺序按照代码的先后顺序执行，

**但是在执行程序时为了提高性能。编译器和处理器常常会对指令做重排序**。重排序分为三种类型：

1. 编译器优化的重排序。编译器在不改变单线程语义的情况下，可以重新安排语句执行顺序
2. 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序
3. 内存系统的重排序。由于处理器使用缓存和（读/写）缓存区，这使得加载和存储操作看上去可能是乱序执行的

上述的1属于编译器重排序，2和3属于处理器重排序。**这些重排序都有可能会导致多线程程序出现内存可见性问题**。所以如果不采取手段，利用Java提供的可见性问题处理工具（如：volatile）加以控制，任由编译器处理器进行指令重排序，程序就会运行出错。

**那为什么不静止重排序呢？**重排序本身是用来提高性能的，全部禁止不行，所以JMM要进行取舍。

#### Java内存模型(JMM)

Java 线程之间的通信由Java内存模型(JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。

从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存(main memory)中，每个线程都有一个私有的本地内存（ThreadLocal），本地内存中存储了该线程以读/写共享变量的副本。

本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了高速缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。

##### Java内存模型示意图

![image-20240402091318054](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402091318054.png) 

从上图来看，线程A与线程B之间如要通信的话，必须要经历下面2个步骤︰

* 首先，线程A把本地内存A中更新过的共享变量刷新到主内存中去。
* 然后，线程B到主内存中去读取线程A之前已更新过的共享变量。

从整体来看，这两个步骤实质上是**线程A在向线程B发送消息**，而且这**个通信过程必须要经过主内存**。JMM通过控制主内存与每个线程的本地内存之间的交互,来为java程序员提供内存可见性保证。

##### 重排序

![image-20240402091651108](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402091651108.png) 

这些**重排序都可能会导致多线程程序出现内存可见性问题**。

对于编译器，**JMM的编译器重排序规则**会禁止特定类型的编译器重排序(不是所有的编译器重排序都要禁止)。

对于处理器重排序，**JMM的处理器重排序规则**会要求java编译器在生成指令序列时，插入特定类型的**内存屏障指令**，通过内存屏障指令来禁止特定类型的处理器重排序(不是所有的处理器重排序都要禁止)。

**内存屏障指令：**

内存屏障被用于多线程编程和并发控制中，确保对共享数据的操作按照预期顺序执行，并保证线程间的数据同步。内存屏障最主要的作用就是保证了内存操作的顺序性及可见性。在内存屏障之前的指令全部执行完成之后，才允许执行内存屏障之后的指令，从而保证代码的顺序性。

##### happen-before规则

基于上面对重排序的学习可以发现，重排序一方面是会提升程序性能，我们应该支持，另外—方面有的重排序会导致程序出问题，我们应该禁止。那到底哪些应该禁止，哪些应该支持呢?这个事情如果让Java程序员自己来分析，明显是很困难的。所以**这个工作就由JMM承担了**。

**JMM定义了一套规则，叫做happen-before规则**。这套规则—方面给程序员的承诺，一方面是对编译器和处理器的约束。JMM承诺程序员基于这套规则编程，即便不理解重排序，程序也不会因为发生了重排序出问题，也不会出现内存可见性问题。而另外一方面，Java平台在具体实现的时候，有了这套规则的也就知道了禁止重排序应该禁止到什么程度，比如有些重排序并不会打破这套规则，也并不会改变程序的执行结果，那就应该支持。

![image-20240402092253570](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402092253570.png) 

##### 八条规则

1. **单一线程顺序规则**：在一个线程内，在程序前面的操作happen-before于后面的操作。

2. **监视器锁规则**：对一个锁的解锁操作happen-before于后面对同一个锁的加锁操作。

3. **volatile变量规则**：对一个volatile变量的写操作happen-before于后面对这个变量的读操作。
4. **传递性规则**：如果A happen-beforeB，B happen-before C，则A happen-before C。
5. 线程start()规则：如果线程A执行操作ThreadB.start()，那么A线程的ThreadB.start())操作happen-before于线程B中的任意操作。
6. join规则：如果线程A执行操作ThreadB.join()并成功返回，那么B线程内的任意操作happen-before于线程A从ThreadB.join()操作成功返回。
7. 线程中断规则：对线程interrupt()方法的调用happen-before于被中断线程的代码检测到中断事件的发生，可以通过interrupted()方法检测到是否有中断发生。
8. 对象终结规则：一个对象的初始化完成(构造函数执行结束)happen-before于它的finalize()方法的开始。

#### synchronized

##### synchronized的使用

Java中每一个对象都可以作为锁，具体表现为以下3种形式。

1. **被synchronized和static一起修饰的方法**，锁的对象是**类的class对象（class）**，该方法被称为**静态同步方法**。
   所有的静态同步方法用的也是同一把锁----类对象本身

2. **仅仅被synchronized修饰的方法**，锁的对象是方法的调用者，即**实例对象（this）**，该方法被称为**（普通）同步方法**。

3. 对于**同步方法块**，锁是Synchronized括号里面指定的对象（指定的对象也可以用this,即指定当前实例对象)

4. **没有被synchronized修饰的方法**，它**没有锁的对象**，该方法被称为**普通方法**。

synchronized的使用可以和八锁问题结合起来，**解题步骤：**

1. **判断多个线程调用的方法是否属于同一把锁**，不是同一把锁的话，则计算有那些锁，那些没有锁；
2. 如果属于同一把锁，则线程的执行按照同步代码方式执行；
3. 如果不是同一把锁，甚至没有锁，则按照多线程的步骤执行。

##### 加锁和释放锁原理

**synchronized加锁和释放锁的原理**本质是对一个对象的监视器(monitor)进行获取，而这个获取过程是排他的，也就是同一时刻只能有一个线程获取到由synchronized所保护对象的监视器。下面通过一个图来展示线程，对象Object，监视器Monitor,同步队列SychronizedQueue之间的关系。

![image-20240402135406667](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402135406667.png) 

图中可以看到，任意线程对Object(Object由synchronized保护)的访问，**首先要获得Object的监视器Monitor**。**如果获取失败，线程进入同步队列，线程状态变为BLOCKED**。当访问Object 的前驱(获得了锁的线程)释放了锁，则该释放操作唤醒阻塞在同步队列中的线程，使其重新尝试对监视器的获取。

##### 可重入的实现原理

**synchronized对于一个对象加锁后是可以重入的**，就是说同一个线程可以反复给该对象加锁，且并不会因为前一次加的锁还没有释放而阻塞。
**原理：**Synchronized加锁的对象拥有一个**monitor计数器**，当线程获取该对象锁后，monitor计数器就会加一，释放锁后就会将monitor计数器减一。所以**同一个线程反复对该对象加锁时，只会引起monitor计数器加1，并不会触发Monitor.Enter失败的流程**，即线程不会被阻塞。释放锁也是一样，每触发一次释放操作锁monitor计数器会减1，当最终monitor计数器**重新减为0之后，才真正表示释放了锁**。

##### 保证可见性的原理

**锁的happens-before关系：**

Synchronized的happens-before规则，即监视器锁规则：**对同一个监视器的解锁，happens-before于对该监视器的加锁**。

继续来看代码:

![image-20240402140149506](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402140149506.png) 

happens-before关系如图：

![image-20240402140227825](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402140227825.png) 

在图中每一个箭头连接的两个节点就代表之间的happens-before关系，

**黑色的是通过程序顺序规则推导出来**，

**红色的为监视器锁规则推导而出：**线程A释放锁happens-before线程B加锁，

**蓝色的则是通过程序顺序规则和监视器锁规则推测出来happens-befor关系**，通过**传递性规则**进一步推导的happens-before关系。现在我们来重点关注**2 happens-before 5**，通过这个关系我们可以得出什么?

根据happens-before的定义中的一条：==**如果A happens-before B，则A的执行结果对B可见**，**并且A的执行顺序先于B**==。线程A先对共享变量A进行加一，由**2 happens-before 5关系可知线程A的执行结果对线程B可见即线程B所读取到的a的值为1**。

##### 锁的内存语义

1. 当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。
2. 当线程获取锁时，JMM会把该线程对应的本地内存置为无效。

##### 锁升级与对比

###### java对象头

Synchronized用的**锁是存在Java对象头**里面的，所以理解对象头的存储结构和存储数据的类型可以有助于对锁的理解。

Java对象头中**主要存储三类数据**：

1. 第一类叫做**Mark Word**，主要**存储对象的hashcode**、**分代年龄**、**锁信息**等运行数据;
2. 第二类是**Class Pointer**，指向方法区中该class 的对象，JVM通过此字段来判断当前对象是哪个类的实例;
3. 第三类，**数组的长度，就是如果当前对象是数组的话才会有**。

三类中，我们这里重点关注第一类Mark Word，是我们理解锁的核心.

![image-20240402141113536](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402141113536.png) 

**程序运行期间，Mark Word存储的信息会随着锁标志位的变化而变化**，**可能会变化为以下四种状态之一：**

![image-20240402141221595](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402141221595.png) 

看到这里，你会发现**无锁、偏向锁的“锁标志位”是一样的**，即**都是01**，这是**因为无锁、偏向锁是靠字段"是否是偏向锁”来区分的**，0代表没有启用偏向锁，1代表启用偏向锁，可以通过VM参数(XX:UseBiasedLocking=true 默认)控制。并且启动偏向锁还有延迟(默认4秒)，可以通过VM参数(XX:BiasedLockingStartupDelay=0 ）关闭延迟。

###### 锁升级与对比

基于上面对Java对象头的理解，可以看出锁一共有4种状态，分别是:**无锁，偏向锁，轻量级锁，重量级锁**(Java SE 1.6开始，**为了降低锁的获取与释放带来的性能消耗，才引入的"偏向锁"和“轻量级锁"**)。这几个锁状态会随着并发竞争情况逐渐升级，==**锁只能升级不能降级**==，也就是说轻量级锁不能变回偏向锁，重量级锁不能变回轻量级锁。下面详细介绍下这几个锁，以及锁的升级过程。

###### 偏向锁

在大多实际环境下，锁不仅不存在多线程竞争，而且总是由同一个线程多次获取，那么在同一个线程反复获取所释放锁中，其中并没有锁的竞争，那么这样看上去，多次的获取锁和释放锁带来了很多不必要的性能开销和上下文切换。所以引入了偏向锁来处理这种情况。

**偏向锁的加锁：**

1. 当一个线程A访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，

2. 以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程A的偏向锁。

3. 如果测试成功，表示线程已经获得了锁。

4. 如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1(表示当前是偏向锁)

5. 如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。

6. 如果没有设置，则使用CAS竞争锁(即轻量级锁)

   <img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402142105880.png" alt="image-20240402142105880" style="zoom: 80%;" /> 

   例子：当大呆需要上WC时，只有它自已要上WC，此时并**没有其它的人需要上WC，那么这时这个WC可以直接给大呆使用，并且大呆把可以标识自已身份的ID贴到门上**，表示此时大呆占用了这个WC。

**偏向锁的撤销：**

还是用上面这个图来解释，此时当前的WC被大呆所占用，这时二呆来了也要使用WC。这时**大呆和二呆就要通过CAS的方式来抢占WC**。因为此时锁的状态是偏向锁的状态，二呆来了也要使用WC(这时有**两个人同时要使用WC，这时就要将偏向锁升级成轻量级锁**)，**在升级轻量锁之前首先需要将WC上的标识大呆身份的ID撕下来**(**这一步叫做偏向锁的撤销**)。

![image-20240402142300696](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402142300696.png) 

###### 轻量级锁

上面锁被撤销后，升级为了轻量级锁，**轻量级锁状态下两个人需要通过过自旋+CAS的方式两个人来抢锁**。**当其中一个线程抢锁成功后，会将LR贴到WC的门上，表示WC当前被某个线程占用，然后另一个没有抢到锁的线程就一直自旋获取锁**。

![image-20240402142517212](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402142517212.png) 

LR的锁记录中存储的是对象的**Mark Word的备份**，即拷贝进入的,而两个线程竞争的过程就是**通过CAS的方式将对象本来的Mark Word位置存储的信息替换为指向自己LR记录的指针**。**谁替换成功了，谁就获得了锁**，例如A成功了。那没有获取到锁的线程B，就再自旋一段时间(**自旋的原因是因为B认为A很快就能执行完**，我就在门口等一下，也就是**B认为竞争没有那么激烈**)。**当自旋一段时间后，如果还没有获得锁，那B就只能将锁修改为重量级锁了，然后自己进入阻塞状态**，等待A执行完之后唤醒。

![image-20240402142725246](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402142725246.png) 

###### 重量级锁

重量级锁，线程加锁失败会进入阻塞状态，等待前驱获得线程的锁执行完之后唤醒。

![image-20240402142835027](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402142835027.png) 

#### volatile

**volatile变量的作用：如果一个字段被声明成volatile，JMM确保所有线程看到这个变量的值是一样的。**

##### volatile可见性的实现

1．当写一个volatile变量的时候，JMM会把该线程对应本地内存中的共享变量值刷新到主内存。
2．当读一个volatile变量时:JMM会把该线程对应的本地内存置为无效，线程接下来将从主内存中读取共享变量

##### volatile有序性的实现

###### happen-before

**对一个volatile 域的写，happens-before于任意后续对这个 volatile 域的读**

![image-20240402145108374](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402145108374.png) 

根据happens-before规则，上面过程会建立3类happens-before关系。

1. 根据程序次序规则：1 happens-before 2且 3 happens-before 4。
2. 根据volatile 规则: 2 happens-before 3。
3. 根据 happens-before 的传递性规则：1 happens-before 4。

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402145239783.png" alt="image-20240402145239783" style="zoom:80%;" /> 

因为以上规则，当线程A将 volatile变量flag更改为true后，对于线程B来说是可见的。

###### volatile禁止重排序

为了性能优化，JMM在不改变正确语义的前提下，会允许编译器和处理器对指令序列进行重排序。针对会改变语义的场景，Java编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序，J**MM针对编译器制定的 volatile重排序规则表**如下(NO就是需要禁止重排序的场景)

![image-20240402145732092](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402145732092.png) 

#### final

##### 重排序禁止规则

按照final修饰的数据类型分类：

基本数据类型:

* final域写：禁止final域写与构造方法重排序，即禁止final域写重排序到构造方法之外，从而保证该对象对所有线程可见时，该对象的final域全部已经初始化过。
* final域读：**先确保初次读对象的引用**，**然后读对象的final 域**，这样**在读对象的final 域的时候可以保证final 域已经被初始化过了**。

引用数据类型:

* 额外增加约束：修饰了一个成员对象，那么就会**先将该成员对象构造完成**(即其成员变量全部被初始化了)，**再将该成员对象的引用赋值给引用变量**。**保证这两步不会被重排序**，否则，其他线程可以通过这个引用来访问尚未被初始化的成员变量。

#### 线程状态

![image-20240402151400052](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402151400052.png) 

1. **NEW**：初始状态，线程被创建，但是还没有调用start()方法。
2. **RUNNABLE**：运行状态，Java线程将操作系统中的就绪和运行两种状态笼统地称作"运行中”
3. **BLOCKED**：阻塞状态，表示线程阻塞于锁。
4. **WAITING**：等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些等待动作(通知或中断)
5. **TIME_WAITING**超时等待状态，该状态不同于WAITING状态，它可以在指定的时间自行返回。

6. **TERMINATED**：终止状态，表示当前线程已经执行完毕。

``阻塞状态BLOCKED是线程阻塞在进入synchronized关键字修饰的方法或代码块时(获取锁)的状态，``

``但是如果是阻塞在java.concurrent包中的Lock接口的线程状态却是等待状态WAITING，因为Lock接口的阻塞实现均使用的是LockSupport类中的相关方法;``

#### 线程中断和终止

中断可以理解为线程的一个**标识位属性**，它表示一个运行中的线程是否被其他线程进行了中断操作。**其他线程通过调用该线程的interrupt方法进行中断操作**。反过来，**线程通过isInterrupt()方法来判断自己是否被执行的中断操作**，并做出响应。

##### 中断异常

如果sleep、wait 等可以让线程进入阻塞的方法使线程休眠了，而**处于休眠中的线程被中断**，那么线程是可以感受到中断信号的，并且会抛出一个InterruptedException异常。

**在抛出InterruptException之前，Java虚拟机会将该线程的中断标记位清除**。然后抛出InterruptException，此时调用isInterrunpted ()方法将会返回false。

##### 线程不应强制停止

为什么线程不应强制停止？

上面介绍了中断，那基于中断的停止模式是，A线程如果想要停止B线程，则A线程需要给B线程发送一个中断信号，B线程通过中断标志位判断自己是否有被中断，**最后自行决定如何响应中断**（例如:可以停止，可以延后，也可以直接忽略)。**为什么要让线程拥有响应中断的主权，而不可以强制停止呢?**(A强制停止B)

可以设想一下，我们很多工作并不是可以贸然停止的，例如A想要停止B时，B线程正在写入一个文件，可能文件正写入一半，如果立即停止那数据就是不完整的。但是对于A来说，它是感知不到B进行到什么阶段的，所以也没办法选择一个最佳时机来停止B，**要想安全稳妥的停止B线程，确实只能B线程自行决策**。

再看几种停止线程的错误方法。比如stop()， suspend()和resume()，这些方法已经被Java直接标记为@Deprecated。如果再调用这些方法，IDE会友好地提示，我们不应该再使用它们了。是**因为stop()会直接把线程停止，这样就没有给线程足够的时间来处理想要在停止前保存数据的逻辑，任务戛然而止**，会导致出现数据完整性等问题。

#### 线程之间的通信

现实的多线程模式下，每一个线程并不是独立的执行就完事了，更常见的是线程之间需要相互协作才能更好的完成—项任务。协作的过程中，就免不了线程之间需要相互通信。Java提供的一些可以完成线程间通信的机制。

1. **Volatile**：当两个线程A，B共同使用一个普通共享变量的时候，线程A对变量进行了修改，另外一个线程B是不能保证一定能看到最新值的。这就导致了线程之间的可见性问题，并发程序基于此运行是会出错的。为了解决这个问题，**Java提供了Volatile关键字，被该关键字修饰的变量不会存在B线程读不到最新值的情况**。
2. **Synchronized**：这是Java提供的另外一个关键字，它可以修饰方法或者同步块，**被修饰之后能够确保同一时间只有一个线程可以处于方法或者同步块中**，所以在方法和同步块中去访问共享变量，可以保证可见性和排他性。
3. **wait/ notify**： Java还提供了"等待/通知""的机制来进行线程间的协作运行。
    **通知等待机制：**
    java在的等待和通知方法(如下**5种**)被**定义在了Object类**上。一个线程B调用了对象O的wait()方法进入等待状态WAITING或者TIMED_WAITING,而另外一个线程A调用了对象O的的notify或者notifyAll方法，线程B从wait方法返回，然后执行后续操作。

  * notify：通知一个在对象上等待的线程。

  * notifyAll：通知所有等待在该对象上的线程。

  * wait()：线程调用该方法进入等待(WAITING）状态，返回需要等待另外的线程通知或者被中断，另外注意线程调用wait方法后会释放对象的锁（**能调用wait方法的前提也是获取到了对象的锁**)

  * wait(long)：线程调用之后会进入超时等待(TIMED_WAITING)状态，多一种返回方式，就是如果没有通知，也会在等待n毫秒后返回。

  * wait(long,int):超时时间更细，到纳秒

4. **Thread.join()**：AB两线程，A调用B.join()，表示A需要等待B完全执行完成，才会从B.join()处返回继续执行。当然也支持join(long)和
   join(long,int)两种超时返回。调用join后，A线程会处于等待(WAITING)或，超时等待(TIMED WAITING)状态

#### ThreadLocal

ThreadLocal叫本地变量（线程变量），其是**以ThreadLocal对象为Key**，**任意对象为value的存储结构**(其底层是在线程里维护了一个map, map的key就是各种ThreadLocal对象），**当一个Key-Value值被存储之后，会一直附带在线程上**，所以你可以在线程执行的任何位置再通过这个ThreadLocal对象取到存入的一个值。另外**设定或修改值的方式是SET(T),获取值的方式是get();**

![image-20240402160558335](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402160558335.png) 

**帮助理解:**

* 一开始创建了一个ThreadLocal对象，叫做TIME_THREADLOCAL_OBECT(特别注意这里只是创建了一个对象)，这个对象会作为一个key,去存储—个Long型的value值，到线程的ThreadLocalMap中。
* begin方法:需要理解为啥set方法只需要传value值，无需传key。是因为TIME_THREADLOCAL_OBECT对象会作为key
* end方法:同理，需要理解get方法为啥不用传参数，同样因为TIME_THREADLOCAL_OBECT会作为key
* another_threadlocal_object:如果需要存储另外一个值，可以再生成一个threadlocal对象，例如代码注释里的another_threadlocal_object。

对象作为key的话，是这个map只能保存—对值，因为只有—个对象，那就是只有一个 key。这一个threadlocal 对象只能保存一个值。按照上面的例子，这个值是一个Long。但是要注意：**一个线程里面是可以定义很多threadlocal 对象的**。

### Java中的锁

#### Lock接口

锁主要是能用来控制多个线程访问共享变量的方式，在Lock接口出现之前，Java主要是靠我们前面介绍的synchronized关键字来实现锁功能的，在JavaSE5之后，开始提供Lock接口来实现锁的功能。他有与synchronized关键字类似的同步功能，只是说有一些差别，**Lock需要显示的进行加锁和解锁操作**。虽然损失了一些隐式加解锁的便捷性，但是增强了可操作性。另外Lock还提供了—些特有的可中断获取锁。超时获取锁等同步特性。

![image-20240402162402874](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402162402874.png) 

* 解锁过程放入finally块，确保锁能够被释放
* **加锁过程不要写在try里面，因为加锁过程如果发生异常，也会进入finally块导致锁无故释放**

**Lock VS synchronized：**

![image-20240327113239201](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240327113239201.png) 

**相同点：**

* synchronized 和Lock都是用来保护资源线程安全的。
* 都可以保证可见性。
* synchronized 和 ReentrantLock都拥有可重入的特点

**不同点：**

* 加解锁控制差别:：**synchronized的加锁和解锁是由Jvm实现的(内置锁)**，而Lock的加解锁需要手动控制，通过lock()和unlock()，一般会把unlock操作放入finally块来解锁，以防忘记解锁。
* synchronized 锁不够灵活：**synchronized一个线程获取锁之后，其他线程想要获取锁只能等待**，只能进入阻塞状态，直到持有锁的线程释放这个锁，可能这个等待过程会持续很久。相比之下，Lock可以使用lockInterruptibly方法，不想等了可以中断退出，也可以使用tryLock获取锁，能获取就获取，不能获取线程也可以去干别的事情，更加灵活。
* **synchronized锁只能同时被一个线程拥有**，但是Lock 锁没有这个限制：例如读写锁中的读锁时可以被多个线程同时拥有的。
* 是否可以设置公平/非公平：公平锁是指多个线程在等待同一个锁时，根据先来后到的原则依次获得锁。ReentrantLock 等Lock 实现类可以根据自己的需要来设置公平或非公平，**synchronized则不能设置**。

#### AQS队列同步器

队列同步器**AbstractQueuedSynchronizer**(以下简称同步器)，**是用来构建锁或者其他同步组件的基础框架**，它使用了**一个int成员变量表示同步状态（五种：1，-1，-2，-3, 0）**，通过**内置的FIFO队列来完成资源获取线程的排队工作**，是实现大部分同步需求的基础。

**同步器的主要使用方式是继承**，子类通过继承同步器并实现它的可重写方法来管理同步状态，在可重写方法的实现过程中免不了要对同步状态进行更改

这时就需要使用同步器提供的3个方法(**getState()**、**setState(int newState)**、**compareAndSetstate(int expect,int update)**)来进行操作，因为它们能够保证状态的改变是安全的。

**子类推荐被定义为自定义同步组件的静态内部类**，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件(锁，CountDownLatch等)使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件(可重入锁ReentrantLock、可重入读写锁ReentrantReadWriteLock和CountDownLatch等)。

##### AQS的实现

**AQS的实现采用的是模版模式**，对外提供的三类方法用于实现一个同步组件;

**三类方法关系**：

1. 使用者继承AQS并重写**5个指定的方法**(第二类)。
2. 重写同步器指定的方法时，需要使用**同步器提供的3个方法**来访问或修改同步状态(第一类)。
3. 最后将AQS组合在自定义同步组件的实现中，并调用其**9个模板方法**(第三类)和5个重写过的方法来实现，另外模板方法会调用使用者重写的方法。

**第—类：3个访问和修改同步状态的方法**
重写同步器指定的方法第二类时，需要使用同步器提供的如下3个方法来访问或修改同步状态。

* getState():获取当前同步状态。
* setState( int newState):设置当前同步状态。
* compareAndSetState(int expect, int update):使用CAS设置当前状态，该方法能够保证状态设置的原子性

**第二类:5个可重写方法**

* isHeldExclusively():该线程是否正在独占资源。只有用到condition才需要去实现它。
* tryAcquire(int):独占方式。尝试获取资源，成功则返回true，失败则返回false。
* tryRelease(int):独占方式。尝试释放资源，成功则返回true，失败则返回false
* tryAcquireShared :共享方式。尝试获取资源。负数表示失败;0表示成功，但没有剩余可用资源;正数表示成功，且有剩余资源
* tryReleaseShared(int):共享方式。尝试释放资源，成功则返回true，失败则返回false。

**第三类:9个模版方法**

模版方法主要分成：独占式获取与释放同步状态，共享式获取与释放同步状态和查询同步队列中的等待线程

![image-20240402171147225](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402171147225.png) 

##### 实现原理分析

尝试从多个角度分析AQS的实现，主要包括**同步队列**，**独占式获取释放同步状态**，**共享式获取同步状态**，**独占超时获取同步状态**等同步器核心数据结构和模版方法

##### 同步队列

1. **队列节点**:节点Node是构成同步队列的基础，获取同步状态失败的线程将会被包装成—个节点加入同步队列的尾部

![image-20240402172133951](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402172133951.png)  

2. **队列基本结构**:同步器包含两个节点的引用(头，尾节点)
   ![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402172423357.png)

3. **新加入节点的过程**:当有新节点需要加入的时候，需要保证线程安全，同步器提供了一个基于CAS的设置尾节点的方法:compareAndSet**Tail**(Nodeexpect,Node update)，**它需要传递当前线程"认为"的尾节点和当前节点**，只有设置成功后，当前节点才正式与之前的尾节点建立关联。
   ![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402172547242.png)

4. **首节点释放过程**:同步队列遵循FIFO，首节点是获取同步状态成功的节点，**首节点的线程在释放同步状态时，将会唤醒后继节点**，**而后继节点将会在获取同步状态成功时将自己设置为首节点**
   ![image-20240402172708638](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402172708638.png)

##### 独占式同步获取释放

在获取同步状态时，**同步器维护了一个同步队列**，**获取状态失败的线程都会被加入到队列中并在队列中自旋**;**在释放同步状态时，同步器调用tryRelease方法释放同步状态**，然后唤醒后继节点。移出队列的条件是后继节点获取了同步状态，并把自己设置为了新的头节点，此时前驱节点会被移出队列。

![image-20240402172945875](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402172945875.png) 

##### 共享式同步获取释放

1. **共享式VS独占式**:共享式获取与独占式获取的差别在于同一时刻是否能让多个线程获取到同步状态。左边共享式访问时，其他共享式的访问都会被允许，而独占式访问被阻塞。右边是独占式访问资源时，同一时刻其他访问均被阻塞。
   ![image-20240402173138897](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402173138897.png)

2. **共享式同步获取实现**:在acquireShared(int arg)方法中，同步器调用tryAcquireShared( int arg)方法尝试获取同步状态，**tryAcquireShared(intarg)方法返回值为int类型，当返回值大于等于0时，表示能够获取到同步状态**。因此，**在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件就是tryAcquireShared(int arg)方法返回值大于等于0**

3. **共享式同步状态释放**:通过调用releaseShared( int arg)方法可以释放同步状态。

##### 独占式超时获取释放

* **使用理解**:通过调用同步器的**doAcquireNanos(int arg,long nanosTimeout)**方法可以超时获取同步状态，即在指定的时间段内获取同步状态，**如果获取到同步状态则返回true，否则，返回false**。该方法提供了传统Java同步操作(比如synchronized关键字)所不具备的特性。
* **支持中断**:超时获取同步状态过程可以**被视作响应中断获取同步状态过程的"增强版”**, doAcquireNanos(int arg,long nanosTimeout)方法在支持响应中断的基础上，增加了超时获取的特性
* **设置时间过短**:**如果nanosTimeout小于等于spinForTimeoutThreshold(1000纳秒)时，将不会使该线程进行超时等待，而是进入快速的自旋过程**。原因在于，非常短的超时等待无法做到十分精确，如果这时再进行超时等待，相反会让nanosTimeout的超时从整体上表现得反而不精确
  ![image-20240402173615596](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402173615596.png)

#### 重入锁ReentrantLock

**什么是重入?**重进入是指任意线程在获取到锁之后能够再次获取该锁而不会被锁所阻塞

**重入实现需要解决两个问题:**

1. **线程再次获取锁**:锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。
2. **锁的最终释放**:线程重复n次获取了锁，随后在第n次释放该锁后，其他线程能够获取到该锁。锁的最终释放要求**锁对于获取进行计数自增**，计数表示当前锁被重复获取的次数，而**锁被释放时，计数自减**，当**计数等于0时表示锁已经成功释放**。

ReentrantLock总共有三个内部类，并且三个内部类是紧密相关的，下面先看三个类的关系。

![image-20240402185004827](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402185004827.png) 

ReentrantLock类内部总共存在Sync、NonfairSync、FairSync三个类,NonfairSync与FairSync类继承自Sync类，Sync类继承自AQS抽象类![image-20240402185153080](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402185153080.png)

#### 读写锁ReentrantReadWriteLock

读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。

Java并发包中提供的读写锁是ReentrantReadWriteLock，具有如下特性

* 公平性选择:支持公平和非公平(默认）的锁获取方式
* 支持重入:同一线程获取读锁之后能再次获取;同一线程获取写锁之后能再次获取写锁，并且还能获取读锁。
* 锁降级:按照获取写锁，再获取读锁，再释放写锁的顺序，写锁能够降级为读锁

##### 读写锁的接口

ReentrantReadWriteLock 是**接口ReadWriteLock**的具体实现，ReadWriteLock中仅定义了两个方法:

* readLock():获取读锁
* writeLock():获取写锁

ReentrantReadWriteLock首先实现了接口中的两个方法，其次还提供了查看其内部状态的方法，方法及描述如下:

![image-20240402185728551](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402185728551.png) 

##### 读写锁的实现分析

###### 读写状态设计

读写锁依然是组合了一个自定义的同步器(AQS)来实现同步功能，而读写状态就是其同步器的状态，再次查看同步器的详解可知，同步状态state是一个int类型的整数。前面ReentrantLock实现重入性是在state上面进行累加，例如同一线程重复获取N次，那state的值为N。现在对于读写锁来说同样只能在这个int类型的同步状态上维护多个读线程和一个写线程的状态，所以此时**累加已经不行了**，**只能将一个32位的int变量进行切割，其中高16位维护读状态，低16位维护写状态**。

![image-20240402185938457](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402185938457.png) 

**解析:当前状态表示一个线程已经获取了写锁，并且重入了两次，所以写状态为3，并且获取了两次读锁，所以读状态为2;**

###### 写锁的获取与释放

**获取:**写锁是一个支持重进入的排它锁。如果当前线程已经获取了写锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取(读状态不为0)或者该线程不是已经获取写锁的线程，则当前线程进入等待状态。

**释放**:写锁释放与ReentrantLock的锁释放类似，因为支持可重入，所以这里每释放一次则写状态减1，当写状态减为0时，才真正释放写锁，别的线程才可以获取。

###### 读锁的获取与释放

读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问(或者写状态为0)时，读锁总会被成功地获取，而所做的也只是(线程安全的)增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。

读锁是一个支持重进入的共享锁，并且支持多个线程同时获取。所以在能够获取读锁的状态下，不管是同一线程再次获取读锁，还是其他线程获取读锁，都只是在读状态增加。

但是，获取读锁的实现从Java 5到Java 6变得复杂许多，主要原因是新增了一些功能，例如**getReadHoldCount()方法，作用是返回当前线程获取读锁的次数**。读状态是记录所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在ThreadLocal中，由线程自身维护。

###### 锁降级

**锁降级(支持)**︰指的是写锁降级成为读锁。如果当前线程拥有写锁，然后将其释放，最后再获取读锁，这种分段完成的过程不能称之为锁降级。锁降级是**指把持住(当前拥有的)写锁，再获取到读锁，随后释放(先前拥有的)写锁的过程**。

锁升级(不支持)︰指读锁升级为写锁。流程遵循先获取读锁，再获取写锁，再释放读锁。

##### 读写锁应用

![image-20240328093254907](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240328093254907.png) 

所谓的读写锁（Readers-Writer Lock），顾名思义就是**将一个锁拆分为读锁和写锁两个锁**。其中**读锁允许多个线程同时获得**，因为读操作本身是线程安全的。而**写锁则是互斥锁，不允许多个线程同时获得写锁**，**并且写操作和读操作也是互斥的**。

独占锁（写锁）：指该锁一次只能被一个线程锁持有。对于ReentranrLock和 Synchronized 而言都是独占锁。

共享锁（读锁）：该锁可被多个线程所持有。

对于ReentrantReadWriteLock其读锁时共享锁，写锁是独占锁，读锁的共享锁可保证并发读是非常高效的。

**main方法：**

~~~java
public class Test01 {
    public static void main(String[] args) {
         LockMyCache myCache = new LockMyCache();
        //10个写线程
        for (int i = 0; i < 10; i++) {
            final int temp = i;
            new Thread(() -> {
                myCache.put(temp + "", temp + "");
            }, "线程" + String.valueOf(i)).start();
        }
        //10个读线程
        for (int i = 0; i < 10; i++) {
            final int temp = i;
            new Thread(() -> {
                myCache.get(temp + "");
            }, "线程" + String.valueOf(i)).start();
        }
    }
}
~~~

**没有读写锁的资源类：**

~~~java
//没有读写锁的资源类，写入的时候，还没写入完成，会存在其他的写入！造成问题
class MyCache {
    private Map<String, String> map = new HashMap<>();

    //写操作
    public void put(String key, String value) {
        System.out.println(Thread.currentThread().getName() + " 执行写操作");
        map.put(key, value);
        System.out.println(Thread.currentThread().getName() + " 写操作完毕");
    }

    //读操作
    public void get(String key) {
        System.out.println(Thread.currentThread().getName() + " 执行读操作");
        map.get(key);
        System.out.println(Thread.currentThread().getName() + " 读操作完毕");
    }
}
~~~

**有读写锁的资源类：**

~~~java
class LockMyCache {
    private volatile Map<String,String> map = new HashMap<>();
    //定义读写锁
    ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    //写操作，上写锁
    public void put(String key, String value) {
        readWriteLock.writeLock().lock();//上写锁
        try {
            System.out.println(Thread.currentThread().getName() + " 执行写操作");
            map.put(key, value);
            System.out.println(Thread.currentThread().getName() + " 写操作完毕");
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            readWriteLock.writeLock().unlock();//解写锁
        }
    }

    //读操作，上读锁
    public void get(String key) {
        readWriteLock.readLock().lock();//上读锁
        try {
            System.out.println(Thread.currentThread().getName() + " 执行读操作");
            map.get(key);
            System.out.println(Thread.currentThread().getName() + " 读操作完毕");
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            readWriteLock.readLock().unlock();//解读锁
        }
    }

}
~~~

![image-20240328100551431](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240328100551431.png) ![image-20240328100628642](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240328100628642.png)  

#### LockSupport工具

LockSupport定义了一组的公共静态方法，这些方法**提供了最基本的线程阻塞和唤醒功能**，而LockSupport也成为构建同步组件的基础工具

LockSupport定义了**一组以park开头的方法用来阻塞当前线程**，以及**unpark(Thread thread)方法来唤醒**一个被阻塞的线程。这些方法及描述如下:

![image-20240402190558046](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402190558046.png) 

#### Condition接口

任意一个Java对象，都拥有—组监视器方法(定义在java.lang.Object上)，主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。**Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式**。

![image-20240402190713341](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402190713341.png) 

##### Condition接口与示例

Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁。Condition对象是由Lock对象(**调用Lock对象的newCondition()方法**)创建出来的，换句话说，Condition是依赖Lock对象的。

![image-20240402190855836](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402190855836.png) 

**分析：**

* **创建Condition对象**:一般都会将Condition对象作为成员变量，获取一个condition必须通过Lock的newCondition方法
*  **await()**:当调用await()方法后，当前线程会释放锁并在此等待
* **signal()**:其他线程调用Condition对象的signal()方法，通知当前线程后，当前线程才从等待状态进入锁的同步队列，尝试获取锁，如果获取到了锁，则从await()方法返回。

##### Condition的部分方法

![image-20240402191108221](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402191108221.png) 

##### Condition实现分析

ConditionObject是同步器AbstractQueuedSynchronizer的内部类，因为Condition的操作需要获取相关联的锁，所以作为同步器的内部类也较为合理。**每个Condition对象都包含着一个队列(以下称为等待队列)**，该队列是Condition对象实现等待/通知功能的关键。

###### 等待队列

等待队列是一个FIFO的队列，并且同步队列中的节点复用了AbstractQueuedSynchronizer.Node，与同步队列中的节点一致。

加入等待队列之后，我们可以通过下面这个图来了解同步器AQS与同步队列，等待队列的对应关系。

![image-20240402191244709](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402191244709.png) 



**总结分析:**

* 一个Condition包含一个等待队列，Condition拥有首节点(firstWaiter)和―尾节点(lastWaiter);
* 一个同步器(AQS)**拥有一个同步队列和多个等待队列**，因为condition对象可以创建多个。(对比来看，Object监视器模型上，一个对象拥有一个同步队列和一个等待队列)

###### 等待

调用Condition的await()方法(或者以await开头的方法)，会使当前**线程进入等待队列并释放锁**，**同时线程状态变为等待状态(WAITING)**。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。如果从队列(同步队列和等待队列)的角度看await()方法，当调用await()方法时，相当于同步队列的首节点(获取了锁的节点)移动到Condition的等待队列中

![image-20240402191507467](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402191507467.png) 

###### 通知

调用Condition的signal()方法，将会唤醒在等待队列中等待时间最长的节点(首节点)，在唤醒节点之前，会将节点移到同步队列中，开始加入到获取同步状态的竞争当中。

![image-20240402191604837](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240402191604837.png) 

成功获取锁之后，被唤醒的线程将从先前调用的await()方法返回，继续执行。Condition的signalAll()方法，相当于对等待队列中的每个节点均执行一次signal()方法，效果就是将等待队列中所有节点全部移动到同步队列中，并唤醒每个节点的线程

### 并发安全容器

#### ConCurrentHashMap

##### HashTable的缺点

在多线程的情况下，使用HashMap是线程不安全的。另外可以使用Hashtable，其是线程安全的，但是Hashtable的运行效率很低，之所以效率低下**主要是因为其实现使用了synchronized关键字**对put等操作进行加锁，而synchronized关键字加锁是对整个对象进行加锁，也就是说在进行put等修改Hash表的操作时，锁住了整个Hash表，从而使得其表现的效率低下。所以最终就诞生了ConcurrentHashMap。

##### 锁分段技术

HashTable容器在竞争激烈的并发环境下表现出效率低下的原因是所有访问HashTable的线程都必须竞争同一把锁，假如**容器里有多把锁，每一把锁用于锁容器其中一部分数据**，那么当多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而可以有效提高并发访问效率，这就是ConcurrentHashMap所使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配—把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。

##### ConCurrentHashMap1.7

在**JDK1.5~1.7版本**，Java使用了分段锁机制实现ConcurrentHashMap.

简而言之，ConcurrentHashMap在对象中**保存了一个Segment数组**，即**将整个Hash表划分为多个分段**;而每个Segment元素，即**每个分段则类似于一个Hashtable;**这样，在执行put操作时首先根据hash算法**定位到元素属于哪个Segment**，然后**对该Segment加锁**即可。因此，ConcurrentHashMap在多线程并发编程中可以实现多线程put操作。

###### 数据结构

整个ConcurrentHashMap由一个个 Segment组成，Segment 代表"部分"或”一段"的意思，所以很多地方都会将其描述为分段锁。简单理解就是，**ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成**。**Segment是一种可重入锁**(ReentrantLock)，在ConcurrentHashMap里扮演锁的角色;**HashEntry则用于存储键值对数据**。

![image-20240403081255601](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240403081255601.png) 

###### 初始化

初始化方法是通过**initialCapacity**、 **loadFactor**和**concurrencyLevel**参数来初始化segment数组、段偏移量segmentShift、段掩码segmentMask和每个segment里的 HashEntry数组来实现的。

* **concurrencyLevel**:并行级别、并发数、Segment 数。**默认是16**，也就是说ConcurrentHashMap有16个Segments,所以理论上，这个时候，最多可以同时支持16个线程并发写，只要它们的操作分别分布在不同的Segment 上。这个值可以在初始化的时候设置为其他值，**但是—旦初始化以后，它是不可以扩容的**。
* **initialCapacity**:初始容量，这**个值指的是整个ConcurrentHashMap 的初始容量**，实际操作的时候需要**平均分给每个Segment**。
* **loadFactor**: Segment 数组不可以扩容，所以**这个负载因子是给每个Segment内部使用的**。

###### 定位Segement

根据前面的数据结构介绍可知，数据都是受到Segment分段锁保护的，所以**插入或者获取元素的时候，必须要先定位到Segment**。可以看到ConcurrentHashMap会首先使用Wang/Jenkins **hash的变种算法对元素的hashCode进行一次再散列**。

**备注：再散列 === 对hashcode进行再进行一次散列**

![image-20240403082254651](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240403082254651.png) 

之所以进行再散列，目的是减少散列冲突，使元素能够均匀地分布在不同的Segment上，从而提高容器的存取效率。
ConcurrentHashMap通过以下**散列算法**定位segment。

![image-20240403082123851](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240403082123851.png) 

###### get操作

Segment的get操作实现非常简单和高效。先经过一次再散列，然后使用这个散列值通过散列运算定位到Segment，再通过散列算法定位到元素。

![image-20240403082517942](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240403082517942.png) 

get操作的高效之处在于**整个get过程不需要加锁**。我们知道HashTable容器的get方法是需要加锁的，那么ConcurrentHash-Map的get操作是如何做到**不加锁不出问题的呢**?

**原因是它的get方法里将要使用的共享变量都定义成volatile类型**，如用于统计当前Segement大小的count字段和用于存储值的HashEntry的value。

![image-20240403082631871](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240403082631871.png) 

在定位元素的代码里我们可以发现，**定位HashEntry**和**定位Segment**的散列算法虽然一样，都与数组的长度减去1再相"与"，但是相"与"的值不一样，**定位Segment使用的是元素的hashcode通过再散列后得到的值的高位**，而**定位HashEntry直接使用的是再散列后的值**。

![image-20240403082829882](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240403082829882.png) 

###### put操作

由于put方法里需要对共享变量进行写入操作，所以**为了线程安全，在操作共享变量时必须加锁**。put方法首先定位到Segment，然后在Segment里进行插入操作。插入操作需要经历两个步骤，**第一步判断是否需要对Segment里的HashEntry数组进行扩容**，**第二步定位添加元素的位置，然后将其放在HashEntry数组里**。（**先判断，后插入**）

* **是否需要扩容**：**在插入元素前**会先判断Segment里的HashEntry数组是否超过容量(threshold)，如果超过阈值，则对数组进行扩容。值得—提的是，**Segment的扩容判断比HashMap更恰当**，因为HashMap是在插入元素后判断元素是否已经到达容量的，如果到达了就进行扩容，**但是很有可能扩容之后没有新元素插入**，这时HashMap就进行了一次无效的扩容。

* **如何扩容**：在扩容的时候，首先会创建一个容量是**原来容量两倍的数组**，然后将原数组里的元素进行再散列后插入到新的数组里。为了高效，ConcurrentHashMap不会对整个容器进行扩容，而**只对某个segment进行扩容**。

###### size操作

如果要统计整个ConcurrentHashMap里元素的大小，就**必须统计所有Segment里元素的大小后求和**。

Segment里的全局变量count是一个volatile变量，那么在多线程场景下，是不是直接把所有Segment的count相加就可以得到整个ConcurrentHashMap大小了呢?
不是的，**虽然相加时可以获取每个Segment的count的最新值**，但是可能累加前使用的count发生了变化，那么统计结果就不准了。所以，**最安全的做法是在统计size的时候把所有Segment的put、remove和clean方法全部锁住**，但是这种做法显然非常低效。
（**备注：累加也需要时间，在这个时间段内修改的count，你做加法时是看不出来的**）
因为在累加count操作过程中，之前累加过的count发生变化的**几率非常小**，所以ConcurrentHashMap的做法是先尝试**3次**通过不锁住Segment的方式来统计各个Segment大小，**如果统计的过程中，容器的count发生了变化，则再采用加锁的方式**来统计所有Segment的大小。

那么ConcurrentHashMap是如何判断在统计的时候容器是否发生了变化呢?
使用modCount变量，在put、remove和clean方法里操作元素前都会将变量modCount进行加1，那么在统**计size 前后比较modCount是否发生变化，从而得知容器的大小是否发生变化**。

##### ConCurrentHashMap1.8

在JDK1.7之前，ConcurrentHashMap是通过分段锁机制来实现的，所以**其最大并发度受Segment的个数限制**。因此，在JDK1.8中，ConcurrentHashMap的实现原理摒弃了这种设计，而是选择了与**HashMap类似的数组+链表+红黑树的方式实现**，而**加锁则采用CAS和synchronized实现**。

###### 数据结构

结构上和Java8的 HashMap基本上一样，不过它要保证线程安全性，所以在**源码上确实要复杂一些**。

![image-20240403084102561](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240403084102561.png) 

###### Node节点

![image-20240403084148167](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240403084148167.png) 

可以看出，每个Node 里面是 key-value 的形式，并且**把 value 用volatile修饰**，以便保证可见性，同时内部还有一个指向下一个节点的next 指针。

###### put方法

###### get方法

自己看源码

#### CopyOnWriteArrayList

从JDK1.5开始，Java并发包里提供了使用CopyOnWrite机制实现的并发容器CopyOnWriteArray-List 作为主要的并发List，CopyOnWrite的并发集合还包括CopyOnWriteArraySet，其底层正是利用CopyOnWriteArrayList 实现的。所以今天我们以CopyOnWriteArrayList为突破口，来看一下CopyOnWrite容器的特点。

###### CopyOnWrite含义

从CopyOnWriteArrayList 的名字就能看出它是满足CopyOnWrite 的ArrayList，**CopyOnWrite的意思是说，当容器需要被修改的时候，不直接修改当前容器，而是先将当前容器进行Copy，复制出一个新的容器，然后修改新的容器，完成修改之后，再将原容器的引用指向新的容器。**这样就完成了整个修改过程。

###### 使用场景

* **读操作可以尽可能的快，而写即使慢—些也没关系**：为了将读取的性能发挥到极致，CopyOnWriteArrayList**读取是完全不用加锁**的，**并且写入也不会阻塞读取操作，也就是说你可以在写入的同时进行读取**。**只有写入和写入之间需要进行同步**，也就是不允许多个写入同时发生，所以会更慢一点。
* **读多写少**：写入本身是会拷贝一份出来，会增加资源的消耗，同时多个写入之间需要进行同步，所以应该尽量的少。

###### 特点

**迭代期间允许修改集合内容**：ArrayList**在迭代期间如果修改集合的内容**，会抛出Concurrent-ModificationException异常的，
CopyOnWriteArrayList 的迭代器在迭代的时候，如果数组内容被修改了,CopyOnWriteArrayList不会报 ConcurrentModificationException的异常，**因为迭代器使用的依然是旧数组，只不过迭代的内容可能已经过时了**。

备注：迭代器在迭代过程中会检查集合是否被修改，如果检测到修改，则会抛出此异常，例如：在遍历List期间删除元素问题

###### 缺点

* **内存占用问题**：因为CopyOnWrite 的**写时复制机制**，所以**在进行写操作的时候，内存里会同时驻扎两个对象的内存**，这一点会占用额外的内存空间。
* **数据―致性问题**：由于CopyOnWrite容器的修改是**先修改副本，所以这次修改对于其他线程来说，并不是实时能看到的**，只有在修改完之后才能体现出来。如果你希望写入的的数据马上能被其他线程看到，CopyOnWrite容器是不适用的。

#### ConCurrentLinkedQueue

实现一个线程安全的队列有两种方式：—种是使用**阻塞算法**，另一种是使用**非阻塞算法**。

使用阻塞算法的队列可以用一个锁(入队和出队用同一把锁)或两个锁(入队和出队用不同的锁)等方式来实现。

非阻塞的实现方式则可以**使用循环CAS的方式来实现**，这个死循环去配合CAS也就是典型的**乐观锁**的思想。

ConcurrentLinkedQueue就是使用**非阻塞算法**实现线程安全的**非阻塞队列**

**适合用在不需要阻塞功能，且并发不是特别剧烈的场景**。

#### 阻塞队列BlockingQueue

###### 阻塞队列基本介绍

阻塞队列是一个队列，在数据结构中起的作用如下图：

![image-20240328110141531](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240328110141531.png) 

当队列是空的，从队列中获取元素的操作将会被阻塞。

当队列是满的，从队列中添加元素的操作将会被阻塞。

试图从空的队列中获取元素的线程将会被阻塞，直到其他线程往空的队列插入新的元素。

试图向已满的队列中添加新元素的线程将会被阻塞，直到其他线程从队列中移除一个或多个元素或者完全清空，使队列变得空闲起来并后续新增。

**阻塞队列的用处：**

在多线程领域：所谓阻塞，在某些情况下会挂起线程（即阻塞），一旦条件满足，被挂起的线程又会自动被唤起。

**为什么需要 BlockingQueue？**

好处是我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue 都给你一手包办了。
在 concurrent 包发布以前，在多线程环境下，我们每个程序员都必须自己去控制这些细节，尤其还要兼顾效率和线程安全，而这会给我们的程序带来不小的复杂度。

###### 接口架构图

![image-20240328110437828](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240328110437828.png) 

* **ArrayBlockingQueue**：由**数组**结构组成的有界阻塞队列。
* **LinkedBlockingQueue**：由**链表**结构组成的**有界**（默认值为：integer.MAX_VALUE）阻塞队列。
* **SynchronousQueue**：不存储元素的阻塞队列，也即**单个元素的队列**。

==**这些类都实现了BolckQueue接口**==

###### 四组API 的使用

![image-20240328110740942](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240328110740942.png) 

![image-20240328110812798](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240328110812798.png) 

###### 抛出异常(add,remove)

**add的返回值为boolean如果队列已满则报错，remove的返回值为弹出的元素如果队列为空则报错，element的返回值为队首元素**

~~~java
		BlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);

        System.out.println(blockingQueue.add("a"));
        System.out.println(blockingQueue.add("b"));
        System.out.println(blockingQueue.add("c"));
        //如果阻塞队列满了，还add的话会抛	IllegalStateException: Queue full
//        System.out.println(blockingQueue.add("d"));

        System.out.println("________________________");
		System.out.println(blockingQueue.element()); //返回队首元素

        System.out.println(blockingQueue.remove());
        System.out.println(blockingQueue.remove());
        System.out.println(blockingQueue.remove());
        //如果阻塞队列为空，还remove会抛 NoSuchElementException
//        System.out.println(blockingQueue.remove());
~~~

###### 返回特殊值(offer,poll)

**offer的返回值为boolean如果队列已满则返回false，poll的返回值为弹出的元素如果队列为空则返回null，peek的返回值为队首元素**

~~~java
		ArrayBlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);

        System.out.println(blockingQueue.offer("a"));
        System.out.println(blockingQueue.offer("b"));
        System.out.println(blockingQueue.offer("c"));
        //不会抛出异常，如果添加失败就返回false
//        System.out.println(blockingQueue.offer("d"));

        System.out.println("________________________");
        System.out.println(blockingQueue.peek());//返回队首元素

        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        System.out.println(blockingQueue.poll());
        //不会抛出异常，如果删除失败就返回null
//        System.out.println(blockingQueue.poll());
~~~

###### 一直阻塞(put,take)

**put方法没有返回值，take方法的返回值为弹出元素**

~~~java
		ArrayBlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);

        blockingQueue.put("a");
        blockingQueue.put("b");
        blockingQueue.put("c");
        //如果阻塞队列满了，还put的话，该put操作会一直阻塞在这里，直到阻塞队列出队元素
//        blockingQueue.put("d");

        System.out.println("__________________________");

        System.out.println(blockingQueue.take());
        System.out.println(blockingQueue.take());
        System.out.println(blockingQueue.take());
        //如果阻塞队列为空，还take的话，该take操作会一直阻塞在这里，直到阻塞队列有进队元素
//        System.out.println(blockingQueue.take());
~~~

###### 超时退出(offer,poll)

**超时退出和返回特殊值所使用的方法是一样的，只不过进行了重载，在超时退出中，需要额外提供时间的相关参数**

~~~java
		ArrayBlockingQueue<String> blockingQueue = new ArrayBlockingQueue<>(3);

        System.out.println(blockingQueue.offer("a", 3, TimeUnit.SECONDS));
        System.out.println(blockingQueue.offer("b", 3, TimeUnit.SECONDS));
        System.out.println(blockingQueue.offer("c", 3, TimeUnit.SECONDS));
        //如果阻塞队列满了，还offer的话,这个offer操作会阻塞3秒，如果3秒过后，阻塞队列仍满的话，就退出offer操作
//        System.out.println(blockingQueue.offer("d", 3, TimeUnit.SECONDS));

        System.out.println("__________________________");

        System.out.println(blockingQueue.poll(3, TimeUnit.SECONDS));
        System.out.println(blockingQueue.poll(3, TimeUnit.SECONDS));
        System.out.println(blockingQueue.poll(3, TimeUnit.SECONDS));
        //如果阻塞队列为空，还poll的话,这个poll操作会阻塞3秒，如果3秒过后，阻塞队列仍为空的话，就退出poll操作
//        System.out.println(blockingQueue.poll(3, TimeUnit.SECONDS));
~~~

###### 同步队列

**SynchronousQueue** 没有容量，或者说容量默认为一。与其他的 BlockingQueue 不同，SynchronousQueue是一个不存储元素的 BlockingQueue 。

每一个**put操作**必须要等待一个**take操作**，否则不能继续添加元素，反之亦然。

~~~java
		SynchronousQueue<String> synchronousQueue = new SynchronousQueue<>();

        //A线程向同步队列里面写入元素
        new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                try {
                    System.out.println(Thread.currentThread().getName() + " 写入元素" + i);
                    Thread.sleep(2000);
                    synchronousQueue.put(String.valueOf(i));
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        },"A线程").start();

        //B线程向同步队列里面读出元素
        new Thread(() -> {
            for (int i = 0; i < 5; i++) {
                try {
                    System.out.println(Thread.currentThread().getName() + " 读出元素" + i);
                    synchronousQueue.take();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        },"B线程").start();
~~~

![image-20240328120118210](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240328120118210.png) 

#### Fork/Join框架

Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。

###### 运行流程图

![image-20240403092832292](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240403092832292.png) 

###### 工作窃取算法

工作窃取(work-stealing)算法是指**某个线程从其他队列里窃取任务来执行**。那么，为什么需要使用工作窃取算法呢?假如我们需要做一个比较大的任务，可以把这个任务分割为若干互不依赖的子任务，为了减少线程间的竞争，把这些子任务分别放到不同的队列里，并为每个队列创建一个单独的线程来执行队列里的任务，线程和队列——对应。比如A线程负责处理A队列里的任务。但是，有的线程会先把自己队列里的任务干完，而其他线程对应的队列里还有任务等待处理。**干完活的线程与其等着，不如去帮其他线程干活**，于是它就去其他线程的队列里窃取一个任务来执行。而在这时它们会访问同一个队列，所以为了减少窃取任务线程和被窃取任务线程之间的竞争，**通常会使用双端队列，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行**。

![image-20240403093025726](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240403093025726.png) 

###### Fork/Join使用

###### Fork/Join实现原理

### 原子类和并发工具类

#### CAS

###### 什么是CAS

CAS的全称为Compare-And-Swap，直译就是对比交换。是**一条CPU的原子指令**，其**作用是让CPU先进行比较两个值是否相等，然后原子地更新某个位置的值**，经过调查发现，其实现方式是基于硬件平台的汇编指令，就是说**CAS是靠硬件实现的，JVM只是封装了汇编调用**，那些AtomicInteger类便是使用了这些封装后的接口。

简单解释：CAS操作需要输入两个数值，一个旧值(期望操作前的值)和一个新值，在操作期间先比较下在旧值有没有发生变化，**如果没有发生变化，才交换成新值，发生了变化则不交换**。

###### CAS使用举例

并发线程累加操作同一个变量500次，但最终结果一般都到不了500，其背后原因就是并发状态下，线程不安全导致的。

针对这个问题，我们如果**将共享的操作变量int换成AtomicInteger**，也可以解决问题。其中**AtomicInteger的实现是使用了CAS操作**

![image-20240403094028547](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240403094028547.png) 

###### CAS问题

**CAS方式为乐观锁**，**synchronized为悲观锁**。因此使用CAS解决并发问题通常情况下性能更优。

但是CAS仍然存在三大问题：**ABA问题**，**循环开销大**，**只能保证一个共享变量的原子操作**。

1. ABA问题
   **什么是ABA问题**：因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，**但是如果一个值原来是A，变成了B，又变成了A**，那么**使用CAS进行检查时会发现它的值没有发生变化**，但是实际上却变化了。ABA很多业务场景是可以容忍的，但是有些业务场景就会带来问题。
   **ABA问题的解决思路**：使用**版本号**。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么**A一B一A**就会变成**1A→2B→3A**。从Java 1.5开始，JDK的Atomic包里提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，**如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值**。

2. 循环开销大
   自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销
3. 只能保证一个共享变量的原子操作
   当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用**锁**

###### 乐观锁悲观锁

乐观锁和悲观锁是用来解决并发场景下数据竞争问题的两种思想。

乐观锁:**乐观锁在操作数据时非常乐观，认为别人不会同时修改数据**。因此在执行更新的时候只会判断—下在此期间别人是否修改了数据，如果别人修改了数据则放弃操作，否则执行操作。

悲观锁:**悲观锁在操作数据时比较悲观，认为别人会同时修改数据**。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁;上锁期间其他人不能修改数据

#### 原子操作类

###### 原子更新基本类型

![image-20240403095007857](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240403095007857.png) 

###### 原子更新数组

![image-20240403095133306](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240403095133306.png) 

![image-20240403095240042](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240403095240042.png) 

###### 原子更新引用类型

###### 原子更新字段

#### 并发工具类

###### CountDownLatch

**原理：**

* CountDownLatch 主要有两个方法，一个是CountDown方法，另一个是await 方法
* 当一个或多个线程调用 await 方法时，这些线程会阻塞，只有被唤醒才能执行await 下面的代码
* 其他线程调用CountDown方法会将计数器减1（调用CountDown方法的线程不会阻塞）
* 当计数器变为0时，await 方法阻塞的线程会被唤醒，继续执行下面的代码

~~~java
 public static void main(String[] args) throws InterruptedException {
    //定义倒计时器
    CountDownLatch countDownLatch = new CountDownLatch(6);

    for (int i = 0; i < 6; i++) {
        new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + " 执行了减1操作");
            //计数器减1
            countDownLatch.countDown();
        }, String.valueOf(i)).start();
    }

    //阻塞等待计数器归零
    countDownLatch.await();
    System.out.println("所有线程都执行减一操作完毕");
}
~~~

###### CyclicBarrier

![image-20240328084808428](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240328084808428.png) 

翻译：CyclicBarrier 篱栅

作用：和上面的减法相反，这里是加法。CyclicBarrier 作用是让一组线程相互等待，当达到一个共同点时，所有之前等待的线程再继续执行，且 CyclicBarrier 功能可重复使用。

CyclicBarrier 字面意思回环栅栏（循环屏障），通过它可以实现让一组线程等待至某个状态（屏障点）之后再全部同时执行。叫做回环是因为当所有等待线程都被释放以后，CyclicBarrier可以被重用。 

当所有的龙珠都被各个线程集齐后，才会执行CyclicBarrier 里面的线程“召唤神龙”

~~~java
public static void main(String[] args) {
    CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> {
        System.out.println("七颗龙珠已集齐，开始召唤神龙");
    });

    for (int i = 0; i < 7; i++) {
        final int temp = i;
        new Thread(() -> {
            try {
                System.out.println(Thread.currentThread().getName() + " 收集了龙珠" + temp);
                cyclicBarrier.await();
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            } catch (BrokenBarrierException e) {
                throw new RuntimeException(e);
            }
        },"线程"+String.valueOf(i)).start();
    }
}
~~~

###### Semaphore

Semaphore（信号量）是Java中一个并发控制工具，用于控制对共享资源的访问。它基于计数器的原理，可以限制同时访问某个资源的线程数量。

Semaphore主要有两个方法，一个是acquire（获取），另一个是release （释放）

* `acquire()`方法尝试获取一个许可证，如果当前没有可用的许可证，则该线程将被阻塞，直到有可用的许可证为止。当一个线程调用 acquire 操作时，他要么通过成功获取信号量（信号量-1）；要么一直等下去，直到有线程释放信号量，或超时
* `release()`方法释放一个许可证，使其可供其他线程使用。实际上会将信号量的值 + 1，然后唤醒等待的线程。

通过适当地使用`acquire()`和`release()`方法，在超过信号量允许的线程数量时，可以限制并发访问共享资源的线程数量，实现线程间的同步和互斥。

~~~java
public static void main(String[] args) {
    Semaphore semaphore = new Semaphore(3);// 模拟资源类，有3个空车位

    for (int i = 0; i < 6; i++) {// 模拟6个车
        new Thread(() -> {
            try {
                semaphore.acquire();// acquire 得到
                System.out.println(Thread.currentThread().getName() + " 正在停车");
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            } finally {
                semaphore.release();// 释放这个位置
            }
        },"车"+String.valueOf(i)).start();
    }
}
~~~

###### Exchanger

Exchanger(交换者)是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。

exchange()方法:入参是本线程需要传递给对方的数据，返回值则是对方线程传过来的数据。

![image-20240403100053824](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240403100053824.png) 

### 线程池和Executor框架

#### 线程池原理

###### 为什么要使用线程池

Java中的线程池是运用场景最多的并发框架，几乎所有需要异步或并发执行任务的程序都可以使用线程池。在开发过程中，合理地使用线程池能够带来3个好处。

1. 降低资源消耗:通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
2. 提高响应速度:当任务到达时，任务可以不需要等到线程创建就能立即执行。
3. 提高线程的可管理性:线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控

###### 线程池实现原理

当提交一个任务到线程池之后，线程池处理这个任务的流程如下。

![image-20240403101315337](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240403101315337.png) 

**流程分析:**

1. 首先会判断核心线程池是否已满:如果没有满，则直接创建新线程来执行任务。如果已经满了，则进行下一步判断，尝试将任务放入队列。
2. 判断队列是否已经满了:如果没有满，则任务放入队列，结束。如果队列已经满了，则进行下一步判断
3. 判断线程池是否已经满:如果没满，则创建新线程来执行任务。如果已经满了，则按照拒绝策略来处理任务。

#### Executor框架

###### Executo两级调度模型

在上层，Java多线程程序通常把应用分解为若干个任务，然后**使用用户级的调度器(Executor框架)将这些任务映射为固定数量的线程**;

在底层，**操作系统内核将这些线程映射到硬件处理器上**。这种两级调度模型的示意图所示。

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240403101657628.png" alt="image-20240403101657628" style="zoom: 67%;" /> 

从图中可以看出，**应用程序通过Executor框架控制上层的调度**;而**下层的调度由操作系统内核控制**，**下层的调度不受应用程序的控制**。

###### Executor框架结构

1. **Executor框架主要由3大部分组成**:
   * **任务**。包括被执行任务需要实现的接口:Runnable接口或Callable接口。
   * **任务的执行**。包括任务执行机制的核心接口Executor，以及继承自Executor的ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口(ThreadPoolExecutor和ScheduledThreadPoolExecutor)。
   * **异步计算的结果**。包括接口Future和实现Future接口的FutureTask类。
2. **类和接口的简介:**
   * Executor是一个接口，它是Executor框架的基础，它将任务的提交与任务的执行分离开来。
   * ThreadPoolExecutor是线程池的核心实现类，用来执行被提交的任务. ScheduledThreadPoolExecutor是一个实现类，可以在给定的延迟后运行命令，或者定期执行命令。
   * Future接口和实现Future接口的FutureTask类，代表异步计算的结果。
   * Runnable接口和Callable接口的实现类，都可以被ThreadPoolExecutor或Scheduled- ThreadPoolExecutor执行。
3. **类和接口的使用示意图:**

![image-20240403102625850](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240403102625850.png) 

4. **流程分析:**
   1. 主线程首先要创建实现Runnable或者Callable接口的任务对象。工具类Executors可以把一个Runnable对象封装为一个Callable对象(Executors.callable(Runnable task)或Executors.callable(Runnable task,Object resule))。
   2. 然后可以把Runnable对象直接交给ExecutorService执行(ExecutorService.execute(Runnable command));或者也可以把Runnable对象或Callable对象提交给ExecutorService执行(Executor-Service.submit(Runnable task)或
      ExecutorService.submit(Callable<T>task))。
   3. 如果执行ExecutorService.submit(...)，ExecutorService将返回一个实现Future接口的对象FutureTask。由于FutureTask实现了Runnable，程序员也可以创建FutureTask，然后直接交给ExecutorService执行。
   4. 最后，主线程可以执行FutureTask.get()方法来等待任务执行完成。主线程也可以执行FutureTask.cancel (boolean mayInterruptIfRunning)来取消此任务的执行。

###### Executor框架成员

总结一下Executor的框架成员，主要有:**ThreadPoolExecutor**、**ScheduledThreadPoolExecutor**、**Future接口**、**Runnable接口**、**Callable接口**和**Executors**。

1. **ThreadPoolExecutor**线程池的实现类:**是Executor框架最核心的类**，Executors可以创建3种类型的线程池:**SingleThreadExecutor**、**FixedThreadPool**和**CachedThreadPool**
   * FixedThreadPool:一种使用固定线程数的线程池，适用于为了满足资源管理的需求，而需要限制当前线程数量的应用场景，它适用于负载比较重的服务器
   * SingleThreadExecutor:一种使用单个线程数的线程池，适用于需要保证顺序地执行各个任务;并且在任意时间点，不会有多个线程是活动的应用场景。
   * CachedThreadPool:一种会根据需要创建新线程的线程池，是大小无界的线程池，适用于执行很多的短期异步任务的小程序，或者是负载较轻的服务器
2. **ScheduledThreadPoolExecutor**线程池实现类:一种用于定时任务或周期任务的线程池Executors可以创建2种类型的
   延迟线程池
   * ScheduledThreadPoolExecutor:包含若干个线程的ScheduledThreadPoolExecutor。适用于需要多个后台线程执行周期任务，同时为了满足资源管理的需求而需要限制后台线程的数量的应用场景
   * SingleThreadScheduledExecutor:只包含一个线程的ScheduledThreadPoolExecutor。适用于需要单个后台线程执行周期任务，同时需要保证顺序地执行各个任务的应用场景
3. **Future接口**:Future接口和实现Future接口的FutureTask类用来表示异步计算的结果。当把Runnable接口或Callable接口的实现类提交(submit)给线程池之后，可以拿到一个实现了Future接口的对象返回值。
   * 提交Runnable任务到ExecutorService时，这个方法的返回类型是Future<?>，它实际上是一个占位符，因为Runnable本身不返回任何值。这里的Future对象主要用来检查计算是否完成，但没有实际的返回值。
   * 提交Callable任务时，submit(Callable<T> task)方法会返回一个Future<T>对象，通过这个Future对象可以获取到Callable任务计算的结果
4. **Runnable接口或Callable接口**:实现这两任意接口的任务对象可以被线程池执行，区别就是提交Runnable任务不会返回结果，而Callable接口会。 
   * Runnable接口中的run方法没有返回值(void)，所以当你实现Runnable接口并重写run方法时，你不能返回一个结果给调用者。
   * Callable接口中的call方法有返回值，可以是一个任意类型的对象。这使得Callable任务能够计算结果并返回给调用者。

#### ThreadPoolExecutor详解

**记住口诀**：**三大方法，七大参数，四种拒绝策略**

###### **三大方法**

* **Executors.newFixedThreadPool(int)**：执行长期任务性能好，创建一个线程池，一池有N个固定的线程，有固定线程数的线程
  （int，int，。。。。。）

* **Executors.newSingleThreadExecutor()**：只有一个线程（1,1，。。。。）
* **Executors.newCachedThreadPool()**：执行很多短期异步任务，线程池根据需要创建新线程，但在先构建的线程可用时将重用他们。可扩容，遇强则强（0，nteger.MAX_VALUE，。。。。。。）

这三大方法底层都是使用的**ThreadPoolExecutor（）这个方法**，在实际开发中，建议直接使用ThreadPoolExecutor（）

###### **七大参数**

查看三大方法的底层源码，发现**本质都是调用了 new ThreadPoolExecutor ( 7 大参数 )**

~~~java
public ThreadPoolExecutor(int corePoolSize,
                    int maximumPoolSize,
                    long keepAliveTime,
                    TimeUnit unit,
                    BlockingQueue<Runnable> workQueue,
                    ThreadFactory threadFactory,
                    RejectedExecutionHandler handler) {
                    //业务代码
}
~~~

* **corePoolSize**：核心线程数。在创建了线程池后，线程中没有任何线程，等到有任务到来时才创建线程去执行任务。默认情况下，在创建了线程池后，线程池中的线程数为0，当有任务来之后，就会创建一个线程去执行任务，当线程池中的线程数目达corePoolSize后，就会把到达的任务放到缓存队列当中。

* **maximumPoolSize** ：最大线程数。表明线程中最多能够创建的线程数量，此值必须大于等于1，临时线程数 = 最大线程数 - 核心线程数。
* **keepAliveTime**：空闲的线程保留的时间。如果临时线程等待了keepAliveTime时间仍然没有新的任务进来，就关闭临时线程
* **TimeUnit** ：keepAliveTime的时间单位。TimeUnit是一个枚举类，里面可以找到keepAliveTime的时间单位。
* **BlockingQueue< Runnable>** ：阻塞队列，存储等待执行的任务。参数有ArrayBlockingQueue、LinkedBlockingQueue、SynchronousQueue可选，同上一节阻塞队列。
* **ThreadFactory**：线程工厂，用来创建线程，一般默认即可。Executors.defaultThreadFactory()
* **RejectedExecutionHandler** ：拒绝策略。队列已满，而且任务量大于最大线程的异常处理策略。有四种取值。

###### 四种拒绝策略

~~~java
//ThreadPoolExecutor.AbortPolicy():丢弃任务并抛出RejectedExecutionException异常。（默认）

//ThreadPoolExecutor.DiscardPolicy()：也是丢弃任务，但是不抛出异常。

//ThreadPoolExecutor.DiscardOldestPolicy()：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）

//ThreadPoolExecutor.CallerRunsPolicy()：由主线程去执行这个任务，老板亲自上
~~~

###### 底层工作原理

![image-20240328151409219](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240328151409219.png) 

**思考题：线程是否越多越好？**

一个计算为主的程序（专业一点称为**CPU**密集型程序）。多线程跑的时候，可以充分利用起所有的cpu核心，比如说4个核心的cpu,开4个线程的时候，可以同时跑4个线程的运算任务，此时是最大效率。但是如果线程远远超出cpu核心数量 反而会使得任务效率下降，因为频繁的切换线程也是要消耗时间的。

**因此对于cpu密集型的任务来说，线程数等于cpu数是最好的了。**

如果是一个磁盘或网络为主的程序（**IO**密集型）。一个线程处在IO等待的时候，另一个线程还可以在CPU里面跑，有时候CPU闲着没事干，所有的线程都在等着IO，这时候他们就是同时的了，而单线程的话此时还是在一个一个等待的。我们都知道IO的速度比起CPU来是慢到令人发指的。所以开多线程，比方说多线程网络传输，多线程往不同的目录写文件，等等。**此时 线程数等于IO任务数是最佳的**。

```java
public static void main(String[] args) {
    // 获得CPU的内核数
//        System.out.println(Runtime.getRuntime().availableProcessors());
    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
            2,
            5,
            3,
            TimeUnit.SECONDS,
            new ArrayBlockingQueue<>(3),
            Executors.defaultThreadFactory(),
            new ThreadPoolExecutor.CallerRunsPolicy()
    );

    try {
        for (int i = 1; i <= 9; i++) {
            int finalI = i;
            //最大容量为：maximumPoolSize + workQueue = 最大容量数
            threadPoolExecutor.execute(() -> {
                System.out.println(Thread.currentThread().getName() + " 办理业务" + finalI);
            });
        }
    } catch (Exception e) {
        throw new RuntimeException(e);
    } finally {
        threadPoolExecutor.shutdown();// 用完记得关闭
    }
}
```

#### ScheduledT-P-E详解

#### FutureTask详解

FutureTask为Future提供了基础实现，如获取任务执行结果(get)和取消任务(cancel)等。如果任务尚未完成，获取任务执行结果时将会阻塞。**一旦执行结束，任务就不能被重启或取消**(除非使用runAndReset执行计算)。**FutureTask常用来封装Callable和 Runnable**，也可以作为一个任务提交到线程池中执行。除了作为一个独立的类之外，此类也提供了一些功能性函数供我们创建自定义task类使用。**FutureTask 的线程安全由CAS来保证**

###### FutureTask三种状态

1. **未启动**: FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态。当创建一个FutureTask，且没有执行FutureTask.run()方法之前，这个FutureTask处于未启动状态。
2. **已启动**: FutureTask.run()方法被执行的过程中，FutureTask处于已启动状
3. **已完成**:FutureTask.run()方法执行完后正常结束，或被取消(FutureTask.cancel(...))，或执行FutureTask.run()方法时抛出异常而异常结束，FutureTask处于已完成状态。

![image-20240403104044742](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240403104044742.png) 

###### get和cancle方法

1. **FutureTask.get()分析**:当FutureTask处于未启动或已启动状态时，执行FutureTask.get()方法将导致调用线程阻塞;当FutureTask处于已完成状态时，执行FutureTask.get()方法将导致调用线程立即返回结果或抛出异常。
2. **FutureTask.cancel分析**:当FutureTask处于未启动状态时，执行FutureTask.cancel()方法将导致此任务永远不会被执行;当FutureTask处于已启动状态时，执行FutureTask.cancel(true)方法将以中断执行此任务线程的方式来试图停止任务;当FutureTask处于已启动状态时，执行FutureTask.cancel(false)方法将不会对正在执行此任务的线程产生影响(让正在执行的任务运行完成);当FutureTask处于已完成状态时，执行FutureTask.cancel(...)方法将返回false。

![image-20240403104320765](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240403104320765.png) 

###### FutureTask的使用

可以把FutureTask交给Executor执行;也可以通过ExecutorService.submit(...)方法返回一个FutureTask，然后执行
FutureTask.get()方法或FutureTask.cancel(...)方法。除此以外，还可以单独使用FutureTask。

### 生产者和消费者

线程间的通信 , 线程之间要协调和调度

####  synchroinzed 版

```java
public class Solution {
    public static void main(String[] args) {
        Date date = new Date();
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                try {
                    date.increment();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        }, "A线程").start();
        new Thread(() -> {
            for (int i = 0; i < 10; i++) {
                try {
                    date.decrement();
                } catch (InterruptedException e) {
                    throw new RuntimeException(e);
                }
            }
        }, "B线程").start();
    }
}

//资源类
class Date {
    private int number = 0;

    public synchronized void increment() throws InterruptedException {
        if (number != 0) { // number==1时,就等待
            this.wait();
        }
        number++;
        System.out.println(Thread.currentThread().getName() + "，执行了++操作，此时number的值——>" + number);
        this.notify(); //执行完number++后，唤醒其他线程
    }

    public synchronized void decrement() throws InterruptedException {
        if (number == 0) { // number==0时,就等待
            this.wait();
        }
        number--;
        System.out.println(Thread.currentThread().getName() + "，执行了--操作，此时number的值——>" + number);

        this.notify(); //执行完number--后，唤醒其他线程
    }
}
```

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240327110302526.png" alt="image-20240327110302526" style="zoom: 80%;" /> 

#### 问题升级（虚假唤醒）

如果有4个线程，两个加，两个减，再执行前述代码，则结果如下：++和--的操作没有交替执行

![image-20240327110547406](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240327110547406.png) 

这就是所谓的**虚假唤醒**问题。

虚假唤醒是一种现象，它只会出现在多线程环境中，指的是在多线程环境下，多个线程等待在同一个条件上，等到条件满足时，所有等待的线程都被唤醒，但由于多个线程执行的顺序不同，后面竞争到锁、获得运行权的线程在运行时条件已经不再满足，**线程应该睡眠但是却继续往下运行的一种现象**。

**白话：**多线程环境的编程中，我们经常遇到让多个线程等待在一个条件上，等到这个条件成立的时候我们再去唤醒这些线程，让它们接着往下执行代码的场景。
**正常情况：**假如某一时刻条件成立，所有的线程都被唤醒了，然后去竞争锁，因为同一时刻只会有一个线程能拿到锁，其他的线程都会阻塞到锁上无法往下执行，等到成功争抢到锁的线程消费完条件，释放了锁，后面的线程继续运行。
**虚假唤醒：**拿到锁时这个条件很可能已经不满足了，这个时候线程应该继续在这个条件上阻塞下去，而不应该继续执行，如果继续执行了，就说发生了虚假唤醒。

==**核心原因：判断是否阻塞不应该用if只判断一次，而应该在循坏中循环判断是否阻塞**==

所以，**将资源类的if全部替换为while后**，代码的运行结果如下：**四个线程可以交替执行，++和--操作也可以交替执行**

![image-20240327111624615](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240327111624615.png) 

#### JUC版

**三剑客对比：**

![image-20240327113239201](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240327113239201.png) 

**Condition接口：**

wait，notify，notifyAll方法，这些方法与synchornized关键字相配合，可以实现等待/通知模式。

Condition接口也提供了类似的Object的监视器方法（**await()、signal()、signalAll()**），与Lock配合可以实现等待/通知模式。但是这两者在使用方式以及功能上还是有差别的。
**Condition接口来自于java.util.concurrent.locks 包下，是JUC的三个包之一**

![image-20240327114536984](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240327114536984.png) 

（**使用时，通过lock.newCondition()方法生成一个Condition对象**，然后将原本是wait的地方替换为condition.await(),将原本是notifyall()的地方替换为condition.signalAll()）

**注意：要有手动上锁解锁的操作**

~~~java
//资源类
class Date {
    private int number = 0;
    //1.定义lock锁
    Lock lock = new ReentrantLock();
    //2.定义Condition
    Condition condition = lock.newCondition();

    public void increment() throws InterruptedException {
        lock.lock();
        try {
            while (number != 0) { // number==1时,就等待
                condition.await();
            }
            number++;
            System.out.println(Thread.currentThread().getName() + "，执行了++操作，此时number的值——>" + number);
            condition.signalAll(); //执行完number++后，唤醒其他线程
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            lock.unlock();
        }
    }

    public void decrement() throws InterruptedException {
        lock.lock();
        try {
            while (number == 0) { // number==0时,就等待
                condition.await();
            }
            number--;
            System.out.println(Thread.currentThread().getName() + "，执行了--操作，此时number的值——>" + number);

            condition.signalAll(); //执行完number--后，唤醒其他线程
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        } finally {
            lock.unlock();
        }
    }
}
~~~

#### 精确通知顺序访问

能实现精准通知的顺序访问，这就是JUC的优势了，现在我假设，A打印完后，B打印，B打印完后，C打印，C打印完后，A再打印。明明是三个线程，随机执行的，现在竟然可以顺序执行，是不是很神奇呀！这就是归功于JUC下的Condition接口了。具体代码如下：

```java
public class Solution {
    public static void main(String[] args) {
        Date date = new Date();
        new Thread(() -> {for (int i = 0; i < 10; i++) date.printA();},"A线程").start();
        new Thread(() -> {for (int i = 0; i < 10; i++) date.printB();},"B线程").start();
        new Thread(() -> {for (int i = 0; i < 10; i++) date.printC();},"C线程").start();
    }
}

class Date {
    private Lock lock = new ReentrantLock();
    private Condition condition1 = lock.newCondition();
    private Condition condition2 = lock.newCondition();
    private Condition condition3 = lock.newCondition();
    private int number = 0;

    public void printA() {
        lock.lock();
        try {
            while (number != 0) { //number！=0时，A线程循环等待
                condition1.await();
            }
            System.out.println(Thread.currentThread().getName() + "——》AAAAAAAAAAAA");
            number = 1;
            condition2.signal(); //A执行完后，唤醒B线程
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            lock.unlock();
        }
    }

    public void printB() {
        lock.lock();
        try {
            while (number != 1) { //number！=1时，B线程循环等待
                condition2.await();
            }
            System.out.println(Thread.currentThread().getName() + "——》BBBBBBBBBBB");
            number = 2;
            condition3.signal(); //B执行完后，唤醒C线程
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            lock.unlock();
        }
    }

    public void printC() {
        lock.lock();
        try {
            while (number != 2) { //number！=2时，C线程循环等待
                condition3.await();
            }
            System.out.println(Thread.currentThread().getName() + "——》CCCCCCCCCCCC");
            number = 0;
            condition1.signal(); //C执行完后，唤醒A线程
        } catch (Exception e) {
            throw new RuntimeException(e);
        } finally {
            lock.unlock();
        }
    }
}
```

![image-20240327142243138](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240327142243138.png) 

## JUnit

### 为什么需要 JUnit

![image-20240312191351768](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312191351768.png) 

### 基本介绍

![image-20240312191419196](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312191419196.png) 

```java
@Test
public void m1() {
	System.out.println("m1 方法被调用");
}

@Test
public void m2() {
	System.out.println("m2 方法被调用");
}
```

## IDE（集成开发环境）—IDEA

1. IDEA 全称 IntelliJ IDEA 
2. 在业界被公认为最好的 Java 开发工具 
3. IDEA 是 JetBrains 公司的产品，总部位于捷克的首都布拉格 
4. 除了支持 Java 开发，还支持 HTML，CSS，PHP，MySQL，Python 等

![image-20240301181316349](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301181316349.png) 

**版本：**IDEA 2020.2

### IDEA 常用快捷键

1. 删除当前行：默认是Ctrl + Y，改为**Ctrl + D**（）
2. 复制当前行：（搜索duplicate），改为**Ctrl + Alt + 向下箭头**（）
3. 代码补全：**Alt + /**
4. 添加注释和取消注释： **Ctrl + /** 
5. 导入该行需要的类：**Alt+Enter** 
6. 快速格式化代码： **Ctrl + Alt + L**
7. 快速运行程序：默认是Shift + F10 ，改为**Alt + R**（）
8. 生成构造器等：**Alt + Insert**
9. 查看一个类的层级关系： **Ctrl + H**
10. 将光标放在一个方法上，输入 **Ctrl + B** （或者**Ctrl + 鼠标左键**）, 可以定位到方法 
11. **ctrl + alt + <**-- (左）；回到上一个方法；**ctrl + alt + -->** (右）；回到下一个方法。搭配上一步使用
12. **ctrl + alt + 左方向键**-- (左）；回到上一个光标；**ctrl + alt + 右方向键** (右）；回到下一个光标。搭配上一步使用
13. 自动的分配变量名 , 通过 在后面加 **.var** ；自动生成增强for循环，通过 在后面加**.for**
14. 自动的填写输出函数，通过后面加**.sout**
15. 查看快捷键的快捷键：**Ctrl + J**
16. 快速生成迭代器的while：**i t i t**
17. 增强for循环： **I（大写）**
18. 异常处理、同步代码块快捷键：**Ctrl + Alt + T**
19. **按住Alt键，然后拖动鼠标**，实现多行代码的同时修改；**Alt + Shift 点击鼠标**，实现特定位置的同时修改

### 自定义模板

![image-20240301183836222](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301183836222.png) 

### 自动添加注释

![image-20240326170931531](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240326170931531.png)

### 断点调试

**断点调试介绍：**

![image-20240303090429018](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303090429018.png) 

**断点调试的快捷键：**

**F7(跳入)** 

**F8(跳过)** 

**shift+F8(跳出)** 

**F9(resume,执行到下一个断点)**

（断点可以在 debug 过程中，动态的下断点）

### 获得CPU的内核数

~~~java
System.out.println(Runtime.getRuntime().availableProcessors());
~~~

### 获得当前系统时间

~~~java
System.currentTimeMills()
~~~

# **前端笔记**

## HTML

##### 描述：

用于定义网络结构的基本技术

##### 基本语法：

<开始标签>	内容	<结束标签>

![image-20240115105017529](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115105017529.png)

##### 标签：

+ ###### **分区div**

  div是一个纯粹的容器，<div>元素在语义上不表示任何特定类型的内容。然而，其可以将内容分组，从而可以使用**class**或是**id**属性方便的定义内容的格式。

+ ###### **标题h1~h6**

  HTML `<h1>`–`<h6>` 标题 (Heading) 元素呈现了六个不同的级别的标题，`<h1>` 级别最高，而 `<h6>` 级别最低。

+ ###### **段落p**

   **`<p>`** 元素表示文本的一个段落。段落是块级元素。

+ ###### **图像img**

  <img> 元素将一张图像嵌入文档

  ![image-20240115110304202](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115110304202.png) 

  - `src` 属性是**必须的**，它包含了你想嵌入的图片的路径。
  - `alt` 属性包含一条对图像的文本描述，这不是强制性的。如果由于某种原因无法加载图像，普通浏览器也会在页面上显示 `alt` 属性中的备用文本：例如，网络错误、内容被屏蔽或链接过期。

+ ###### **列表ul/ol**

  **`<ul>`** 元素表示一系列无序的列表项目，通常渲染为项目符号列表。

  ![image-20240115110519215](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115110519215.png) 

  **`<ol>` **元素表示有序列表，通常渲染为一个带编号的列表。

  ![image-20240115110655736](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115110655736.png) 

+ ###### **超链接a**

  <a> 元素（或称锚元素）可以通过它的 href 属性创建通向其他网页、文件、电子邮件地址、同一页面内的位置或任何其他 URL 的超链接。

  <a> 中的内容应该指明链接的目标。如果存在 href 属性，当 <a> 元素聚焦时按下回车键就会激活它。

  <a>中的href属性可以使用**文本片段**链接到某一段文字：这时点击a标签会直接跳转到相应的标签

  ![image-20240115111039304](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115111039304.png) 

+ ###### **表单form**

  **`<form>` 元素**表示文档中的一个区域，此区域包含交互控件，用于向 Web 服务器提交信息。

  ```html
  action:处理表单提交的 URL。这个值可被 <button>、<input type="submit"> 或 <input type="image"> 元素上的 formaction 属性覆盖。
  method:浏览器使用这种 HTTP 方式来提交 表单。可能的值有：
  	post：指的是 HTTP POST 方法；表单数据会包含在表单体内然后发送给服务器。
      get：指的是 HTTP GET 方法；表单数据会附加在 action 属性的 URL 中，并以 '?' 作为分隔符，没有副作用 时使用这个方法。
  <form action="" method="get" class="form-example">
    <div class="form-example">
      <label for="name">Enter your name: </label>
      <input type="text" name="name" id="name" required />
    </div>
    <div class="form-example">
      <label for="email">Enter your email: </label>
      <input type="email" name="email" id="email" required />
    </div>
    <div class="form-example">
      <input type="submit" value="Subscribe!" />
    </div>
  </form>
  ```

   ![image-20240115111322271](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115111322271.png)

+ ###### **表格table**

  **table**元素表示表格数据——即在一个由包含数据的行和列组成的二维表格中呈现的信息。

  ```html
  <table>
    <thead>
      <tr>
        <th colspan="2">The table header</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>The table body</td>
        <td>with two columns</td>
      </tr>
    </tbody>
  </table>
  ```

  ![image-20240115111909442](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115111909442.png) 

+ ###### **框架iframe**

​	**HTML 内联框架元素 (`<iframe>`)** ,它能够将另一个 HTML 页面嵌入到当前页面中。目前我还没有用到这个。

##### HTML5特性：

###### 语义化标签：

当接近要使用的标记时，问问自己，“什么元素最能描述/表示我要填充的数据？”例如，它是数据列表吗？有序或无序？是否是一篇具有章节和相关信息旁注的文章？它是否列出了定义？它是需要标题的图形还是图像？除了全局网站范围的页眉和页脚之外，它还应该有页眉和页脚吗？等等。

写语义标记的一些好处如下：

- 搜索引擎将其内容视为影响页面搜索排名的重要关键字。

- 比起搜索无休止的带有或不带有语义/命名空间类的 `div`，找到有意义的代码块显然容易得多。

- 语义命名反映了正确的自定义元素/组件命名。

- 常见的语义化元素

  ```html
  <article>
  <aside>
  <detiales>
  <figcaption>
  <figure>
  <footer>
  <header>
  <main>
  <mark>
  <nav>
  <section>
  <summary>
  <time>
  ```



## 前端基础知识

##### 互联网：

互联网（[internet](https://baike.baidu.com/item/internet/272794?fromModule=lemma_inlink)），又称国际网络，指的是[网络](https://baike.baidu.com/item/网络/143243?fromModule=lemma_inlink)与网络之间所串连成的庞大网络，这些网络以一组通用的[协议](https://baike.baidu.com/item/协议/13020269?fromModule=lemma_inlink)相连，形成逻辑上的单一巨大国际网络。

互联网始于1969年[美国](https://baike.baidu.com/item/美国/125486?fromModule=lemma_inlink)的[阿帕网](https://baike.baidu.com/item/阿帕网/1950726?fromModule=lemma_inlink)。通常[internet](https://baike.baidu.com/item/internet/272794?fromModule=lemma_inlink)泛指互联网，而Internet则特指[因特网](https://baike.baidu.com/item/因特网/114119?fromModule=lemma_inlink)。这种将[计算机网络](https://baike.baidu.com/item/计算机网络/18763?fromModule=lemma_inlink)互相联接在一起的方法可称作“网络互联”，在这基础上发展出覆盖全世界的全球性互联网络称互联网，即是互相连接一起的[网络结构](https://baike.baidu.com/item/网络结构/8259917?fromModule=lemma_inlink)。

##### 域名：

域名（英语：Domain Name），又称网域，是由一串用点分隔的名字组成的[互联网](https://baike.baidu.com/item/互联网/199186?fromModule=lemma_inlink)上某一台[计算机](https://baike.baidu.com/item/计算机/140338?fromModule=lemma_inlink)或计算机组的名称，用于在[数据传输](https://baike.baidu.com/item/数据传输/2987565?fromModule=lemma_inlink)时对计算机的定位标识（有时也指地理位置）。 [1]

由于[IP地址](https://baike.baidu.com/item/IP地址/150859?fromModule=lemma_inlink)不方便记忆并且不能显示地址组织的名称和性质，人们设计出了域名，并通过[域名系统](https://baike.baidu.com/item/域名系统/2251573?fromModule=lemma_inlink)（DNS，Domain Name System）来将域名和IP地址相互[映射](https://baike.baidu.com/item/映射/20402621?fromModule=lemma_inlink)，使人更方便地访问互联网，而不用去记住能够被机器直接读取的IP地址数串。

##### DNS：

DNS（Domain Name System）域名系统，是一个层次化、分散化的互联网连接资源命名系统。DNS 维护着一个[域名](https://developer.mozilla.org/zh-CN/docs/Glossary/Domain_name)列表以及与之相关联的资源（例如 IP 地址）。

DNS 最突出的功能是将易于记忆的域名（例如 mozilla.org）翻译成为数字化的 [IP 地址](https://developer.mozilla.org/zh-CN/docs/Glossary/IP_Address)（例如 151.106.5.172）；这一从域名到 IP 地址的映射过程被称为**DNS 查询**（DNS lookup）。与之对应，**DNS 反向查询**（rDNS）用来找到与 IP 地址对应的域名。

##### 服务器：

服务器是为用户（通常称为客户端）提供服务的软件或硬件。硬件而言的服务器是互联网上的共享计算机，通常性能强劲且位于数据中心。软件而言的服务器（一般是运行在硬件服务器上）是一种向客户端程序或向[用户界面](https://developer.mozilla.org/zh-CN/docs/Glossary/UI)提供服务的程序。

我们一般在局域网或广域网（如互联网）提供服务。传统上，客户端程序和服务器程序通过 [API](https://developer.mozilla.org/zh-CN/docs/Glossary/API) 传递信息进行连接，这种信息使用[协议](https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol)编码。

举个例子：

- 连接到互联网的 Web 服务器向你的浏览器发送一个 [HTML](https://developer.mozilla.org/zh-CN/docs/Glossary/HTML) 文件，这样你就可以浏览页面。
- 用于文件、域名、邮件、打印机和传真机的局域网服务器。
- 数据中心的小型机、大型机和超算。

##### 浏览器：

**浏览器**是一种从 [Web](https://developer.mozilla.org/zh-CN/docs/Glossary/World_Wide_Web) 获取和显示页面的程序，并且让用户通过[超链接](https://developer.mozilla.org/zh-CN/docs/Glossary/Hyperlink)访问更多页面。浏览器是最常见的一种用户代理。

###### DOM事件流：

DOM(文档对象模型)结构是一个树型结构，当一个[HTML元素](https://baike.baidu.com/item/HTML元素/5983313?fromModule=lemma_inlink)产生一个事件时，该事件会在元素节点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为DOM事件流。

DOM同时支持两种事件模型：[捕获型事件](https://baike.baidu.com/item/捕获型事件/0?fromModule=lemma_inlink)和[冒泡型事件](https://baike.baidu.com/item/冒泡型事件/7508003?fromModule=lemma_inlink)，但是，捕获型事件先发生，冒泡型事件后发生。两种事件流会触发DOM中的所有对象，从[document对象](https://baike.baidu.com/item/document对象/6553996?fromModule=lemma_inlink)开始，也在document对象结束。

![image-20240225131301937](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225131301937.png) 

###### 事件委托：

当冒泡和捕获同时存在时，事件触发顺序为：捕获->目标（small就是目标）->冒泡。事件委托，也叫事件代理，一般指的是利用事件冒泡，将一个或者一组DOM的事件处理程序，委托给其父级元素或者更外层元素。**可以通过只指定一个事件处理程序，就可以管理一批同类型的事件处理程序**。

例如：如果需要给列表项添加事件，当列表项数量过多时，会存在频繁操作DOM的情况；并且函数是引用类型, 需要堆内存来存储，占用大量空间。**通过事件委托，可以将事件绑定到其父级元素ul上，这样只需要操作一次DOM，不会引起频繁的重绘。**也不会占用大量的空间。

```html
<!-- 通过事件的具体属性实现通过事件委托也和直接绑定在li上一样的效果--><!DOCTYPE html>
<html lang="en">
<body>
  <ul id='father'>
    <li id="a">A</li>
    <li id="b">B</li>
    <li id="c">C</li>
    <li id="d">D</li>
  </ul>
  <script>
  father.addEventListener('click', function(e) {
    const event = e；
    const target = event.target；
    // 根据事件属性判断当前所在的DOM节点，不同节点处理不同的程序（主要通过e.target,在父节点上定义的事件，可以处理子节点）
    switch(target.id) {
      case "a":
        console.log('a');
        break;
      case "b":
        console.log('b');
        break;
      case "c":
        console.log("c");
        break;
      case "d":
        console.log("d");
        break;
      default:
        console.log('default');
    }
  })
  </script>
</body>
</html>
```

###### 浏览器加载顺序：

1. HTML解析完毕

2. 外部脚本和样式加载完毕

3. 脚本在文档内解析并执行

4. HTML DOM完全构造起来

5. 图片个外部内容加载

6. 网页完全加载

**1-4执行是很快的，5很慢**

###### 浏览器渲染过程：

渲染流程大致可以划分为五个过程：

1. 构建DOM

   <img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240121114811031.png" alt="image-20240121114811031" style="zoom:50%;" /> 

2. 构建CSSOM

   <img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240121114842031.png" alt="image-20240121114842031" style="zoom:50%;" /> 

3. 构建渲染（render）树

   ![image-20240121114959429](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240121114959429.png) 

4. 布局

   获取渲染树的结构，节点位置和大小，然后依据盒子模型来进行布局

5. 绘制

   把渲染树以像素的形式绘制在页面上

![image-20240121114521130](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240121114521130.png) 

**（如果构建DOM的过程中，碰见js，则下载js，如果js没有额外的设置则需要等到CSSOM构建完成后才能执行js文件，js既可以对DOM做修改，也可以对CSSOM做修改）**



##### HTTP：

HTTP（Hyper Text Transformer Protocol，超文本传输协议）是一种通信协议，它允许将超文本标记语言（HTML）文档从Web服务器传送到客户端的浏览器。

它是一个应用层协议，承载于TCP协议之上。

###### HTTP1.0

HTTP/1.0是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。默认采用短连接。

HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。这种无状态性可以借助cookie/session机制来做身份认证和状态记录。

缺点，无连接的特性导致最大的性能缺陷就是无法复用连接。每次发送请求的时候，都需要进行一次TCP的连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率非常低。

###### HTTP1.1

HTTP/1.1版本，持久连接/长连接被默认采用（默认模式使用带流水线的持久连接），并能很好地配合代理服务器工作，还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。

###### HTTP请求方法

1. GET

   请求指定的页面信息，并返回实体主体。

   注：GET也可以将数据提交到服务器，不过一般都是使用POST提交数据到服务器.

2. POST

   POST请求方法的作用：向服务器发送数据。

   POST和GET请求方法的本质区别：

   ​    1、GET用于信息获取，它是安全的（这里安全的含义是指非修改信息），而POST是用于修改服务器上资源的请求；

   ​    2、GET请求的数据会附在URL之后（然后提交到服务器），而POST把提交的数据则放置在HTTP实体的主体里，所以，POST的安全性要比GET的安全性高；

   ​    3、GET方式提交数据和POST方法提交数据并没有限制数据大小。

3. HEAD

   HEAD请求方法作用：只请求头部，允许客户端在未获取资源实体的情况下，对资源的头部检查，了解资源的基本情况，比如类型，是否被修改过等。

   HEAD和GET请求方法的区别：GET请求回来的报文有实体的主体部分，而HEAD请求回来的报文没有实体的主体部分。

###### 状态码

2xx 成功

3xx 重定向

4xx 客户端报错

5xx 服务端报错

###### Cookie

是某些网站为了辨别用户身份，进行[Session](https://baike.baidu.com/item/Session/479100?fromModule=lemma_inlink)跟踪而储存在用户本地终端上的数据（通常经过加密），由用户[客户端](https://baike.baidu.com/item/客户端/101081?fromModule=lemma_inlink)计算机暂时或永久保存的[信息](https://baike.baidu.com/item/信息/111163?fromModule=lemma_inlink) 。

###### HTTPS

HTTPS （全称：Hypertext Transfer Protocol Secure [5]），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和[身份认证](https://baike.baidu.com/item/身份认证/5294713?fromModule=lemma_inlink)保证了传输过程的安全性 。HTTPS 在HTTP 的基础下加入[SSL](https://baike.baidu.com/item/SSL/320778?fromModule=lemma_inlink)，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。

## Git

#### git基础命令笔记：

git remote -v查看配置了的远程连接的名称

git remote add origin https://github.com/RJrowlling/ExerciseProject.git 配置远程连接，连接本地仓库和远程仓库

git remote rm origin 删除配置了的远程连接



git branch 查看分支名称

git branch issue1 新建分支

git branch -d issue1 删除分支

git checkout mian 切换分支



git add README.md 将READNE.md文件添加到索引暂存区

git commit -m "将暂存区里的索引同步到本地数据库上，并设置了message"

git push origin main 将本地仓库的数据推送到远程仓库的main分支中



git revert HEAD撤消上一次提交的更改。

1. 注意这里只是从本地仓库中还原了上一次提交的更改，如果你已经push到远程仓库，则远程仓库不变，除非你再次push
2. Git revert 命令将一个提交作为参数，并**创建一个新的提交来撤消该提交所做的更改**。

#### 把本地项目上传到github上出现了问题？

![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240127160257601.png) 

![image-20240127160239654](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240127160239654.png) 

##### 1. 没有在github上面关联公钥

基础的内容已经配置好了（用户名，电子邮箱，本地钥匙都有），首先进入C:\Users\cjy\\.ssh目录文件下找到id_rsa.pub公钥，打开记事本复制内容到下图（配置好后，github会给你发电子邮件）

![image-20240127160036193](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240127160036193.png) 

##### 2.网络连接问题

ping github.com时，会显示超时，这就是网络连接问题。通过ip查询https://ipaddress.com/website/github.com找到github.com的ip地址，例如（140.82.113.4）

![image-20240127160751778](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240127160751778.png)

此时修改本地 DNS 文件 C:\Windows\System32\drivers\etc 目录下的 hosts 文件，由于该文件在 C 盘中，无法直接打开进行修改，需要使用管理员权限，此处操作方式为，搜索 记事本 软件，右键以管理员身份运行，选择上述 hosts 文件打开，在文件内容最下方加入一行

```
140.82.113.4    github.com
```

## Node.js

定义：node.js是一个开源的，跨平台的JavaScript运行环境

安装：https://blog.csdn.net/zxy15974062965/article/details/121117803

### 包管理工具

包：package，代表了一组功能的源码集合

包管理工具：管理【包】的应用软件，进行下载安装、更新、删除操作

#### npm

npm全称node package Manage【node的包管理工具】

npm是node.js官方**内置的**包管理工具

##### npm 全局安装 ：

```
npm i -g <包名>

npm root -g
```

全局安装的命令不受工作目录位置的影响，**而且安装的位置不是在当前工作目录的node_module，而是在全局安装包的位置**，可以通过**npm root -g** 可以查看全局安装包的位置；而且并不是所有包都适合全局安装。

##### **windows会对全局安装的脚本进行约束，不让它运行？**

可以通过修改windows的执行策略来解决这个问题，具体：输入：set-ExecutionPolicy remoteSigned

![image-20240201094202340](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240201094202340.png)

##### **npm 安装所有依赖**：

```
npm i
npm install
```

通过该命令可以依据package.json和package-lock.json的依赖声明，安装项目所有依赖（**node-modules文件夹大多数情况是不会存入版本库的**），只有安装完所有依赖才能够正常启动项目

##### 安装指定版本的包：

```
npm i <包名@版本号>
例子：
npm i jquery@1.11.2
```

##### 删除依赖：

```
局部删除：
npm remove unip
全局删除：
npm remove -g nodemon
```

##### npm 配置命名别名：

可以通过命名别名可以更简单的执行命令，具体来说，配置package.json中的scripts属性

![image-20240201100222985](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240201100222985.png)

##### cnpm：

cnpm是淘宝构建的npmjs.com的完整镜像，也称为**淘宝镜像**，cnpm服务部署在国内阿里云服务器上，可以提高包的下载速度。

**淘宝镜像源官网：**https://www.npmmirror.com/，这里可以获得第一手的镜像网站

**官方也提供了一个全局工具包cnpm**（不是内置的），操作命令与npm大体相同。

**安装cnpm：**

```
npm install -g cnpm --registry=https://registry.npmmirror.com
```

##### npm配置淘宝镜像：

npm 也可以使用淘宝镜像源，直接配置：



```
 npm config set registry https://registry.npmmirror.com

在配置之前，先 npm config list查看，并保存一下原来的registry，方便后面改回来
"https://registry.npmjs.org/"这是npm原有的数源
```

**使用了淘宝镜像源之后，就不要搭梯子了，关掉梯子，yarn才能正常运行。**

#### Yarn

介绍：yarn是由Facebook推出的JavaScript包管理工具

特点：速度超快，会缓存包，所以下次下载无需重复下载。并行下载

安装：

```
npm i -g yarn
```

##### yarn常用命令

![image-20240201103854636](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240201103854636.png)

##### yarn全局安装

查询 yarn 安装依赖的全局路径 

```
yarn global bin
```

修改 yarn 全局 bin 位置 ，这个就是yarn之后安装全局依赖的位置，**但是注意，要修改环境变量，才能使yarn全局安装的包正常运行**

```
yarn config set prefix "D:\nodejs\node_modules\yarn\bin"
```

##### yarn配置淘宝镜像

```
yarn config set registry https://registry.npmmirror.com

在配置之前，先 yarn config list查看，并保存一下原来的registry，方便后面改回来
```

**使用了淘宝镜像源之后，就不要搭梯子了，关掉梯子，yarn才能正常运行。**

## React



## VScode使用

##### VScode怎么运行js文件？

+ **使用内置终端**

  首先，我们需要打开一个JS文件，然后按下“Ctrl+Shift+`”键，打开终端界面，可以在其中输入“**node 文件名.js**”命令来运行JS文件。

+ **使用Code Runner插件**

​	安装Code Runner插件，打开一个JS文件，然后按下**“Ctrl+Alt+N”键**，Code Runner会自动运行当前打开的JS文件，并在底部显示输出结果。

+ **使用Live Server插件**

​	在VSCode中安装Live Server插件，打开一个HTML文件，然后按下**“Alt+L”键**，此时，Live Server会自动启动一个本地服务器，并在浏览器中打开我们的HTML文件。如果HTML文件中引用了JS文件，Live Server也会自动运行这些JS文件。

##### VScode怎样调试js文件？

1. 首先要加断点

   ![image-20240117163505090](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117163505090.png) 

2. 点击JavaScript调试终端

   ![image-20240117163526777](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117163526777.png) 

3. 在终端里面输入node 文件名.js，回车

​	![image-20240117163613470](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117163613470.png) 

4. 在左侧进行调试

​	<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117163831404.png" alt="image-20240117163831404" style="zoom:50%;" /> 

# 博客笔记

为了以后的深入学习，一定要培养自己看文档的习惯。为了能够使自己适应看文档的习惯，现在强制自己在每看完一篇文章后输出一篇博客，并发布到博客平台。



## Java核心技术卷

主要是写一些对于Java核心技术卷的观后感或笔记，然后发布到知识星球上面，强制自己适应对于文字的阅读，为以后的阅读文档打下良好的基础。

标题：**Java核心技术卷读书笔记：第一章 Java 程序设计概述**

### 01：Java 程序设计概述

Java的第一次发布就引起了人们的极大兴趣，Java 是一种功能齐全的出色语言，是一个高质量的执行环境， 还提供了一个庞大的库。正是因 为它集多种优势于一身，所以对广大的程序设计人员有着不可抗拒的吸引力。

**Java白皮书有11 个关键术语：**

1 ) 简单性 2 ) 面向对象 3 ) 分布式 4 ) 健壮性 5 ) 安全性 7 ) 可移植性 8 ) 解释型 9 ) 高性能 10 ) 多线程 11 ) 动态性 6 ) 体系结构中立

1. 简单性：Java 语法是 C++ 语法的一个“ 纯净” 版本，这里没有头文件、 指针运算、结构、 联合、 操作符重载、 虚基类等。简单的另一个方面是小，现在有 一个独立的具有较小类库的 Java 微型版。
2. 面向对象：开发 Java 时面向对象技术已经相当成熟。 Java 的面向对象特性与 C++ 旗鼓相当。Java 与 C++ 的主要不同点在于多重继承，在 Java 中，取而代之的是更简单的接口概念。
3. 分布式：Java 有一个丰富的例程库，用于处理像 HTTP 和 FIT 之类的 TCP/IP 协议。
4. 健壮性：Java 编译器能够检测许多在其他语言中仅在运行时才能够检测出来的问题。
5. 安全性：从一开始，Java 就设计成能够防范各种攻击，不过，Java 的安全模型很复杂。遭遇多次高调攻击之后， 浏览器开发商和 Oracle 都越来越谨慎 。现在看来， 尽管 Java 安全模型没有原先预想的那么成功， 但 Java 在那个时代确 实相当超前。
6. 体系结构中立：编译器生成一个体系结构中立的目标文件格式，这是一种编译过的代码， 只要有 Java 运行时系统， 这些编译后的代码可以在许多处理器上运行。
7. 可移植性：在 Java 中，数据类型具有固定的大小， 这消除了代码移植时令 人头痛的主要问题。
8. 解释性：Java 解释器可以在任何移植了解释器的机器上执行 Java 字节码
9. 高性能：尽管对解释后的字节码性能已经比较满意，但在有些场合下还需要更加高效的 性能。字节码可以（在运行时刻）动态地翻译成对应运行这个应用的特定 CPU 的机 器码。即时编译器可以监控经常执行哪 些代码并优化这些代码以提高速度。
10. 多线程：多线程可以带来更好的交互响应和实时行为。Java 在当时很超前，它是第一个支持并发程序设计的主流语言。
11. 动态性：从各种角度看， Java 与 C 或 C++ 相比更加具有动态性。它能够适应不断发展 的环境。例如：在 Java 中找出运行时类型信息十分简单

**Java发展简史：**

Java 的历史要追溯到 1991 年，由 Patrick Naughton 和 James Gosling Sun 带领的Sun公司的工程师小组想要设计一种小型的计算机语言， 这个项目被命名为“ Green”。这个“ Green”项目代码短小、 紧凑且与平台无关， 这些要求促使开发团队设计一个可移植的语言， 可以为 虚拟机生成中间代码。Gosling 把这种语言称为“ Oak ”，后来发现 Oak 是一种已有的计算机语言的 名字，于是， 将其改名为 Java。

1996 年年初，Sun 发布了 Java 的第 1 个版本。人们很快地意识到 Java1.0 不能用来进行 真正的应用开发。后 来的 Java 1.1弥补了其中的大多明显的缺陷 。 大大改进了反射能力，并为 GUI 编程增加了新 的事件处理模型：不过它仍然具有很大的局限性。

1998 年 JavaOne 会议的头号新闻是即将发布 Java 1.2 版。这个版本取代了早期玩具式的 GUI, 并且它的图形T.具箱更加精细而具有可伸缩性，更加接近“ 一次编写， 随处运行” 的 承诺。除了‘ 标准版’ 之外，Sun 还推出了两个其他的版本：一个是用于手机等嵌人式设备的‘ 微 型版”；另一个是用于服务器端处理的“ 企业版”。

标准版的 1.3 和 1.4 版本对最初的 Java 2 版本做出了某些改进， 扩展了标准类库，提高 系统性能。

5.0 版是自 1.1 版以来第一个对 Java 语言做出重大改进的版本（这一版本原来被命名为 1.5 版，在 2004 年的 JavaOne 会议之后，版本数字升至 5.0 )。

版本 6 ( 没有后缀 .0 ) 于 2006 年年末发布。 同样，这个版本没有对语言方面再进行改进。 但是，改进了其他性能，并增强了类库。

Sun Microsystems 公司沦陷， 于 2009 年被 Oracle 收购 _ Java 的开发停滞了很长一段时间。

2011年 Oracle 发布了 Java 的一个新版本，Java 7, 其中只做了一些简单的改进。

2014 年 ,Java 8终于发布，在近 20 年中这个版本有了最大的改变。Java 8 提供了一种“ 函数式” 编程方式，可以很容易地表述并发执行的计算。 所有编程语言都必须与时俱进，Java 在这方面显示出非凡的能力

![image-20240317210923604](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240317210923604.png) 

**关 于 Java 的常见误解：**

Java 是 HTML 的扩展：两者没有任何共同之处

Java 是一种非常容易学习的程序设计语言：像 Java 这种功能强大的语言大都不太容易学习。

Java 是解释型的， 因此对于关键的应用程序速度太慢了：早期的 Java 是解释型的。 现在 Java 虚拟机使用了即时编译器， 因此采用 Java 编写的 “ 热点” 代码其运行速度与 C++ 相差无几， 有些情况下甚至更快。

JavaScript 是 Java 的简易版：JavaScript 的语法类似 Java, 除此之外，两者无任何关系。

Java 只不过是另外一种程序设计语言：Java 是一种很好的程序设计语言，程序设计语言的成功更多地取决于其支撑系统的能力， 而不是优美的语 法。Java 的成功源于其类库能够让人们轻松地完成原本有一定难度的事情。

Java 将成为适用于所有平台的通用性编程语言：从理论上讲， 这是完全有可能的。 但在实际中， 某些领域其他语言有更出色的表现。

### 03：Java 的程序设计结构

本章主要介绍程序设计的基本概念（如数据类型、分支以 及循环）在 Java 中的实现方式。

**一个简单的 Java 应用程序：**

public class FirstSample { 

​	public static void main(String[] args) { 

​		System.out.println("We will not use 'Hello, World!"'); 

​	} 

} 

1. 首先，Java 区分大小写。 如果出现了大小写拼写错误（例如， 将 main 拼写成 Main), 程序将无法运行

2. 关键字 public 称为访问修饰符（access modifier), 这 些修饰符用于控制程序的其他部分对这段代码的访问级別
3. 关键字 class 表明 Java 程序中的全部内容都包含在类中，Java 应用程序中的全部内容都必须放置在类中
4. 关键字 class 后面紧跟类名。 Java 中定义类名的名字必须以字母开头，后面可以跟字母和数字的任意组合，但是不能使用 Java 保留字
5. 标准的类命名规范为（FirstSample）大驼峰：类名是以大写字母开头的名 词，如果名字由多个单词组成，每个单词的第一个字母都应该大写
6. 源代码的文件名必须与公共类的名字相同，并用 .java 作为扩展名
7. 在编译这段源代 码之后就会得到一个包含这个类字节码的文件，Java 编译器将字节码文件自动地命名为 FirstSample. class, 并与源文件存储在同一个目录下
8. 每个 Java 应用程序都 必须有一个 main 方法
9. 在 Java 中，每个句子必须用分号结束。 特别需要说明，回车不是语句的结束标志
10. 在这里，使用了 System.out 对象并调用了它的 println 方法。注意， 点号（ • ）用于调用 方法

**注 释：**

Java 中的注释不会出现在可执行程序中。因此， 可以在 源程序中根据需要添加任意多的注释，而不必担心可执行代码会膨胀。在 Java 中，有 3 种标 记注释的方式。

1. 最常用的方式是使用 //，其注释内容从 // 开始到本行结尾。
2. 当需要长篇的注释时， 既可以在每行的注释前面标记 //，也可以使用 /* 和 */ 将一段比较 长的注释括起来。
3. 第 3 种注释可以用来自动地生成文档。这种注释以 / ** 开始， 以 */ 结束

在 Java 中，/* **/ 注释不能嵌套 „ 也就是说， 不能简单地把代码用 /* *和 */ 括起来 作为注释， 因为这段代码本身可能也包含一个 */ 

**数 据 类 型:**

Java 是 -种强类型语言。这就意味着必须为每一个变量声明一种类型。在 Java 中， -共有 8 种基本类型（ primitive type ), 其中有 4 种整型、2 种浮点类型、 1 种用于表字符类型 char  和 1 种用于表示真值的 boolean 类型。

1. 整型
   1. byte型，1字节，
   2. short型，2字节
   3. int型，4字节
   4. long型，8字节，长整型数值有一个后缀 L 或 1 ( 如 4000000000L。)

​	注意， Java 没有任何无符号（unsigned) 形式的 int、 long、short 或 byte 类型。

2. 浮点类型

   1. float类型，4字节，float 类型的数值有一个后缀 F 或 f (例如，3.14F）
   2. double类型，8字节，没有后缀 F 的浮点数值（如 3.14 ) 默 认为 double 类型。

   下面是用于表示溢出和出错情况 的三个特殊的浮点数值：

   •正无穷大 ，常量 Double_POSITIVE_INFINITY

   •负无穷大，Double.NEGATIVEJNFINITY

    •NaN (不是一个数字），Double.NaN，特别要说明的是， 不能这样检测一个特定值是否等于 Double.NaN：
   	if (x = Double.NaN) // is never true 所有“ 非数值” 的值都认为是不相同的，然而，可以使用 Double.isNaN 方法：

   ​	if (Double.isNaN(x)) // check whether x is "not a number"

   注意： 浮点数值不适用于无法接受舍入误差的金融计算中。 例如，命令 System.out.println ( 2.0-1.1 ) 将打印出 0.8999999999999999, 而不是人们想象的 0.9。这种舍入误差的主要 原因是浮点数值采用二进制系统表示， 而在二进制系统中无法精确地表示分数 1/10。

3. char 类型

   char 类型原本用于表示单个字符，如今，有些 Unicode 字符可以用一个 char值描述，另外一些 Unicode 字符则需要两个 char 值。char 类型的字面量值要用单引号括起来。例如：‘A’ 是编码值为 65 所对应的字符常量。它与 "A" 不同，"A" 是包含一个字符 A 的字符串。

   char 类型的值可以表示为十六进制值，其 范围从 \u0000 到 \Uffff。例如：\u03C0 表示希腊字母 π。除了转义序列 \u 之外， 还有一些用于表示特殊字符的转义序列，\b 退格，\n 换行（\u00A0），\t 制表（对应\u0009）。更隐秘地， 一定要当心注释中的 \u。注释 // \u00A0 is a newline。会产生一个语法错误， 因为读程序时 \u00A0 会替换为一个换行符。

4. boolean 类型

   boolean (布尔）类型有两个值：false 和 true, 用来判定逻辑条件 整型值和布尔值之间 不能进行相互转换

**变 量：**

1. 在 Java 中，每个变量都有一个类型（ type)。在声明变量时，变量的类型位于变量名之 前。
   double salary;

2. 尽管 $ 是一个合法的 Java 字符， 但不要在你自己的代码中使用这个字符。它只用 在 Java 编译器或其他工具生成的名字中。

3. 声明一个变量之后，必须用赋值语句对变量进行显式初始化， 千万不要使用未初始化的 变量。要想对一个已经声明过的变量进行赋值， 就需要将变量名放在等号（=) 左侧， 相应取值 的 Java 表达式放在等号的右侧。
   int vacationDays; 
   vacationDays=12;

4. 在 Java 中， 变量的声明尽可能地靠近变量第一次使用的地方， 这是一种良好的程序编写 风格

5. 在 Java 中， 利用关键字 final 指示常量。final double CM_PER_INCH = 2.54;关键字 final 表示这个变量只能被赋值一次。一旦被赋值之后，就不能够再更改了。习惯上, 常量名使用全大写。

**运 算 符：**

在 Java 中，使用算术运算符 + 、-、 * 、/ 表示加、减、 乘、除运算。 

1. 当参与 / 运算的两个 操作数都是整数时， 表示整数除法；否则， 表示浮点除法。

2. 整数的求余操作（有时称为取模) 用 ％ 表示。例如，15/2 等于 7 ，15%2 等于 1 , 15.0/2 等于 7.50

3. 在 Math类中，包含了各种各样的数学函数。println 方法和 sqrt 方法存在微小的差异。println 方法处理 System.out 对象。但是， Math 类中的 sqrt 方法处理的不是对象，这样的方法被称为静态方法。Java 还提供了两个用于表示 TC 和 e 常量的近似值Math.PI Math.E

4. 自动类型转换：
   byte ——short——int——long ——float——double
   char——int——long——float——double

5. 强制类型转换：

   在必要的时候， int 类型的值将会自动地转换为 double 类型。但另 一方面，有时也需要将 double 转换成 int。 在 Java 中， 允许进行这种数值之间的类型转换。 当然， 有可能会丢失一些信息。在这种情况下，需要通过强制类型转换（ cast) 实现这个操 作。double x = 9.997;
   int nx = (int) x;
   这样， 变量 nx 的值为 9。强制类型转换通过截断小数部分将浮点值转换为整型。

6. 如果想对浮点数进行舍人运算， 以便得到最接近的整数（在很多情况下， 这种操作更有 用，) 那就需要使用 Math_ round 方法double x z 9.997; 
   int nx = (int) Math.round(x);
   现在， 变量 nx 的值为 10。 当调用 round 的时候， 仍然需要使用强制类型转换（ int) 其原因 是 round 方法返回的结果为 long 类型

7. X += 4; 等价于： x = x + 4;
   如果 X 是一个 int, 则以下语句 x += 3.5; 是合法的， 将把 X 设置为（int)(x + 3.5）。

8. n++ 将变量 n 的当前值加 1, n-- 则将 n 的值减 1
   上面介绍的是运算符放在操作数后面的“ 后缀” 形式。 还有一种“ 前缀” 形式：++n。后缀和前缀形式都会使变量值加 1 或减 1。但用在表达式中时， 二者就有区别了。前缀形式会先完成加 1; 而后缀形式会使用变量原来的值。

9. && 和丨| 运算符是按照“ 短路” 方 式来求值的： 如果第一个操作数已经能够确定表达式的值，第二个操作数就不必计算了。
   & 和丨运算符也会得到一个布尔值。这些运算符与 && 和丨丨运 算符很类似，不过 & 和丨运算符不采用“ 短路” 方式来求值， 也就是说，得到计算结果之前两个操作数都需要计算。

10. Java 支持三元操作符？：，这个操作符有时很有用。如果条件为 true, 下面的 表达式 condition ? expressioni : expression

11. 自定义枚举类型。枚举类型包括有限个命名的值，enum  Size { SMALL, MEDIUM, LARGE, EXTRA.LARCE };现在，可以声明这种类型的变量： Size s = Size.MEDIUM

**字 符 串:**

1. Java 没有内置的字符串类型， 而是在标准 Java 类库中提供了 一个预定义类，很自然地叫做 String。每个用双引号括起来的字符串都是 String类的一个实 例

2. String 类的 substring 方法可以从一个较大的字符串提取出一个子串。
   String greeting = "Hello"; 
   String s = greeting.substring（0, 3);创建了一个由字符“ Hel” 组成的字符串。

3. Java语言允许使用 + 号连接（拼接）两个字符串。当将一个字符串与一个非字符串的值进行拼接时，后者被转换成字符串

4. String 类没有提供用于修改字符串的方法，由于不能修改 Java 字符串中的字符， 所以在 Java 文档中将 String 类对象称为不可变字 符串， 如同数字 3 永远是数字 3 —样。不可变字符串却有一个优点：编译器可以让字符串共享。总而言之，Java 的设计者认为共享带来的高效率远远胜过于提取、 拼接字符串所带来的 低效率。

5. 可以使用 equals 方法检测两个字符串是否相等，要想检测两个字符串是否相等，而不区分大小写， 可以使用 equalsIgnoreCase 方法。一定不要使用==运算符检测两个字符串是否相等！ 这个运算符只能够确定两个字串 是否放置在同一个位置上。
   当然， 如果字符串放置在同一个位置上， 它们必然相等。但是， 完全有可能将内容相同的多个字符串的拷贝放置在不同的位置上
   String greeting = "Hello"; //initialize greeting to a string 
   if (greeting == "Hello") . // probably true 
   if (greeting.substring(0, 3) == "HeV") . . . // probably false

6. 空串 "" 是长度为 0 的字符串。空串是一个 Java 对象， 有自己的串长度（ 0 ) 和内容（空）。不过， String 变量还可以存 放一个特殊的值， 名为 null, 这表示目前没有任何对象与该变量关联

7. 调用 s.charAt(n) 将返回位置 n 的代码单元，n 介于 0 ~ s.length()-l 之间。

**输入输出:**

1. 打印输出到“ 标准输出流”（即控制台窗口）是一件非常容易的事情，只要 调用 System.out.println 即可。然而，读取“ 标准输人流” System.in 就没有那么简单了。要想通 过控制台进行输人，首先需要构造一个 Scanner 对象，并与“ 标准输人流” System.in 关联。Scanner in = new Scanner(System.in);

2. 现在，就可以使用 Scanner 类的各种方法实现输入操作了。String name = in.nextLine();
   要想读取一个整数， 就调用 nextlnt 方法。要想读取下一个浮点数， 就调用 nextDouble 方法

3. 可以使用 SyStem.0ut.print(x) 将数值 x 输出到控制台上。这条命令将以 x 对应的数据类型 所允许的最大非 0 数字位数打印输出 X。在 printf中，可以使用多个参数， 例如： 
   System.out.printf("Hello, %s. Next year, you'll be SSd", name, age)

4. 每一个以 ％ 字符开始的格式说明符都用相应的参数替换。 格式说明符尾部的转换符将指示被 格式化的数值类型：f 表示浮点数，s 表示字符串，d 表示十进制整数。

5. 可以使用静态的 String.format 方法创建一个格式化的字符串， 而不打印输出： 
   String message = String.format("Hello, %s. Next year, you'll be %d", name , age);

6. 要想对文件进行读取，就需要一个用 File 对象构造一个 Scanner 对象
   Scanner in = new Scanner(Paths.get("niyflle.txt"), "UTF-8")

**控 制 流 程：**

与任何程序设计语言一样， Java 使用条件语句和循环结构确定控制流程

1. 块（即复合语句）是指由一对大括号括起来的若干条简单的 Java 语句。块确定了变量的作 用域。一个块可以嵌套在另一个块中。

2. 在 Java 中，条件语句的格式为if (condition) statement。这里的条件必须用括号括起来。

3. 当条件为 true 时，while 循环执行一条语句（也可以是一个语句块）。一般格式为
   while { condition ) statement
   如果开始循环条件的值就为 false, 则 while 循环体一次也不执行 。

4. 如果希望 循环体至少执行一次， 则应该将检测条件放在最后。 使用 do/while 循环语句可以实现这种操 作方式。它的语法格式为： do statement while { condition);

5. for 循环语句是支持迭代的一种通用结构， 利用每次迭代之后更新的计数器或类似的变量 来控制迭代次数。
   for (int i = 1; i <= 10; i++) 
   System.out.println(i);
   特别指出，如果在 for 语句内部定义一个变量， 这个变量就不能在循环体之外使用。

6. 在处理多个选项时， 使用 if/else 结构显得有些笨拙。 Java 有一个与 C/C++ 完全一样的 switch 语句。switch语句将从与选项值相匹配的 case 标签处开始执行直到遇到 break 语句，或者执行到 switch i吾句的结束处为止。如果没有相匹配的 case 标签， 而有 default 子句， 就执行这个子句。
   有可能触发多个 case 分支。 如果在 case 分支语句的末尾没有 break 语句， 那么就 会接着执行下一个 case 分支语句。这种情况相当危险， 常常会引发错误。 

7. Java 还提供了一种带标签的 break语句，用于跳出多重嵌套的循环语句。可以将标签应用到任何语句中， 甚至可以应用到 if语句或者块语句中
   最后，还有一个 continue 语句。与 break 语句一样， 它将中断正常的控制流程。continue 语句将控制转移到最内层循环的首部。

**大 数 值：**

如果基本的整数和浮点数精度不能够满足需求， 那么可以使用java.math 包中的两个 很有用的类：Biglnteger 和 BigDecimal，这两个类可以处理包含任意长度数字序列的数值。 Biglnteger 类实现了任意精度的整数运算， BigDecimal 实现了任意精度的浮点数运算。

使用静态的 valueOf方法可以将普通的数值转换为大数值： Biglnteger a = Biglnteger.valueOf(100);

遗憾的是，不能使用人们熟悉的算术运算符（如：+ 和 *) 处理大数值。 而需要使用大数 值类中的 add 和 multiply 方法

**数 组：**

数组是一种数据结构， 用来存储同一类型值的集合。通过一个整型下标可以访问数组中 的每一个值。例如， 如果 a 是一个整型数组， a[i] 就是数组中下标为 i 的整数。

1. 在声明数组变量时， 需要指出数组类型 （ 数据元素类型紧跟 []) 和数组变量的名字。下 面声明了整型数组 a: 	
   int[] a;
   不过， 这条语句只声明了变量 a， 并没有将 a 初始化为一个真正的数组。应该使用 new 运算 符创建数组	
   int[] a = new int[100];

2. 创建一个数字数组时， 所有元素都初始化为 0。boolean 数组的元素会初始化为 false。 对 象数组的元素则初始化为一个特殊值 null, 这表示这些元素（还）未存放任何对象。

3. 要想获得数组中的元素个数，可以使用 array.length。一旦创建了数组， 就不能再改变它的大小（尽管可以改变每一个数组元素）。如果经常需 要在运行过程中扩展数组的大小， 就应该使用另一种数据结构—数组列表

4. Java 有一种功能很强的循环结构， 可以用来依次处理数组中的每个元素（其他类型的元 素集合亦可）而不必为指定下标值而分心。这种增强的 for 循环的语句格式为：
   for (variable : collection) statement
   定义一个变量用于暂存集合中的每一个元素， 并执行相应的语句（当然，也可以是语句块)。 collection 这一集合表达式必须是一个数组或者是一个实现了 Iterable 接口的类对象（例如 ArrayList)。
   for each 循环语句显得更加简洁、 更不易出错,不必为下标的起始值和终止值而操心。

5. 有个更加简单的方式打印数组中的所有值， 即利用 Arrays 类的 toString 方法。 调 用 Arrays.toString(a), 返回一个包含数组元素的字符串，这些元素被放置在括号内， 并 用逗号分隔， 例如，“ [2,3,5,7，11，13] ”

6. 在 Java中， 提供了一种创建数组对象并同时赋予初始值的简化书写形式
   int[] small Primes = { 2, 3, 5, 7, 11, 13 };
   这种表示法将创建一个新数组并利用括号中提供的值进行初始化，数组的大小就是初始值的 个数

7. 在 Java 中，允许将一个数组变量拷贝给 另一个数组变量。这时， 两个变量将引用同 一个数组。如果希望将 一个数组的所有值拷贝到一个新的数组中去， 就要使用 Arrays 类的 copyOf方法

8. 每一个 Java 应用程序都有一个带 String arg[]，参数的 main 方法。这个参数表明 main 方法将接收一个字符串数组， 也就是命令行参数
   public static void main(String[] args)
   如果使用下面这种形式运行这个程序： java Message -g cruel world

9. 要想对数值型数组进行排序， 可以使用 Arrays 类中的 sort 方法
   int[] a = new int[10000]; 
   Arrays.sort(a)这个方法使用了优化的快速排序算法。快速排序算法对于大多数数据集合来说都是效率比较 高的

10. 多维数组将使用多个下标访问数组元素， 它适用于表示表格或更加复杂的排列形式。Java 实际上没有多维数组，只有一维 数组。多维数组被解释为“ 数组的数组。”

### 04：对 象 与 类

面向 对象程序设计与面向过程程序设计在思维方式上存在着很大的差别,面向对象程序设计（简称 OOP) 是当今主流的程序设计范型，Java 是完全面向对象的.

**面向对象程序设计概述:**

面向对象的程序是由对象组成的， 每个对象包含对用户公开的特定功能部分和隐藏的实现部分。面向对象更加适用于解决规模较大的问题.

1. 类（ class) 是构造对象的模板或蓝图。由类构造（construct) 对象的过程称为创建类的实例 （instance )

2. 封装 是与对象有关的一个重要概念。从形式上看， 封装是将数据和行为组合在一个包中， 并对对象的使用者隐藏了数据的实现方式,封装给对象赋予了“ 黑盒” 特征， 这是提高重用性和可靠性 的关键。
   对象 中的数据称为成员变量（ instance field ), 操纵数据的过程称为方法（ method 。) 对于每个特定的 类实例（对象）都有一组特定的成员变量值。这些值的集合就是这个对象的当前状态（ state )。
3. 通过扩展一个类来建立另外一个 类的过程称为继承（inheritance)，在扩展一个已有的类时， 这个扩展后的新类具有所扩展的类的全部属性和方法。在新类 中，只需提供适用于这个新类的新方法和数据域就可以了。
4. 对象的三个主要特性：
   1. 对象的行为（behavior) —可以对对象施加哪些操作，或可以对对象施加哪些方法？
   2. 对象的状态（state ) —当施加那些方法时，对象如何响应？
   3. 对象标识（identity ) —如何辨别具有相同行为与状态的不同对象？
5. 识别类的简单规则是在分析问题的过程中寻找名词，而方法对应着动词。
6. 在类之间， 最常见的关系有：依赖、聚合、继承。
   依赖（ dependence ), 即“ uses-a” 关系， 是一种最明显的、 最常见的关系。例如，Order 类使用 Account 类是因为 Order 对象需要访问 Account 对象查看信用状态。应该尽可能地将相互依赖的类减至最少，用软件工程的术语来说，就是 让类之间的耦合度最小。
   聚合（aggregation ), 即“ has-a ” 关系， 是一种具体且易于理解的关系。例如， 一个 Order 对象包含一些 Item 对象。聚合关系意味着类 A 的对象包含类 B 的对象。
   继承（ inheritance ), 即“ is-a” 关系， 是一种用于表示特殊与一般关系的。例如，Rush Order类由 Order 类继承而来，Rush Order类具有Order类的一些属性和方法。

**类：**

1. 在 Java 中， 没有类就无法做任何事情，然而，并不是所有 的类都具有面向对象特征。例如：Math 类只封装了功能，它不需要也不 必隐藏数据。由于没有数据，因此也不必担心生成对象以及初始化成员变量。

2. 要想使用对象，就必须首先构造对象， 并指定其初始状态，构造器是一种特殊的方法， 用来构造并初始化对象。构造器的名字应该与类名相同，要想构造一个 Date 对 象， 需要在构造器前面加上 new 操作符。
   new Date()
   构造器与类同名 、每个类可以有一个以上的构造器 、构造器可以有 0 个、1 个或多个参数 、构造器没有返回值 、构造器总是伴随着 new 操作一起调用

3. 对象与对象变量之间存在着一个重要的区别，定义了一个对象变量 deadline, 它 可 以 引 用 Date 类型的对象。但是，一定要认识到： 变量 deadline 不是一个对象， 实际上也没有引用对象。此时，不能将任何 Date 方法应用于这个变 量上。
   Date deadline;
   s = deadline.toString（）; // not yet
   必须首先初始化变量 deadline，deadline = new Date();一定要认识到，一个对象变量并没有实际包含一个对象，而仅仅引用一个对象。
4. raiseSalary 方法有两个参数。 第一个参数称为隐式 参数， 是出现在方法名前的 Employee 类对象。第二个参数位于方法名后面括号中的数值，这是一个显式 参 数 
   number007. raiseSalary(5);
5. 私有方法，在实现一个类时，由于公有数据非常危险， 所以应该将所有的数据域都设置为私有的。然 而，方法又应该如何设计呢？尽管绝大多数方法都被设计为公有的，但在某些特殊情况下，也 可能将它们设计为私有的。然而，只要方法是 私有的，类的设计者就可以确信：它不会被外部的其他类操作调用，可以将其删去。如果方 法是公有的， 就不能将其删去，因为其他的代码很可能依赖它
6. final 成员变量，可以将成员变量定义为 final。 构建对象时必须初始化这样的域。也就是说， 必须确保在每 一个构造器执行之后，这个域的值被设置， 并且在后面的操作中， 不能够再对它进行修改。

7. 静态变量，如果将域定义为 static, 每个类中只有一个这样的域。而每一个对象对于所有的实例域 却都有自己的一份拷贝。
   静态变量使用得比较少，但静态常量却使用得比较多。在 Math 类中定义了一个 静态常量：Math.Pi。
   静态方法是一种不能向对象施加操作的方法，例如， Math 类的 pow 方法就是一个静态 方法。静态方法不能访问实例域， 因为它不能操作实例对象。但是，静态方法可 以操作自身类中的静态域。当然，也可以使用对象调用静态方法，不过，这种方式很容易造成混淆，其原因 是静态 方法计算的结果与 实例对象 毫无关系。

8. main 方法不对任何对象进行操作。事实上，在启动程序时还没有任何一个对象。静态的 main 方法将执行并创建程序所需要的对象。

**方法参数：**

按 值调用 （call by value) 表示方法接收的是调用者提供的值。而按引用调用 （ call by reference) 表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而 不能修改传递值调用所对应的变量值

方法参数共有两种类型：基本数据类型（数字、布尔值）、对象引用。一个方法不可能修改一个基本数据类型的参数，而对象引用作为参数就不同了，对象引用及其他的拷贝是同时引用同一个对象。

**对 象 构 造：**

1. 重载，有些类有多个构造器，这种特征叫做重载（ overloading）。 如果多个方法（比如， StringBuilder 构造器方法）有 相同的名字、 不同的参数，便产生了重载。Java 允许重载任何方法， 而不只是构造器方法。
   重载解析：这个过程是如 果编译器找不到匹配的参数， 就会产生编译时错误，因为根本不存在匹配， 或者没有一个比 其他的更好。

2. 默认初始化，如果在构造器中没有显式地给域赋予初值，那么就会被自动地赋为默认值： 数值为 0、 布尔值为 false、 对象引用为 null。同数组。

3. 无参数的构造器，很多类都包含一个无参数的构造函数，对象由无参数构造函数创建时， 其状态会设置为 适当的默认值。如果在编写一个类时没有编写构造器， 那么系统就会提供一个默认的无参数构造器。这个构造 器将所有的实例域设置为默认值。如果类中提供了至少一个构造器， 那么就会重载默认的无参构造器。
   仅当类没有提供任何构造器的时候， 系统才会提供一个默认的构造器

4. 显式初始化，可以在类定义中， 直接将一个值赋给任何属性，在执行构造器之前，先执行赋值操作。

5. 如果构造器的第一个语句形如 this(...)， 这个构造器将调用同一个类的另一个构造器。
   public Employee(double s) {

   ​	this("Employee #" + nextld, s);
   ​	nextld++;

   }

6. 初始化块，在一个类的声明中， 可以包含多个代码块，只要构造类的对象，这些块就会被执行。
   无论使用哪个构造器构造对象，首 先运行初始化块，然后才运行构造器的主体部分。这种机制不是必需的，也不常见。通常会直接将初始化代码放在构造器中

7. 静态的初始化块，将代码放在一个块中，并标记关键字 static。在类第一次加载的时候， 将会进行静态域的初始化。

8. 调 用构造器的具体处理步骤：

   1. 所有属性被默认初始化为默认值（0、false 或 null）。
   2. 按照在类声明中出现的次序， 依次执行初始化块。
   3. 如果构造器第一行调用了第二个构造器，则执行第二个构造器主体
   4. 执行这个构造器的主体

**包：**

Java 允许使用包（ package ） 将类组织起来。借助于包可以方便地组织自己的代码，并将 自己的代码与别人提供的代码库分开管理。使用包的主要原因是确保类名的唯一性。

1. 一个类可以使用所属包中的所有类， 以及其他包中的公有类（ public class）。
2. 要想将一个类放人包中， 就必须将包的名字放在源文件的开头，包中定义类的代码之 前。
   package com.horstiann.corejava; 
   public class Employee { 
   }
3. 标记为 public 的部分可以被任意的类使 用；标记为 private 的部分只能被定义它们的类使用。如果没有指定 public 或 private , 这 个 部 分（类、方法或变量）可以被同一个包中的所有方法访问。

**文档注释：**

JDK 包含一个很有用的工具，叫做javadoc, 它可以由源文件生成一个 HTML 文档。

**类设计技巧：**

1. 一定要保证数据私有。这是最重要的，绝对不要破坏封装性。
2. 一定要对数据初始化。Java 不对局部变量进行初始化， 但是会对对象的实例域进行初始化。最好不要依赖于系 统的默认值， 而是应该显式地初始化所有的数据
3. 不要在类中使用过多的基本类型。就是说，用其他的类代替多个相关的基本类型的使用。这样会使类更加易于理解且易于 修改。
4. 不是所有的域都需要独立的域访问器和域更改器
5. 将职责过多的类进行分解。如果明 显地可以将一个复杂的类分解成两个更为简单的类，就应该将其分解
6. 类名和方法名要能够体现它们的职责。
7. 优先使用不可变的类。更改对象的问题在于， 如果多个线程试图同时更新一个对象，就会发生并发更改。

### 05：继 承

本章将学习面向对象程序设计的另外一个基本概念: 继承（inheritance)。利用继承，人们可以基于已存在的类构造一个新类。继承已存在的类就 是复用（继承）这些类的方法和域。

1. 关键字 extends 表示继承（public class Manager extends Employee）。关键字 extends 表明正在构造的新类派生于一个已存在的类。 已存在的类称为超类 ( superclass)、 基类（ base class) 或父类（parent class); 新类称为子类（subclass、) 派生类 ( derived class) 或孩子类（child class)
2. 在通过扩展超类定义子类的时候，仅需要指出子类与超类的不同之处。因此在设计类的时候，应该将通用的方法放在超类中， 而将具有特殊用途的方法放在子类中
3. 有些人认为 super 与 this 引用是类似的概念， 实际上，这样比较并不太恰当。这是 因为 super 不是一个对象的引用， 不能将 super 赋给另一个对象变量， 它只是一个指示编 译器调用超类方法的特殊关键字。
   关键字 this 有两个用途： 一是引用隐式参数，二是调用该类其他的构 造器 ， 同样，super 关键字也有两个用途：一是调用超类的方法，二是调用超类的构造器。
4. 由于 子类的构造器不能访问超 类的私有域， 所以必须利用 超 类 的构造器对这部分私有域进行初始化，我们可以通过 super 实现对超类构造器的调用。使用 super 调用构造器的语句必须是子类构造器的第一条语句。 
   如果子类的构造器没有显式地调用超类的构造器， 则将自动地调用超类默认（没有参数 ) 的构造器。 如果超类没有不带参数的构造器， 并且在子类的构造器中又没有显式地调用超类 的其他构造器，则 Java 编译器将报告错误。
5. 一个对象变量（例如， 变量 e ) 可以指示多种实际类型的现象被称为多态（ polymorphism)。 在运行时能够自动地选择调用哪个方法的现象称为动态绑定（ dynamic binding。)
6. 有时候，可能希望阻止人们利用某个类定义子类。不允许扩展的类被称为 final 类。如果 在定义类的时候使用了 final 修饰符就表明这个类是 final 类。
   类中的特定方法也可以被声明为 final。如果这样做，子类就不能覆盖这个方法（ final 类中的所有方法自动地成为 final 方法 ) ，将方法声明为 final 主要目的是： 确保它们不会在子类中改变语义。
7. 对象引用的转换语法与数值表达式的类型转换类似， 仅 需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了，Manager boss = (Manager) staff[0]；
   将一个子类的引用赋给一个超类 变量， 编译器是允许的。但将一个超类的引用赋给一个子类变量， 必须进行强制类型转换， 这样 才能够通过编译时的检査。
   总之，1、只能在继承层次内进行类型转换。2、在将超类转换成子类之前，应该使用 instanceof进行检查。（instanceof会检查变量的运行类型）
8. 如果自下而上在类的继承层次结构中上移，位于上层的类更具有通用性，甚至可能更加 抽象，祖先类更加通用， 人们只将它作为派生其他类的基类，而不作为想使 用的特定的实例类。
9. 包含一个或多个抽象方法的类本身必须被声明为抽象的，除了抽象方法之外，抽象类还可以包含具体数据和具体方法。抽象方法充当着占位的角色， 它们的具体实现在子类中。类即使不含抽象方法，也可以将类声明为抽象类，而抽象类不能被实例化。
   需要注意， 可以定义一个抽象类的对象变量， 但是它只能引用非抽象子类的对象，这是运用到了多态的知识。
10. Java 用于控制可见性的 4 个访问修饰符：1 ) 仅对本类可见 private。2 ) 对所有类可见 public。3 ) 对本包和所有子类可见 protected。4 ) 对本包可见—默认（很遗憾，) 不需要修饰符。
11. Object 类是 Java 中所有类的始祖， 在 Java 中每个类都是由它扩展而来的，如果没有明确地指出超类，Object 就被认为是这个类的超类。
    在 Java 中，只有基本类型 （ primitive types) 不是对象， 例如，数值、 字符和布尔类型的 值都不是对象。 所有的数组类型，不管是对象数组还是基本类型的数组都扩展了 Object 类。
12. Object 类中的 equals 方法用于检测一个对象是否等于另外一个对象，在 Object 类中，这 个方法将判断两个对象是否具有相同的引用，如果两个对象具有相同的引用， 它们一定是相 等的。然而，对于多数类来说， 这种判断 并没有什么意义。所以我们经常在子类中，重写基类的equals。
13. 在 Object 中还有一个重要的方法， 就是 toString方法， 它用于返回表示对象值的字符 串。当然，设计子类的程序员也应该定义自己的 toString 方法，并将子类域的描述添加进去。  强烈建议为自定义的每一个类增加 toString 方法。这样做不仅自己受益， 而且所 有使用这个类的程序员也会从这个日志记录支持中受益匪浅
14. ArrayList 是一个采用类型参数（ type parameter ) 的泛型类（ generic class)。为了指定数 组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面， 例如，ArrayList类型，ArrayList<Employee> staff = new ArrayList()；这被称为“ 菱形” 语法，因为空尖括号<>就像是一个菱形.
    数组列表自动扩展容量的便利增加了访问元素语法的复 杂程度。 其原因是 ArrayList 类并不是 Java 程序设计语言的一部分，它只是一个由某些人编 写且被放在标准库中的一个实用类。
15. 有时， 需要将 int 这样的基本类型转换为对象, 所有的基本类型都冇一个与之对应的类。例如，Integer 类对应基本类型 int。通常， 这些类称为包装类 （ wrapper ) 。
    Integer、Long、Float、Double、Short、Byte、Character 、 Boolean (前 6 个类派生于公共的超类 Number)。

**继承的设计技巧：**

1. 将公共操作和域放在超类
2. 不要使用受保护的域
3. 使用继承实现“ is-a” 关系
4. 除非所有继承的方法都有意义，否则不要使用继承
5. 在覆盖方法时，不要改变预期的行为
6. 使用多态， 而非类型信息

### 06：接 口 lambda 内部类

**接口：**

接口（ interface) 技术， 这种技术主要用来描述类具有什么功能，而并不 给出每个功能的具体实现。一个类可以实现（ implement) —个或多个接口，并在需要接口的 地方， 随时使用实现了相应接口的对象。

1. 接口不是类，而是对类的一组需求描述，这些类要遵从接口描 述的统一格式进行定义。
2. 接口中的所有方法自动地属于 public。 因此，在接口中声明方法时，不必提供关键字 public 。
3. 要将类声明为实现某个接口， 需要使用关键字 implements: class Employee implements Comparable
4. 接口不是类，尤其不能使用 new 运算符实例化一个接口，然而， 尽管不能构造接口的对象，却能声明接口的变量，接口变量必须引用实现了接口的类对象
5. 使用抽象类表示通用属性存在这样一个问题： 每个类只能扩展于一个类。假 设 Employee 类已经扩展于一个类， 例如 Person, 它就不能再像下面这样扩展第二个类了。接口可以提供多重继承的大多数好处，同时还能避免多重继承的复杂性和低效性。
6. 回调（ callback) 是一种常见的程序设计模式。在这种模式中，可以指出某个特定事件发 生时应该采取的动作。

**lambda 表达式：**

lambda表达式，这是 一种表示可以在将来某个时间点执行的代码块的简洁方法。使用 lambda 表达式，可以用一 种精巧而简洁的方式表示使用回调或变量行为的代码。

1. lambda 表达式是一个可传递的代码块， 可以在以后执行一次或多次。

2. lambda 表达式就是一个代码块， 以及必须传入 代码的变量规范。

   一种 lambda 表达式形式：参数， 箭头（->) 以及一个表达式。如 果代码要完成的计算无法放在一个表达式中，就可以像写方法一样，把这些代码放在 {}中， 并包含显式的 return语句。
   (String first, String second) -> first.length() - second.length()

3. 对于只有一个抽象方法的接口， 需要这种接口的对象时， 就可以提供一个 lambda 表达 式。这种接口称为函数式接口

   下面考虑 Arrays.sort 方法。它的第二个参数需要一个 Comparator 实例， Comparator 就是只有一个方法的接口， 所以可以提供一个 lambda 表达式
   Arrays.sort (words, (first, second) -> first.length() - second.length()) ;

**内部类:**

内部类（ inner class) 机制。理论上讲，内部类有些复杂， 内部类定义在另 外一个类的内部， 其中的方法可以访问包含它们的外部类的域。内部类技术主要用于设计具 有相互协作关系的类集合

1. 内部类方法可以访问该类定义所在的作用域中的数据， 包括私有的数据
2. 内部类可以对同一个包中的其他类隐藏起来
3. 当想要定义一个回调函数且不想编写大量代码时，使用匿名 （anonymous) 内部类比较 便捷
4. 假如只创建这个类的一个对象，就不必命名了。这种类被称为匿名内部类
5. 在内部类不需要访问外围类对象的时候， 应该使用静态内部类。 有些程序员用嵌 套类 （nested class) 表示静态内部类。与常规内部类不同，静态内部类可以有静态域和方法。声明在接口中的内部类自动成为 static 和 public 类。

### 07：异常、断言和曰志

对于异常情况， 例如， 可能造成程序崩溃的错误输入，Java 使 用 一 种 称 为 异 常 处 理的错误捕获机制处理。假设在一个 Java 程序运行期间出现了一个错误。这个错误可能是由于文件包含了错误 信息，或者网络连接出现问题造成的，也有可能是因为使用无效的数组下标， 或者试图使用 一个没有被赋值的对象引用而造成的。用户期望在出现错误时， 程序能够采用一些理智的行 为。

1. 异常处理的任务就是将控制权从错误产生的地方转移给能够处理这种情况的错误处理 器。程序中可能会出现的错误和问题：
   1. 用户输入错误
   2. 设备错误
   3. 物理限制，磁盘满了，可用存储空间已被用完
   4. 代码错误，程序方法有可能无法正确执行。

2. Error 类层次结构描述了 Java 运行时系统的内部错误和资源耗尽错误。 应用程序不应该 抛出这种类型的对象。 如果出现了这样的内部错误， 除了通告给用户，并尽力使程序安全地 终止之外， 再也无能为力了。这种情况很少出现。
3. 在设计 Java 程序时， 需要关注 Exception 层次结构。 这个层次结构又分解为两个分支： 一个分支派生于 RuntimeException ; 另一个分支包含其他异常。
4. 由 程序错误导致的异常属于 RuntimeException ; 而程序本身没有问题， 但由于像 I/O 错误这类 问题导致的异常属于其他异常（编译异常）。
5. 在程序中，可能会遇到任何标准异常类都没有能够充分地描述清楚的问题。 在这种情 况下，创建自己的异常类就是一件顺理成章的事情了。我们需要做的只是定义一个派生于 Exception 的类，或者派生于 Exception 子类的类。
6. 只要将其抛出就不用理 踩了。当然， 有些代码必须捕获异常。如果某个异常发生的时候没有在任何地方进行捕获，那程序就会终止执行，并在控制台 上打印出异常信息， 其中包括异常的类型和堆栈的内容。要想捕获一个异常， 必须设置 try/catch语句块。
7. 在一个 try 语句块中可以捕获多个异常类型，并对不同类型的异常做出不同的处理。
8. 当代码抛出一个异常时， 就会终止方法中剩余代码的处理，并退出这个方法的执行。
9. 异常处理不能代替简单的测试、不要过分地细化异常、 利用异常层次结构、不要压制异常、在检测错误时，“ 苛刻 ” 要比放任更好、不要羞于传递异常
10. 在一个具有自我保护能力的程序中， 断言很常用。当希望进行检查， 以避免让“ 不是一个数” 的数值参与计算操作。主动可以抛 出一个异常。断言机制允许在测试期间向代码中插入一些检査语句，如果结果为 false, 则抛出一个 AssertionError 异常。

## Java基础技术

### 多态机制

#### 多态是什么

多态（Polymorphism）按字面的意思就是“多种状态”。在面向对象语言中，接口的多种不同的实现方式即为多态。

#### 多态的语法格式

父类类名 引用名称 = new 子类类名();

当是多态时，该引用名称只能访问父类中的属性和方法，但是访问的时候，会优先访问子类重写以后的方法

#### 满足多态的条件

子类必须继承父类

子类必须重写父类的方法

父类引用指向子类对象，即：父类类名 引用名称 = new 子类类名();

#### 使用多态好处

使用多态可以使代码之间的耦合度降低

减少冗余代码的同时，也使得项目的扩展能力更强

注：耦合度指的是代码（程序）之间的关联程度

#### 多态中的类型转换

Java多态中，有两种类型转换：向上转型和向下转型

##### 向上转型

向上转型，是自动类型转换，子类型赋值给父类型（父类型的引用指向子类型），构成多态

父类类型 引用名称 = new 子类类名();

当使用多态方式调用方法时，该引用名称只能访问父类中的属性和方法。编译器首先检查父类中是否有该方法，如果没有，则编译错误。如果有，再去调用子类的同名（重写）方法。

##### 向下转型

向下转型，是强制类型转换，父类型赋值给子类型

当使用多态时，并且访问子类独有的属性或方法时，则必须进行向下转型

当进行向下转型时，建议先使用 instance of 关键字进行判断，判断合法时，则在转为对应的类型，否则可能会出现类型转换异常 java.lang.ClassCastException。

#### 多态的实现方式

1. 普通子类重写父类方法
2. 接口
3. 抽象类和抽象方法

#### 多态简单使用案例

场景：假如有个饲养员，需要给不同的宠物喂食，下面给出使用多态和不使用多态的实现方式

##### 不使用多态的实现

首先定义一个抽象类Animal、一个饲养员类AnimalKeeper、一个宠物类Dog和一个宠物类Cat。

```java
public abstract class Animal {

    public void eat() {
        System.out.println("动物吃东西！");
    }
}

public class Dog extends Animal {
    @Override
    public void eat() {
        System.out.println("狗啃骨头！");
    }
}

public class Cat extends Animal {
    @Override
    public void eat() {
        System.out.println("猫吃鱼！");
    }
}
```

```java
/**
 * 饲养员
 */
public class AnimalKeeper {

    /**
     * 给宠物猫喂食
     *
     * @param cat
     */
    public void feed(Cat cat) {
        cat.eat();
    }

    /**
     * 给宠物狗喂食
     *
     * @param dog
     */
    public void feed(Dog dog) {
        dog.eat();
    }

}
```

```java
public class PolymorphicTest {

    public static void main(String[] args) {
        //创建饲养员对象
        AnimalKeeper animalKeeper = new AnimalKeeper();

        //创建宠物对象
        Cat cat = new Cat();
        animalKeeper.feed(cat);//猫吃鱼！

        Dog dog = new Dog();
        animalKeeper.feed(dog);//狗啃骨头！
    }
}
```

以上实现看起来没有什么问题，也容易理解，在目前情况下，饲养员可以满足喂养宠物的需求。但是，过了一周，饲养员又喂养了一只鸟，这时候不得不修改AnimalKeeper类，使其可以饲养宠物鸟，不仅违反了Java中的开闭原则，而且以上代码的实现，扩展性极差。

##### 使用多态的实现

只需要对以上代码中，饲养员类AnimalKeeper进行替换，新增一个饲养员类AnimalKeeperPolymorphic类。

```java
/**
 * 饲养员
 */
public class AnimalKeeperPolymorphic {

    /**
     * 饲养员给宠物喂食
     *
     * @param animal
     */
    public void feed(Animal animal) {
        animal.eat();
    }

}
```

这种实现有什么好处呢，当新需求来了，需要扩展时，不需要修改饲养员的代码。比如说刚才那个需求，新增加一个宠物鸟，只需要新建一个宠物鸟类，实现Animal接口，不仅遵循了OCP原则，也可以实现饲养宠物鸟的功能。

#### 多态分析

以上文中示例代码进行分析，看看多态是如何使用的。AnimalKeeperPolymorphic中的feed()方法，使用了多态。

当饲养员喂养宠物狗时，其实执行的是：

```abnf
Animal animal = new Dog();
```

当饲养员喂养宠物猫时，其实执行的是：

```abnf
Animal animal = new Cat();
```

这种属于向上转型，里面有继承（cat继承Animal）关系，重写了父类eat()方法，子类型赋值给父类型（父类型的引用指向子类型），构成了多态。

Animal animal = new Cat(); 程序**在编译阶段，animal引用类型被编译器看做Animal类型**，所以程序**在编译阶段，animal引用绑定的是Aninmal类中的eat()方法，这个过程叫做Java多态的静态绑定**。

程序**在运行的时候，堆中的对象实际上是Cat类型**，而Cat对象已经覆盖（重写）了父类Animal的eat()方法，所以**程序在运行阶段，对象绑定的方法是Cat中的eat()方法，这个过程叫做Java多态的动态绑定**。

### 注解机制详解

#### 注解基础

注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解。它主要的作用有以下四方面：

- 生成文档，通过代码里标识的元数据生成javadoc文档。
- 编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。
- 编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。
- 运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例。

**Java自带的标准注解**，包括`@Override`、`@Deprecated`和`@SuppressWarnings`，分别用于标明重写某个方法、标明某个类或方法过时、标明要忽略的警告，用这些注解标明后编译器就会进行检查。

**元注解**，元注解是用于定义注解的注解，包括`@Retention`、`@Target`、`@Inherited`、`@Documented`，`@Retention`用于标明注解被保留的阶段，`@Target`用于标明注解使用的范围，`@Inherited`用于标明注解可继承，`@Documented`用于标明是否生成javadoc文档。

**自定义注解**，可以根据自己的需求定义注解，并可用元注解对自定义注解进行注解。

接下来我们通过这个分类角度来理解注解。

#### Java内置注解

`@Override`：表示当前的方法定义将覆盖父类中的方法

`@Deprecated`：表示代码被弃用，如果使用了被@Deprecated注解的代码则编译器将发出警告

`@SuppressWarnings`：表示关闭编译器警告信息

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
//从它的定义我们可以看到，这个注解可以被用来修饰方法，并且它只在编译时有效，在编译后的class文件中便不再存在。这个注解的作用我们大家都不陌生，那就是告诉编译器被修饰的方法是重写的父类的中的相同签名的方法，编译器会对此做出检查，若发现父类中不存在这个方法或是存在的方法签名不同，则会报错。

@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target(value={CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE})
public @interface Deprecated {
}
//从它的定义我们可以知道，它会被文档化，能够保留到运行时，能够修饰构造方法、属性、局部变量、方法、包、参数、类型。这个注解的作用是告诉编译器被修饰的程序元素已被“废弃”，不再建议用户使用。

@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})
@Retention(RetentionPolicy.SOURCE)
public @interface SuppressWarnings {
    String[] value();
}
//它能够修饰的程序元素包括类型、属性、方法、参数、构造器、局部变量，只能存活在源码时，取值为String[]。它的作用是告诉编译器忽略指定的警告信息
```

#### 元注解

上述内置注解的定义中使用了一些元注解（注解类型进行注解的注解类），在JDK 1.5中提供了4个标准的元注解：`@Target`，`@Retention`，`@Documented`，`@Inherited`, 在JDK 1.8中提供了两个元注解 `@Repeatable`和`@Native`。

##### @Target

Target注解的作用是：描述注解的使用范围（即：被修饰的注解可以用在什么地方） 。

Target注解用来说明那些被它所注解的注解类可修饰的对象范围：注解可以用于修饰 packages、types（类、接口、枚举、注解类）、类成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数），在定义注解类时使用了@Target 能够更加清晰的知道它能够被用来修饰哪些对象，它的取值范围定义在ElementType 枚举中。

```java
public enum ElementType {
    TYPE, // 类、接口、枚举类
    FIELD, // 成员变量（包括：枚举常量）
    METHOD, // 成员方法
    PARAMETER, // 方法参数
    CONSTRUCTOR, // 构造方法
    LOCAL_VARIABLE, // 局部变量
    ANNOTATION_TYPE, // 注解类
    PACKAGE, // 可用于修饰：包
    TYPE_PARAMETER, // 类型参数，JDK 1.8 新增
    TYPE_USE // 使用类型的任何地方，JDK 1.8 新增
}
```

##### @Retention

Reteniton注解的作用是：描述注解保留的时间范围（即：被描述的注解在它所修饰的类中可以被保留到何时） 。

Reteniton注解用来限定那些被它所注解的注解类在注解到其他类上以后，可被保留到何时，一共有三种策略，定义在RetentionPolicy枚举中。

```java
public enum RetentionPolicy {
 
    SOURCE,    // 源文件保留
    CLASS,       // 编译期保留，默认值
    RUNTIME   // 运行期保留，可通过反射去获取注解信息
}
```

##### @Documented

Documented注解的作用是：描述在使用 javadoc 工具为类生成帮助文档时是否要保留其注解信息。

##### @Inherited

Inherited注解的作用：被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。

```java
@TestInheritedAnnotation(values = {"value"}, number = 10)
public class Person {
}

class Student extends Person{
	@Test
    public void test(){
        Class clazz = Student.class;
        Annotation[] annotations = clazz.getAnnotations();
        for (Annotation annotation : annotations) {
            System.out.println(annotation.toString());
        }
    }
}

//输出：xxxxxxx.TestInheritedAnnotation(values=[value], number=10)
```

即使Student类没有显示地被注解`@TestInheritedAnnotation`，但是它的父类Person被注解，而且`@TestInheritedAnnotation`被`@Inherited`注解，因此Student类自动有了该注解。

#### 注解与反射接口

定义注解后，如何获取注解中的内容呢？反射包java.lang.reflect下的AnnotatedElement接口提供这些方法。这里注意：**只有注解被定义为RUNTIME后，该注解才能是运行时可见**，当class文件被装载时被保存在class文件中的Annotation才会被虚拟机读取。

AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的方法来访问Annotation信息。

1. 判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false。注意：此方法会忽略注解对应的注解容器。

   ```java
   boolean isAnnotationPresent(Class<?extends Annotation> annotationClass)
   ```

2. 返回该程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null。

   ```java
   <T extends Annotation> T getAnnotation(Class<T> annotationClass)
   ```

3. 返回该程序元素上存在的所有注解，若没有注解，返回长度为0的数组。

   ```java
   Annotation[] getAnnotations()
   ```

#### 自定义注解

当我们理解了内置注解, 元注解和获取注解的反射接口后，我们便可以开始自定义注解了。这个例子我把上述的知识点全部融入进来, 代码很简单：

**定义自己的注解**

```java
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyMethodAnnotation {

    public String title() default "";

    public String description() default "";

}
```

**使用注解**

```java
public class TestMethodAnnotation {

    @Override
    @MyMethodAnnotation(title = "toStringMethod", description = "override toString method")
    public String toString() {
        return "Override toString method";
    }

    @Deprecated
    @MyMethodAnnotation(title = "old static method", description = "deprecated old static method")
    public static void oldMethod() {
        System.out.println("old method, don't use it.");
    }

    @SuppressWarnings({"unchecked", "deprecation"})
    @MyMethodAnnotation(title = "test method", description = "suppress warning static method")
    public static void genericsTest() throws FileNotFoundException {
        List l = new ArrayList();
        l.add("abc");
        oldMethod();
    }
}
```

**用反射接口获取注解信息**

```java
// 获取所有methods(不理解)
Method[] methods = TestMethodAnnotation.class.getClassLoader()
        .loadClass(("com.pdai.java.annotation.TestMethodAnnotation"))
        .getMethods();

// 遍历
for (Method method : methods) {
    // 方法上是否有MyMethodAnnotation注解
    if (method.isAnnotationPresent(MyMethodAnnotation.class)) {
            // 获取并遍历方法上的所有注解
            for (Annotation anno : method.getDeclaredAnnotations()) {
                System.out.println("Annotation in Method '"
                        + method + "' : " + anno);
            }

            // 获取MyMethodAnnotation对象信息
            MyMethodAnnotation methodAnno = method
                    .getAnnotation(MyMethodAnnotation.class);

            System.out.println(methodAnno.title());
    }
}
```

#### 注解支持继承吗？

注解是不支持继承的。

不能使用关键字extends来继承某个@interface，但注解在编译后，编译器会自动继承java.lang.annotation.Annotation接口.

虽然反编译后发现注解继承了Annotation接口，请记住，即使Java的接口可以实现多继承，但定义注解时依然无法使用extends关键字继承@interface。

区别于注解的继承，被注解的子类继承父类注解可以用@Inherited： 如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解。

### 重写与重载详解

#### 重写 (Override)

##### 重写基本介绍

重写是子类对父类的允许访问的方法的实现过程进行重新编写！返回值和形参都不能改变。即外壳不变，核心重写！

重写的好处在于子类可以根据需要，定义特定于自己的行为。也就是说子类能够根据需要实现父类的方法。实例如下：

```java
class Animal{
   public void move(){
      System.out.println("动物可以移动");
   }
}

class Dog extends Animal{
   public void move(){
      System.out.println("狗可以跑和走");
   }
}

Animal a = new Animal(); // Animal 对象
Animal b = new Dog(); // Dog 对象
a.move();// 执行 Animal 类的方法
b.move();//执行 Dog 类的方法

动物可以移动
狗可以跑和走
```

在上面的例子中可以看到，尽管 b 属于 Animal 类型，但是它运行的是 Dog 类的 move 方法。

**这是由于在编译阶段，只是检查参数的编译类型。然而在运行时，Java 虚拟机 (JVM) 指定对象的运行类型并且运行该对象的方法。**

**因此在上面的例子中，之所以能编译成功，是因为 Animal 类中存在 move 方法，然而运行时，是因为JVM指定了该对象的运行类型Dog，运行的是Dog类重写的move方法。**

思考以下例子：

```java
class Dog extends Animal{

   public void move(){
      System.out.println("狗可以跑和走");
   }
    //新增了一个子类特有的bark方法
   public void bark(){ 
      System.out.println("狗可以吠叫");
   }
}

Animal a = new Animal(); // Animal 对象
Animal b = new Dog(); // Dog 对象
a.move();// 执行 Animal 类的方法
b.move();//执行 Dog 类的方法
a.bark();//执行 Animal 类的方法  ？？这一行报错

该程序将抛出一个编译错误，因为 a 的编译类型 Animal 没有 bark 方法。这里要进行一个向下转型的操作即可
```

##### 方法重写的规则

* 参数列表与被重写方法的参数列表必须完全相同。

* 返回类型与被重写方法的返回类型最好是相同，如果不同，则必须是**该返回值的子类**

  ```java
  class a {}
  
  class b extends a {}
  
  class c {
      public a test() {
          return null;
      }
  }
  class d extends c {
      @Override
      public b test() {
          return null;
      }
  }
  ```

* 子类方法的访问权限必须大于或等于父类方法的访问权限。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。

* 声明为 final 的方法不能被重写。

* 声明为 static 的方法不能被重写。

* 构造方法不能被重写。

* 重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常

##### Super 关键字的使用

当需要在子类中调用父类的被重写方法时，要使用 super 关键字。

```java
class Dog extends Animal{

   public void move(){
      super.move(); // 应用super类的方法
      System.out.println("狗可以跑和走");
   }
}
Animal b = new Dog(); 
b.move(); //执行 Dog类的方法

动物可以移动
狗可以跑和走
```

#### 重载 (Overload)

重载 (overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型呢？可以相同也可以不同。

每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

最常用的地方就是构造器的重载。

**重载规则：**

* 被重载的方法必须改变参数列表；
* 被重载的方法可以改变返回类型；
* 被重载的方法可以改变访问修饰符；
* 被重载的方法可以声明新的或更广的检查异常；
* 方法只能在同一个类中被重载。
* 无法以返回值类型作为重载函数的区分标准。

**实例：**

```java
public int test(){
    System.out.println("test1");
    return 1;
}

public void test(int a){
    System.out.println("test2");
}	

//以下两个参数类型顺序不同
public String test(int a,String s){
    System.out.println("test3");
    return "returntest3";
}	

public String test(String s,int a){
    System.out.println("test4");
    return "returntest4";
}	
```



#### 总结

方法的重写 (Overriding) 和重载 (Overloading) 是 java 多态性的不同表现。重写是父类与子类之间多态性的一种表现，重载可以理解成多态的具体表现形式。

1. 方法重载是一个类中定义了多个方法名相同,而他们的参数的数量不同或数量相同而类型和次序不同,则称为方法的重载 (Overloading)。
2. 方法重写是在子类存在方法与父类的方法的名字相同,而且参数的个数与类型一样,返回值也一样的方法,就称为重写 (Overriding)。
3. 方法重载是一个类的多态性表现,而方法重写是子类与父类的一种多态性表现。

**重写与重载之间的区别：**

![image-20240322083419617](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240322083419617.png) 

![image-20240322083452116](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240322083452116.png)  

## Java集合框架

### Java 8系列之重新认识HashMap

HashMap是Java程序员使用频率最高的用于映射(键值对)处理的数据类型。随着JDK（Java Developmet  Kit）版本的更新，JDK1.8对HashMap底层的实现进行了优化，例如引入红黑树的数据结构和扩容的优化等。本文结合JDK1.7和JDK1.8的区别，深入探讨HashMap的结构实现和功能原理。

Java为数据结构中的映射定义了一个接口java.util.Map，此接口主要有四个常用的实现类，分别是HashMap、Hashtable、LinkedHashMap和TreeMap

(1) **HashMap**：它根据键的hashCode值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。  HashMap最多只允许一条记录的键为null，允许多条记录的值为null。HashMap非线程安全，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections的synchronizedMap方法使HashMap具有线程安全的能力，或者使用ConcurrentHashMap。

(2) **Hashtable**：Hashtable是遗留类，很多映射的常用功能与HashMap类似，不同的是它承自Dictionary类，并且是线程安全的，任一时间只有一个线程能写Hashtable，并发性不如ConcurrentHashMap，因为ConcurrentHashMap引入了分段锁。Hashtable不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。

(3) **LinkedHashMap**：LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。

(4) **TreeMap**：TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。

对于上述四种Map类型的类，要求映射中的key是不可变对象。不可变对象是该对象在创建后它的哈希值不会被改变。如果对象的哈希值发生变化，Map对象很可能就定位不到映射的位置了。通过上面的比较，我们知道了HashMap是Java的Map家族中一个普通成员，鉴于它可以满足大多数场景的使用条件，所以是使用频度最高的一个。下文我们主要结合源码，从存储结构、常用方法分析、扩容以及安全性等方面深入讲解HashMap的工作原理。

**搞清楚HashMap，首先需要知道HashMap是什么，即它的存储结构-字段；其次弄明白它能干什么，即它的功能实现-方法。下面我们针对这两个方面详细展开讲解。**

#### 存储结构-字段

从结构实现来讲，HashMap是数组+链表+红黑树（JDK1.8增加了红黑树部分）实现的，如下如所示。

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240326133555982.png" alt="image-20240326133555982" style="zoom:50%;" /> 

(1) 从源码可知，HashMap类中有一个非常重要的字段，就是 Node[] table，即哈希桶数组，明显它是一个Node的数组。我们来看Node[JDK1.8]是何物。
Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。上图中的每个黑色圆点就是一个Node对象。

(2)  HashMap就是使用哈希表来存储的。哈希表为解决冲突，可以采用开放地址法和链地址法等来解决问题，Java中HashMap采用了链地址法。链地址法，简单来说，就是数组加链表的结合。在每个数组元素上都一个链表结构，当数据被Hash后，得到数组下标，把数据放在对应下标元素的链表上。

```
map.put("美团","小美");
```

系统将调用”美团”这个key的hashCode()方法得到其hashCode  值（该方法适用于每个Java对象），然后再通过Hash算法的后两步运算（高位运算和取模运算，下文有介绍）来定位该键值对的存储位置，有时两个key会定位到相同的位置，表示发生了Hash碰撞。当然Hash算法计算结果越分散均匀，Hash碰撞的概率就越小，map的存取效率就会越高。

如果哈希桶数组很大，即使较差的Hash算法也会比较分散，如果哈希桶数组数组很小，即使好的Hash算法也会出现较多碰撞，所以就需要在空间成本和时间成本之间权衡，其实就是在根据实际情况确定哈希桶数组的大小，并在此基础上设计好的hash算法减少Hash碰撞。那么通过什么方式来控制map使得Hash碰撞的概率又小，哈希桶数组（Node[] table）占用空间又少呢？答案就是好的Hash算法和扩容机制。

在理解Hash和扩容流程之前，我们得先了解下HashMap的几个字段。从HashMap的默认构造函数源码可知，构造函数就是对下面几个字段进行初始化，源码如下：

```
int threshold;             // 所能容纳的key-value对极限 
final float loadFactor;    // 负载因子
int modCount;  
int size;  
```

首先，Node[] table的初始化长度length(默认值是16)，Load  factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳的最大数据量的Node(键值对)个数。threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。

结合负载因子的定义公式可知，threshold就是在此Load  factor和length(数组长度)对应下允许的最大元素数目，超过这个数目就重新resize(扩容)，扩容后的HashMap容量是之前容量的两倍。默认的负载因子0.75是对空间和时间效率的一个平衡选择，建议大家不要修改，除非在时间和空间比较特殊的情况下，如果内存空间很多而又对时间效率要求很高，可以降低负载因子Load factor的值；相反，如果内存空间紧张而对时间效率要求不高，可以增加负载因子loadFactor的值，**这个值可以大于1**（？）。

size这个字段其实很好理解，就是HashMap中实际存在的键值对数量。注意和table的长度length、容纳最大键值对数量threshold的区别。而modCount字段主要用来记录HashMap内部结构发生变化的次数，主要用于迭代的快速失败。强调一点，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。

在HashMap中，哈希桶数组table的长度length大小必须为2的n次方(一定是合数)，这是一种非常规的设计，常规的设计是把桶的大小设计为素数。相对来说素数导致冲突的概率要小于合数，具体证明可以参考[这篇文章](http://blog.csdn.net/liuqiyao_01/article/details/14475159)，Hashtable初始化桶大小为16，HashMap采用这种非常规设计，主要是为了在取模和扩容时做优化，同时为了减少冲突，HashMap定位哈希桶索引位置时，也加入了高位参与运算的过程。

这里存在一个问题，即使负载因子和Hash算法设计的再合理，也免不了会出现拉链过长的情况，一旦出现拉链过长，则会严重影响HashMap的性能。于是，在JDK1.8版本中，对数据结构做了进一步的优化，引入了红黑树。而当链表长度太长（默认超过8）时，链表就转换为红黑树，利用红黑树快速增删改查的特点提高HashMap的性能，其中会用到红黑树的插入、删除、查找等算法。本文不再对红黑树展开讨论，想了解更多红黑树数据结构的工作原理可以参考[这篇文章](http://blog.csdn.net/v_july_v/article/details/6105630)。

#### 功能实现-方法

##### 确定哈希桶数组索引位置

HashMap的内部功能实现很多，本文主要从根据key获取哈希桶数组索引位置、put方法的详细执行、扩容过程三个具有代表性的点深入展开讲解。

不管增加、删除、查找键值对，定位到哈希桶数组的位置都是很关键的第一步。前面说过HashMap的数据结构是数组和链表的结合，所以我们当然希望这个HashMap里面的元素位置尽量分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，不用遍历链表，大大优化了查询的效率。HashMap定位数组索引位置，直接决定了hash方法的离散性能。

```java
static final int hash(Object key) {
    int h;
    // h = key.hashCode() 为第一步 取hashCode值
     // h ^ (h >>> 16)  为第二步 高位参与运算
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```

Hash算法本质上就是两步：**取key的hashCode值、高位运算**

对于任意给定的对象，只要它的hashCode()返回值相同，那么程序调用方法一所计算得到的Hash码值总是相同的。我们首先想到的就是把hash值对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。在JDK1.8的实现中，优化了高位运算的算法，通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^  (h >>>  16)，主要是从速度、功效、质量来考虑的，这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销。

**取模运算**

```java
 if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);
```

调用这个方法**i = (n - 1) & hash**来计算该对象应该保存在table数组的哪个索引处。

这个方法非常巧妙，它通过h & (table.length  -1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方，这是HashMap在速度上的优化。当length总是2的n次方时，h& (length-1)运算等价于对length取模，也就是h%length，但是&比%具有更高的效率。

##### HashMap的put

HashMap的put方法执行过程可以通过下图来理解，自己有兴趣可以去对比源码更清楚地研究学习。

![image-20240326140808081](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240326140808081.png) 

①.判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；

②.根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向⑥，如果table[i]不为空，转向③；

③.判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的是hashCode以及equals；

④.判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；

⑤.遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树（另外要求size大于64），在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；

⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩容。

##### 扩容机制resize（）

扩容(resize)就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。当然Java里的数组是无法自动扩容的，方法是使用一个新的数组代替已有的容量小的数组，就像我们用一个小桶装水，如果想装更多的水，就得换大水桶。

#### 线程安全性

在多线程使用场景中，应该尽量避免使用线程不安全的HashMap，而使用线程安全的ConcurrentHashMap。那么为什么说HashMap是线程不安全的，下面举例子说明在并发的多线程使用场景中使用HashMap可能造成死循环。代码例子如下(便于理解，仍然使用JDK1.7的环境)：

```java
public class HashMapInfiniteLoop {  

    private static HashMap<Integer,String> map = new HashMap<Integer,String>(2，0.75f);  
    public static void main(String[] args) {  
        map.put(5， "C");  

        new Thread("Thread1") {  
            public void run() {  
                map.put(7, "B");  
                System.out.println(map);  
            };  
        }.start();  
        new Thread("Thread2") {  
            public void run() {  
                map.put(3, "A);  
                System.out.println(map);  
            };  
        }.start();        
    }  
} 
```

其中，map初始化为一个长度为2的数组，loadFactor=0.75，threshold=2*0.75=1，也就是说当put第二个key的时候，map就需要进行resize。

通过设置断点让线程1和线程2同时debug到transfer方法的首行。注意此时两个线程已经成功添加数据。放开thread1的断点至transfer方法的“Entry next = e.next;” 这一行；然后放开线程2的的断点，让线程2进行resize。结果如下图。

![image-20240326144915957](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240326144915957.png) 

注意，Thread1的 e 指向了key(3)，而next指向了key(7)，其在线程二rehash后，指向了线程二重组后的链表。

线程一被调度回来执行，先是执行 newTalbe[i] = e， 然后是e = next，导致了e指向了key(7)，而下一次循环的next = e.next导致了next指向了key(3)。

e.next = newTable[i] 导致 key(3).next 指向了 key(7)。注意：此时的key(7).next 已经指向了key(3)， 环形链表就这样出现了。

于是，当我们用线程一调用map.get(11)时，悲剧就出现了——Infinite Loop。

![image-20240326145341670](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240326145341670.png) 

HashMap中，如果key经过hash算法得出的数组索引位置全部不相同，即Hash算法非常好，那样的话，getKey方法的时间复杂度就是O(1)，如果Hash算法技术的结果碰撞非常多，假如Hash算极其差，所有的Hash算法结果得出的索引位置一样，那样所有的键值对都集中到一个桶中，或者在一个链表中，或者在一个红黑树中，时间复杂度分别为O(n)和O(lgn)。 鉴于JDK1.8做了多方面的优化，总体性能优于JDK1.7。

文章链接：https://tech.meituan.com/2016/06/24/java-hashmap.html

### 对比Vector、ArrayList、LinkedList有何区别？

我们在日常的工作中，能够高效地管理和操作数据是非常重要的。由于每个编程语言支持的数据结构不尽相同，比如我最早学习的 C  语言，需要自己实现很多基础数据结构，管理和操作会比较麻烦。相比之下，Java 则要方便的多，针对通用场景的需求，Java  提供了强大的集合框架，大大提高了开发者的生产力。

今天我要问你的是有关集合框架方面的问题，**对比 Vector、ArrayList、LinkedList 有何区别？**

这三者都是实现集合框架中的 List，也就是所谓的有序集合，因此具体功能也比较近似，比如都提供按照位置进行定位、添加或者删除的操作，都提供迭代器以遍历其内容等。但因为具体的设计区别，在行为、性能、线程安全等方面，表现又有很大不同。

Vector 是 Java 早期提供的线程**安全的动态数组**，如果不需要线程安全，并不建议选择，毕竟同步是有额外开销的。Vector 内部是使用对象数组来保存数据，可以根据需要自动的增加容量，当数组已满时，会创建新的数组，并拷贝原有数组数据。

ArrayList 是应用更加广泛的**动态数组**实现，它本身不是线程安全的，所以性能要好很多。与 Vector 近似，ArrayList 也是可以根据需要调整容量，不过两者的调整逻辑有所区别，Vector 在扩容时会提高 1 倍，而 ArrayList 则是增加 50%。

LinkedList 顾名思义是 Java 提供的**双向链表**，所以它不需要像上面两种那样调整容量，它也不是线程安全的。

似乎从我接触 Java 开始，这个问题就一直是经典的面试题，前面我的回答覆盖了三者的一些基本的设计和实现。

一般来说，也可以补充一下不同容器类型适合的场景：

Vector 和 ArrayList 作为动态数组，其内部元素以数组形式顺序存储的，所以非常适合随机访问的场合。除了尾部插入和删除元素，往往性能会相对较差，比如我们在中间位置插入一个元素，需要移动后续所有元素。

而 LinkedList 进行节点插入、删除却要高效得多，但是随机访问性能则要比动态数组慢。

所以，在应用开发中，如果事先可以估计到，应用操作是偏向于插入、删除，还是随机访问较多，就可以针对性的进行选择。这也是面试最常见的一个考察角度，给定一个场景，选择适合的数据结构，所以对于这种典型选择一定要掌握清楚。

原文链接：https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/Java%20%e6%a0%b8%e5%bf%83%e6%8a%80%e6%9c%af%e9%9d%a2%e8%af%95%e7%b2%be%e8%ae%b2/08%20%20%e5%af%b9%e6%af%94Vector%e3%80%81ArrayList%e3%80%81LinkedList%e6%9c%89%e4%bd%95%e5%8c%ba%e5%88%ab%ef%bc%9f-%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4.md















# 项目笔记 

### 留言板项目：

![image-20240126133325443](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240126133325443.png)

1、在设置点赞的时候，你要用到<button onclick="点赞函数（this）">，这里面的this就是button按钮本身，通过**this.parentNode**,来访问到父级的容器节点，通过在**父级的容器节点.querySelect("点赞数")**，来获取到点赞按钮对应的点赞数。

2、设置了每一次在刷新或是发布评论时，随机更换头像。

### todolist项目：

要求：用前端三件套去实现todolist的基本功能，并结合git实现版本管理

成果图：

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E6%88%90%E6%9E%9C1.png" alt="image-20240128113121971" style="zoom: 80%;" /> 

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E6%88%90%E6%9E%9C2.png" alt="image-20240128113225760" style="zoom:80%;" /> 

心得：

1. 对于每一项任务的删除或完成操作，借鉴了留言板项目的点赞功能，通过this.parentNode找到父级容器，然后运用node.remove()操作进行删除操作
2. 批量操作师根据复选框的checked属性进行if判断的，勾选则checked属性为true，用forEach进行批量操作
3. 不完善的点，每一次计算待办任务和已完成任务的数量，都要重新计算类数组的长度，我觉得可以用监听来实现这一点，只要类数组的长度有变化，就会立即更新待办任务和已完成任务的数量，而不用在每一个需要删除和完成操作的函数最后面进行更新

### 用户中心项目：

完整了解做项目的思路，接触一些企业级的开发技术（尽量少写代码）

#### 企业做项目流程

需求分析=>设计（概要设计，详细设计）=> 技术选型=>初始化项目/引入需要的技术=>写Demo=>写代码（实现业务逻辑）=>测试（单元测试）=>代码提交/代码评审=>部署=>发布

#### 需求分析

1. 登录/注册

2. 数据库设计：

   id（主键）bigint

   username 昵称 varchar

   userAccount 登录账号 

   avatarUrl 头像 varchar

   gender 性别 tinyint

   userPassword 密码 varchar

   phone 电话 varchar

   email 邮箱 varchar

   isValid 是否有效 (比如被封号)tinyint 0 1

   ------

   createTime 创建时间（数据插入时间）datetime

   updateTime 更新时间（数据更新时间）datetime

   isDelete 是否删除0 1（逻辑删除）tinyint

3. 用户管理（仅管理员可见）对用户的查询、修改

4. 用户校验（仅星球用户）

   

   

#### 技术选型

前端：三件套+React+组件库Ant Design+Umi+Ant Design Pro（现成的管理系统）

后端：java + spring + springmvc + mybatis + mybatis-plus+springboot+mysql

部署：服务器+容器（平台）

#### 计划

1. 初始化项目
   1. 前端初始化
      1. 初始化项目
      2. 引入一些组件
      3. 框架介绍/项目瘦身
   2. 后端初始化
      1. 准备环境（MySql之类的）
      2. 引入框架（整合框架）
2. 登录/注册
   1. 前端
   2. 后端
3. 用户管理（仅管理员可见）
   1. 前端
   2. 后端

#### 注册逻辑

1. 用户在前端输入账号和密码，以及校验码
2. 校验用户的账户、密码、验证密码是否符合要求
   1. 非空
   2. 账户的话**不小于**4位
   3. 密码**不小于**8位
   4. 账户不能重复
   5. 账户不包含特殊字符
   6. 密码和验证密码相同
3. 对密码进行加密（密码千万不能直接以明文储存到数据库中）
4. 向数据库插入用户数据

#### 登录接口

接受参数： 用户账户、密码

请求类型：POST

请求体：JSON格式的数据

> 请求参数很长时，不建议用get

返回值：用户信息（**脱敏**） 

#### 登录逻辑

1. 校验用户账户密码是否合法 
   1. 非空
   2. 账户的话**不小于**4位
   3. 密码**不小于**8位
   4. 账户不包含特殊字符
2. 校验密码是否输入正确，要和数据库中的密文密码去比对
3. 返回用户信息（脱敏），隐藏敏感信息，防止数据库中的字段泄露
4. 记录用户的登录态（session），将其存到服务器上（用后端springboot框架封装的服务器tomcat去记录）
5. 返回脱敏后的用户信息

#### 用户管理接口

！！！必须鉴权

1. 查询用户
   1. 允许根据用户名查询
2. 删除用户

#### 如何知道那个用户登录了？（javaweb）

1. 连接服务器端后，得到一个session状态（匿名会话），返回给前端

2. 登陆成功后，得到一个登录成功的session，并给该session设置一些值，比如说用户信息，返回给前端一个设置cookie的命令。

   **session => cookie **

3. 前端接受到后端命令后，奢姿cookie，保存到浏览器内

4. 前端再次请求后端的时候（相同的域名），在请求头带上cookie去请求

5. 后端拿到前端传来的cookie，找到对应的session

6. 后端从session中可以取出基于该session存储的变量（用户的登录信息、登录名）


#### 前后端交互

前端需要向后端发送请求

前端ajax来请求后端

axious封装了ajax

request是ant design项目有封装了一次

#### 代理

正向代理：替客户端向服务器发送请求，

反向代理：替服务器接受请求，

怎么搞代理？

Nginx服务器

node.js服务器

![image-20240207144306714](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240207144306714.png)

#### 问题解决：

1. 前端初始化，在使用官网命令时，没有umi3选项？

   在cmd输入yarn global add create-umi@0.27.0，建个myapp文件夹，在这个文件夹的cmd下输入create-umi。如果在输入create-umi显示是外部命令（这是yarn的小毛病，yarn全局安装的包确实用不了），需要先**yarn global bin**找到yarn的bin目录，然后再把此目录添加进环境变量。

   总结：没有使用官方的命令，而是通过全局下载的create-umi



2. 前端初始化，yarn global add create-umi@0.27.0网络一直ping不通报？

   yarn和npm一样都可以配置淘宝镜像源，配置之后可以通过yarn config list检查。配置成功之后要关掉梯子。



3. 后端初始化，在配置java版本时，最低也只能到java17版本，需要java8？

   原因是springboot官方停止了对springboot2的维护，解决办法就是在IDEA里更改Server URL即可，用阿里云的镜像。

![image-20240202090502436](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240202090502436.png)

4. 连接数据库时，mysql连接不了，经过查找发现是Mysql服务无法启动的问题？

![image-20240202094357389](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240202094357389.png)

![image-20240202100104008](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240202100104008.png) 

直接专业卸载

5. 打开金师播放器后，复制粘连键用不了了？

   win + r 打开命令框，输入 cmd.exe /c echo off | clip （每次打开播放器观看都需要输入）

### 零钱通项目：

 使用 Java 开发 零钱通项目 , 完成收益入账，消费，查看明细，退出系统等功能。面向过程编程、面向对象编程两种方式

![image-20240303110648477](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303110648477.png) 

### 房屋出租系统

实现基于文本界面的《房屋出租软件》。

 能够实现对房屋信息的添加、修改和删除（用数组实现），并能够打印房屋明细表

![image-20240303164142160](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303164142160.png) 

![image-20240303164216502](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303164216502.png) 

**退出系统**

![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303164243311.png) 

**设计分析**

![image-20240303165520739](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303165520739.png) 

# 算法笔记

## 数组专项

### 二分查找

二分查找是先找到一个区间的中间位置middle，和某个target进行比较，可能这个middle就是target；也可能target大于middle，说明target是在左区间，反之target则在右区间，然后循环。

首先要想到一个while循环，循环条件是left和right比大小。其次，也是难点，**要根据区间的分类进行写代码，不同的区间，代码的形式不一样**。区间一般来讲，分为**左闭右闭**，和**左闭右开**。

#### **左闭右闭**

1. left等于0，right等于**arr.length-1**，因为是右闭，**如果right等于arr.length就说明arr.length在我们的范围区间里面**，而这是错误的

2. while的循环条件是(**left <= right**)，因为是左闭右闭，所以存在left等于right的情况，例如：[1,1]这是合理的区间

3. 当arr[middle] > target，说明target在左区间，left不需要改变，但是right需要改变，**此时right等于middle - 1**，**因为是右闭，已经明确得知arr[middle] > target的情况下，说明middle索引的数不等于target，middle不在范围区间里面，所以要middle - 1**

4. 当arr[middle] < target，说明target在右区间，right不需要改变，但是left需要改变，**此时left等于middle + 1**，原因同3

   ```java
   public static int search1(int[] nums, int target) {
           int right = nums.length - 1;
           int left = 0;
           int middle;
           while (left <= right) {
               middle = (left+right) / 2;
               if (nums[middle] > target) {
                   right = middle - 1;
                   continue;
               }
               if (nums[middle] < target) {
                   left = middle + 1;
                   continue;
               }
               return middle;
           }
           return -1;
       }
   ```

#### **左闭右开**

1. left等于0，right等于**arr.length**，因为是右开，**right等于arr.length这个范围区间本来就不包含arr.length这个索引**

2. while的循环条件是(**left < right**)，因为是左闭右开，不存在left等于right的情况，例如：[1,1）这是不合理的区间

```java
 public static int search2(int[] nums, int target) {
        int right = nums.length;
        int left = 0;
        int middle;
        while (left < right) {
            middle = (left+right) / 2;
            if (nums[middle] > target) {
                right = middle;
                continue;
            }
            if (nums[middle] < target) {
                left = middle + 1;
                continue;
            }
            return middle;
        }
        return -1;
    }
```

#### 总结

不管是左闭右闭也好，还是左闭右开也好，当你确定了一个区间分类后，在以后的代码分析中就要坚持这个想法，明确边界的范围。

### 移除元素

这个要求原地移除所有等于Val的数值，并返回新数组的长度。我们知道数组是不能拓展它自身的，除非嫁接到一个新的数组，而题目要求在原地进行操作。所以我们提出来**双指针的算法**来解决这一题。

**双指针算法**：

一个快指针（fast），一个慢指针（slow），它们的作用是：fast指针是通过遍历找到**不等于Val**的索引（这是要删除的，这是不满足新数组的数值），slow指针是在原地把**符合新数组的数值（fast找到的）**拷贝过来，fast指针和slow指针是在同一个数组里面，只是作用不一样。而且最后我们可以发现slow指针所指向的索引是新数组的长度。

```java
public static int removeElement(int[] nums, int val) {
    int slow = 0;
    for (int fast = 0; fast < nums.length; fast++) {
        if (nums[fast] != val) {
            nums[slow] = nums[fast];
            slow++;
        }
    }
    return slow;
}
```

### 有序数组平方

这个题我先开始是用平方，后用冒泡排序做的，但是发现时间复杂度太高，平方哪里遍历了一次所有的数组，然后再是冒泡排序，时间开销很大。

后面，有一种双指针的算法，可以极大的节省时间开销。而且这个题目也很有特点：它是要比较平方之后的大小，**那么越靠近两边的数，平方之后就越大**，因为可能有负数，而中间的数平方之后最小。那么就可以**设计一种双指针，一个指针指向头，一个指针指向尾，然后两个指针平方之后比大小,大的就存放进新数组**，然后进行相应的数据处理。

```java
//双指针的思路，时间复杂度低，但是多用了一个result数组 
public static int[] sortedSquares (int[] nums) {
        int[] result = new int[nums.length];
        int k = nums.length - 1;
        for (int i = 0,j = nums.length - 1; i <= j; ) {
            if (nums[i]*nums[i] > nums[j]*nums[j]) {
                result[k--] = nums[i]*nums[i];
                i++; //i要加一，而j不变，可以看到i和j不因循环次数而改变，只有相应的条件到达才能改变i，j的值
            } else {
                result[k--] = nums[j]*nums[j];
                j--;
            }
        }
        return result;
}
```

```java
//先平方，后用冒泡排序，时间复杂度高，但是是原地排序
public static int[] sortedSquares1 (int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        nums[i] = nums[i] * nums[i];
    }
    for (int i = 0; i < nums.length - 1; i++) {
        for (int j = 0; j < nums.length - 1 - i; j++) {
            if (nums[j] > nums[j+1]) {
                int temp = nums[j];
                nums[j] = nums[j+1];
                nums[j+1] = temp;
            }
        }
    }
    return nums;
}
```

### 长度最小的子数组

先开始想错了，以为可以先排序好，然后从头开始遍历找到最短的子数组满足target。题目要求数组不能动，你要在不懂原数组的基础上面，找到最小的大于等于target的子数组。

可以考虑用到滑动窗口的算法解。滑动窗口首先就要想到两个指针，滑动的区间就是这两个指针之间的区域，问题是怎么滑动这个区间。

首先，一个j指针，从头到尾开始移动，j指针移动到某个条件时，i指针开始滑动。这个条件就是当滑动区间的sum刚好大于或等于target的时候，进入到i指针的动作，i指针会向前移动一位，sum会减小，而且还要比较result和当前滑动区间的长度谁更小。

```java
public static int lengthOfLongestSubstring(int[] nums, int target) {
        int i = 0;
        int sum = 0;
        int result = nums.length;
        for (int j = 0; j < nums.length; j++) {
            sum += nums[j];
            while (sum >= target) { //这里是while而不是if，因为i有可能连续滑动(1,1,1,1,100),target=100
                sum -= nums[i];
                result = Math.min((j-i+1), result);
                i++;
            }
        }
        if (i == 0) {//i==0，说明for循环根本没有进入到while循环里面去，说明一直到滑动完，整个滑动区间的长度都没有大于target的情况
            return 0;
        }
        return result;
    }
}
```

### 螺旋矩阵

这一题是采用模拟的做法做出来的，模拟这个旋转矩阵。

首先就是要确定这个螺旋矩阵，我们模拟旋转的话，会转多少圈？答案是n / 2圈，但是当n为奇数时，我们单独处理中间的位置。

其次，我们要确定走的边的规则是什么，我的规则是左闭右开，那么就应该在4个for循环中都遵循左闭右开原则。

最后注意边界位置。

![image-20240312210028972](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240312210028972.png) 

```java
public int[][]  generateMatrix(int n) {
        int[][] matrix = new int[n][n];
        int startX = 0;
        int startY = 0;
        int offset = 1;
        int count = 1;

        int circle = n / 2;
        while(circle-- > 0) {
            for (int j = startY; j < n - offset; j++) {
                matrix[startX][j] = count++;
            }
            for (int i = startX; i < n - offset; i++) {
                matrix[i][n - offset] = count++;
            }
            for (int j = n - offset; j > startY; j--) {
                matrix[n - offset][j] = count++;
            }
            for (int i = n - offset; i > startX; i--) {
                matrix[i][startY] = count++;
            }
            startX++;
            startY++;
            offset++;
        }
        if(n % 2 == 1) {
            matrix[n/2][n/2] = n * n;
        }
        return matrix;
}
```

## 链表专项

### 移除链表元素

#### 原链表删除元素

移除链表元素有两种解法，我采用的原链表删除元素。这里就要考虑到头节点的删除和头结点之外的删除是不一样的。

删除头结点：如果头结点的val满足条件，那么就将head指针移向下一个节点即可；

删除非头结点：先把head指针赋值给current指针，当current.next.val满足条件时，则将current.next 指向current.next.next以此来达到删除的目的

注意，两个都要保证节点部位空。

```java
 public ListNode removeElements(ListNode head, int val) {
        while (head != null && head.val == val) {
            head = head.next;
        }
        ListNode current = head;

        while (current != null && current.next != null) {
            if (current.next.val == val) {
                current.next = current.next.next;
            }
            else {
                current = current.next;
            }

        }
        return head;
 }
```

#### 虚拟头结点删除元素

采用虚拟头结点删除元素可以统一代码形式，而采用原链表删除元素的会有头结点和非头结点的区分。

首先就是要定义一个虚拟头结点，ListNode dummyHead = new ListNode(0,head);

然后就是，定义一个当前节点current，注意，是指向虚拟头结点，而不是虚拟头结点的next，因为头结点也可能被删除；

然后，while循环的条件是，current.next != null，说明还没有遍历到最后一个元素

最后返回的是虚拟头结点的next，而不是head，因为head有可能被删除，就是说链表一个元素都没有，都被删除了，如果此时返回head，那就剩head这个节点。

```java
//虚拟头结点删除元素
    public ListNode removeElements2(ListNode head, int val) {
        ListNode dummyHead = new ListNode(0,head); //先定义一个虚拟头结点
        ListNode current = dummyHead;
        while (current.next != null) {
            if (current.next.val == val) {
                current.next = current.next.next;
            } else {
                current = current.next;
            }
        }
        return dummyHead.next;
}
```

```java
//链表结构
class ListNode {
      int val;
      ListNode next;
      ListNode() {}
      ListNode(int val) { this.val = val; }
      ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}
```

### 设计链表

这题首先要想到用一个**虚拟头结点**来代表整个链表，这样设计的代码结构清晰，逻辑清楚，注意这时候可以只用虚拟头结点，而不需要在使用head指针。至于说，为什么统一，可以看代码，统一了头结点和非头结点的操作。

其次，要想到在这个链表类中，定义一个内部类Node，这样就可以很好的区分LinkedList类，虽然这两个类本质上没有什么区别，但是逻辑上给人很清晰的感觉。

注意，要定义一个全局的size，这样就可以在增删改查时，利用size快速索引出对应的index

```java
public class MyLinkedList {
    class Node {
        int val;
        Node next;
        public Node(int val) {
            this.val = val;
            this.next = null;
        }
    }

    int size;
    Node dummyHead;

    public MyLinkedList() {
        size = 0;
        dummyHead = new Node(0);
    }

    public int get(int index) {
        if (index<0 || index >= size) {
            return -1;
        }

        Node current = dummyHead;
        int i = 0;
        while (true) {
            if (index == i) {
                return current.next.val;
            }
            i++;
            current = current.next;
        }
    }

    public void addAtHead(int val) {
        Node node = new Node(val);
        node.next = dummyHead.next;
        dummyHead.next = node;
        size++;
    }

    public void addAtTail(int val) {
        Node node = new Node(val);

        Node current = dummyHead;
        while (current.next != null) {
            current = current.next;
        }
        current.next = node;
        size++;
    }

    public void addAtIndex(int index, int val) {
        if (index<0 || index >size ) {
            return;
        }
        if (index == size) {
            addAtTail(val);
            return;
        }

        Node node = new Node(val);
        Node current = dummyHead;
        int i = 0;
        while (true) {
            if (i == index) {
                node.next = current.next;
                current.next = node;
                size++;
                return;
            }
            current = current.next;
            i++;
        }
    }

    public void deleteAtIndex(int index) {
        if (index<0 || index >= size) {
            return;
        }
        Node current = dummyHead;
        int i = 0;
        while (true) {
            if (index == i) {
                current.next = current.next.next;
                size--;
                return;
            }
            i++;
            current = current.next;
        }
    }
}

class MyLinkedListTest {
    public static void main(String[] args) {
        MyLinkedList myLinkedList = new MyLinkedList();
        myLinkedList.addAtHead(5);
        myLinkedList.addAtIndex(1, 2);
        myLinkedList.get(1);
        myLinkedList.addAtHead(6);
        myLinkedList.addAtTail(2);
        myLinkedList.get(3);
        myLinkedList.addAtTail(1);
        myLinkedList.get(5);
        myLinkedList.addAtHead(2);
        myLinkedList.get(2);
        myLinkedList.addAtHead(6);
    }
}
```

### 反转链表

这一题，我是采用双指针的思路来写的，一个是current指针，指向当前的节点，另一个是pre指针，在current前面一位。记得还要有一个临时指针temp哦

首先是初始化，current初始化为head，pre初始化为null，想想为什么？然后想像一下这两个指针在完成current.next = pre之后，同时向后移动，直到pre指向最后一个节点，而current指向null，所以current == null是终止条件。

注意顺序哦，要先temp = current.next，保存current的下一个节点，然后就将current.next指向前一个节点pre，然后县移动pre = current，在移动current = temp

```java
//双指针解法
public static ListNode reverseList(ListNode head) {
    ListNode current = head;
    ListNode pre = null;
    ListNode temp;

    while (current != null) {
        temp = current.next;
        current.next = pre;
        pre = current;
        current = temp;

    }
    return pre;
    }
}
```

### 两两交换链表中的节点

这个题目首先是要想到虚拟头结点，然后你就要想象交换两两节点的一个大致流程：

流程：dummyHead先指向第二个节点，然后原始第二个节点指向原始第一个节点，然后原始第一个节点指向原始第三个节点，这样就完成了节点的两两交换，然后将current指针向前移动两位，开始进行下一轮的操作

注意的点：

1. 循环结束的条件，如果是奇数个节点，循环结束的条件是current.next.next为null；如果是偶数个节点，循环结束的条件是current.next为null，所以综合起来就是**while(current.next != null && current.next.next != null)**,一定要注意顺序，否则会造成NPE
2. 流程走向的具体细节，当dummyHead先指向第二个节点的时候，会失去current.next原本指向的第一个节点，这里要用一个临时指针保存；当原始第二个节点指向原始第一个节点的时候，会失去原本第二个节点.next指向的第三个节点，所以也要用一个临时指针保存。

```java
public ListNode swapPairs(ListNode head) {
    ListNode dummyHead = new ListNode();
    dummyHead.next = head;
    ListNode current = dummyHead;

    while (current.next != null && current.next.next != null) {
        ListNode temp = current.next;
        ListNode temp2 = current.next.next.next;
        current.next = current.next.next;
        current.next.next = temp;
        temp.next = temp2;

        current = current.next.next;
    }
    return dummyHead.next;
}
```

### 删除链表中倒数第N个节点

我首先是先循环遍历，得出链表的长度，然后计算得出删除节点的索引。删除的主题思想使用双指针，pre和current，然后就要考虑空指针异常，我就采用的虚拟头结点，这样当链表中只有一个节点的时候，我可以统一起来，pre指向dummyHead，current指向head，循环结束的条件是current遍历到对应的index为止，执行pre.next = current.next删除操作。

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    int length = 0;
    ListNode tempNode = head;
    while (tempNode != null) {
        length++;
        tempNode = tempNode.next;
    }

    int index = length - n;
    ListNode dummyHead = new ListNode();
    dummyHead.next = head;
    ListNode pre = dummyHead;
    ListNode current = head;
    for (int i = 0; i <= index; i++) {
        if (i == index) {
            pre.next = current.next;
            break;
        }
        pre = current;
        current = current.next;
    }
    return dummyHead.next;
}
```

### 链表相交

判断链表相交的思路是，**把两个链表右对齐**，只用判断右对齐后，从左往右判断他们的节点是否相等，来判断出相交的节点。这种思路很巧妙，规避了常规思路左对齐的各种分类讨论情况。

具体实现步骤是：先算出两个链表的长度；然后移动长度较长的current指针，使其右对齐；循环比较两个节点的current是否相等，来判断是否为相交节点。

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    int lengthA = getLength(headA);
    int lengthB = getLength(headB);
    ListNode currentA = headA;
    ListNode currentB = headB;
    if (lengthA > lengthB) {
        for (int i = 0; i < lengthA - lengthB; i++) {
            currentA = currentA.next;
        }
    }
    if (lengthA < lengthB) {
        for (int i = 0; i < lengthB - lengthA; i++) {
            currentB = currentB.next;
        }
    }

    while (currentA != currentB) {
        currentA = currentA.next;
        currentB = currentB.next;
    }
    return currentA;
}

public int getLength(ListNode current) {
    int length = 0;
    while (current != null) {
        length++;
        current = current.next;
    }
    System.out.println(length);
    return length;
}
```

### 环形链表二

首先这题是要你找到环形链表的入口节点。分为两步，第一步先判断是否有环，第二步既然有环，根据第一步找到的相遇节点结合头结点找到环形的入口节点。

第一步先判断是否有环：

首先就是定义两个快慢指针，快指针一次走走两步，慢指针一次走一步，那么如果他们相遇，他们必定是在环里面相遇，也证明了存在环；如果不相遇，那说明快指针先走到了结尾，说明没有环。如果有环，他们必定相遇在环内，这个相遇节点我们有安排

第二步既然有环，根据第一步找到的相遇节点结合头结点找到环形的入口节点：

![image-20240321200856016](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240321200856016.png) 

这里就要考察数学公式了，首先重新定义一个current指针指向head，然后让current指针和slow指针同时向后移动，直到他们相遇，相遇的节点就是环形的入口节点。

slow：**(X + Y)  * 2 = X + Y + (Y + Z)*N** :fast

==> X + Y = (Y + Z) * N

==>X = (Y + Z) * (N - 1) + Z    (N >= 1)

**当N = 1时，有X = Z**，这说明current移动到环形的入口节点的距离 与 slow指针移动到环形的入口节点的距离正好相等。也可以推断，当N > 1时，这两个指针的第一次相遇都是在环形的入口节点。

```java
public static ListNode detectCycle(ListNode head) {
    ListNode fast = head;
    ListNode slow = head;
    do {
        try {
            fast = fast.next.next;
        } catch (Exception e) {
            return null;
        }
        slow = slow.next;
    } while (fast != slow);

    ListNode current = head;
    while (current != slow) {
        current = current.next;
        slow = slow.next;
    }
    return current;
}
```

## 哈希专项

### 有效字母异位词

首先要理解题意，异位词是指，若 s 和 t 中每个字符出现的次数都相同，则称 s 和 t 互为字母异位词。

然后，我是第一次用hash表的解法，用hash的解法要想到三种数据结构分别是：数组、Set、Map

这是我是采用数组的方式来解这一题的，思路是：

首先你要想到用一个长度为26的整型数组，来记录26个小写字母出现的次数，

先看第一个字符串s，我们循环遍历s，hash [ **s.chatAt(i)  -  'a'** ] ++,字符会自动转型为整型，它会计算该字符与a字符的相对距离，这样就可以用hash数组的索引来表示每个字母出现的个数了，0表示a，1表示b，25表示z

然后我们遍历第二个字符串t，这里我们要做减减的操作，hash [ **s.chatAt(i)  -  'a'** ] --。

通过第一个for循环做加加操作，通过第二个for循环做减减操作，只要我们发现最后hash数组里面有元素大于0，或者是小于0，说明，这两个字符串肯定有些元素多了或是有些元素少了，总之就是不相等

~~~java
public static boolean isAnagram(String s, String t) {
    int[] hash = new int[26];
    for (int i = 0; i < s.length(); i++) {
        hash[s.charAt(i) - 'a']++;
    }
    for (int i = 0; i < t.length(); i++) {
        hash[t.charAt(i) - 'a']--;
    }
    for (int i = 0; i < 26; i++) {
        if (hash[i] != 0) {
            return false;
        }
    }
    return true;
}
~~~

### 两个数组的交集

我的思路是，先把其中一个数组num1转换成HashSet，这样可以为num1数组去重，然后我已num2数组为遍历，去查找num2的元素是否会出现在Hashset中，出现就把它存入到result的Hashset里面，这样就又可以去重（针对num2），最后再把result转换成整型数组。

难点就是，怎样把整型数组转换成HashSet，怎样把Hash装换成整形数组

~~~java
HashSet numSet= new HashSet<>(nums1.length);
        HashSet result= new HashSet<>(nums1.length);
        for (int i : nums1) {
            numSet.add(i);
        }

        for (int i : nums2) {
            if (numSet.contains(i)) {
                result.add(i);
            }
        }
        int[] arr = new int[result.size()];
        Object[] array = result.toArray();
        for (int i = 0; i < arr.length; i++) {
            arr[i] = (int)array[i];
        }
        return arr;
~~~

### 快乐数

**快乐数」** 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。

```
输入：n = 19
输出：true
解释：
1**2 + 9**2 = 82
8**2 + 2**2 = 68
6**2 + 8**2 = 100
1**2 + 0**2 + 0**2 = 1
```

首先这题不要想复杂了，很简单，一轮计算过程是：分别取出所有位数，然后平方求和看是不是1，如果不是就开始下一轮。

题目可以简化，把这些求出来的下一轮n，都统一放进一个Hashset中，如果在一轮一轮的计算过程中，发现这个下一轮n，竟然已经出现在Hashset中，那么说明再过一段时间，也会重复出现这个n，说明程序出现了无限循环，而这个数自然也不是happy数。那么当我发现下一轮n已经存在Hashset中是2，我就可以结束循环了，再就是确确实实出现了n ==  1，这就是happy数。

~~~java
public boolean isHappy(int n) {
    HashSet<Integer> set = new HashSet<>();
    while (n != 1 && !set.contains(n)) {
        set.add(n);
        n = getNextNum(n);
    }
    return n == 1;
}

public int getNextNum(int num) {
    int result = 0;
    int temp;
    while (num != 0) {
        temp = num % 10;
        result += temp * temp;
        num /= 10;
    }
    return result;
}
~~~

### 两数之和

给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数

**示例 1：**

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

其实这一题，很容易想到用两层for循环，循环遍历，直到找出两个数之和为target。但是我想用map的方式来解这一题，具体思路如下：

首先就是要定义一个HashMap，这个map的作用是遍历存放这个nums数组的元素值，和索引，具体来说：key=元素的值，value=元素在数组中的索引。这里我们只用一层for循环，在这循环里面我们首先计算target和nums[i]的差值，即**int s = target - num[i]**；然后我们判断这个s是否存在于map的key中，这样做的**目的在于，既然我的s存在于你的map中，那么map的这个key与nums[i]的和就是target，这就找到了**，只要返回这两个索引即可。

~~~java
public int[] twoSum(int[] nums, int target) {
    int[] res = new int[2];
    HashMap<Integer, Integer> map = new HashMap<>();

    for (int i = 0; i < nums.length; i++) {
        int s = target - nums[i];
        if (map.containsKey(s)) {
            res[0] = i;
            res[1] = map.get(s);
            break;
        }
        map.put(nums[i],i);
    }
    return res;
}
~~~

### 四数相加III

这个题目是四个数字，然后找出所有的nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0的个数，可以直接采用暴力解法，通过四层for循环，可以把所用的情况都遍历出来，而且不需要去重。

但是这一题我们采用哈希map的方式来解这一题，这是一道经典的采用map方式解决的一题。

思路：

首先定义两层for循环，将数组一num1和数组二num2的和保存到map的key中，那么map的value保存的是这个求和的值出现的次数；
然后，再定义两层for循环，去遍历数组三num3和数组四num4的和的相反数，在map的key中去匹配是否有与这个相反数相匹配的；
如果有的话，那么count的值要加上此时key对应的value值

代码：

~~~java
public static int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
    Map<Integer, Integer> map = new HashMap<>();
    int count = 0;

    for (int k : nums1) {
        for (int i : nums2) {
            int temp = k + i;
            map.put(temp, map.getOrDefault(temp, 0) + 1);
        }
    }

    for (int k : nums3) {
        for (int i : nums4) {
            int temp = -k - i;
            count += map.getOrDefault(temp, 0);
        }
    }

    return count;
}

~~~

### 赎金信

给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。

如果可以，返回 `true` ；否则返回 `false` 。

`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。

**示例 ：**

```
输入：ransomNote = "aa", magazine = "ab"
输出：false
输入：ransomNote = "aa", magazine = "aab"
输出：true
```

这一题很明显是要采用HashMap来做的，思路如下：

首先就是要遍历magazine，把它put到map中，key对应字符串中的字符，value对应该字符在字符串中出现的次数

然后遍历第二个字符串ransomNote，取到的字符在map中是否存在，如果不存在就直接return false，否则把该字符key对应的value减一，而且我们还要判断这个value的值是否小于0，如果小于0也要返回false。最后for循环后，return true

~~~java
public static boolean canConstruct(String ransomNote, String magazine) {
    Map<Character, Integer> map = new HashMap<>();

    for (int i = 0; i < magazine.length(); i++) {
        char c = magazine.charAt(i);
        map.put(c, map.getOrDefault(c, 0) + 1);
    }

    for (int i = 0; i < ransomNote.length(); i++) {
        char c = ransomNote.charAt(i);
        map.put(c, map.getOrDefault(c, 0) - 1);
        if (map.get(c) < 0) {
            return false;
        }
    }
    return true;
}
~~~

### 三数之和

给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]]，满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0。你返回所有和为 0 且不重复的三元组。注意：答案中不可以包含重复的三元组。

输入：nums = [-1,0,1,2,-1,-4]
输出：[[-1,-1,2],[-1,0,1]]
解释：
nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0 。
nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0 。
nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0 。
不同的三元组是 [-1,0,1] 和 [-1,-1,2] 。
注意，输出的顺序和三元组的顺序并不重要。

这一题不能用Hash的解法，因为太过复杂。这题我是采用双指针的解法，思路如下：

首先，最外层是一个for循环遍历nums，然后定义一个left指针指向i+1，一个right指针指向num.length - 1的索引位置。，这里我们要再定义一个while循环，再循环里面如果nums[i] + nums[left] + nums[right] == 0的话，这是满足条件的，可以直接add到集合中；如果nums[i] + nums[left] + nums[right] > 0，说明sum大了，要将right左移；如果nums[i] + nums[left] + nums[right] <  0，说明sum小了，要将left右移。这就是大概的一个流程，但是问题的关键在于去重。

如何去重？首先我想到的是i的去重，如果num[i] == num[i - 1]，说明我前面的i对应的值，和当前的i对应的值相等，那么前面i的数据对应的三元组（如果求得的话），也应该是一样的，那么这里我就要进行一次去重，直接continue

然后就是当nums[i] + nums[left] + nums[right] == 0，按道理我们应该同时进行right--和left++，但是考虑到：例如：如果我的nums[right] == nums[right-1],那这说明我当前的right的值和下一个right的值相等，在得知i是一定的，而right的值也是一定的情况下，那left的值也一定是固定的，这就是我们要去重的，具体做法是**while（nums[right] == nums[right - 1] && left < right）right--;**。同理**while (nums[left] == nums[left + 1] && left < right) {left++;}**，这就是三次去重操作。

~~~java
public static List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> list = new ArrayList<>();
    Arrays.sort(nums);

    if (nums[0] > 0) {
        return list;
    }

    for (int i = 0; i < nums.length; i++) {
        int left = i + 1;
        int right = nums.length - 1;

        if (i > 0 && nums[i] == nums[i - 1]) {
            continue;
        }

            while (left < right) {
                int temp = nums[i] + nums[left] + nums[right];
                if (temp > 0) {
                    right--;
                } else if (temp < 0) {
                    left++;
                } else {
                    list.add(Arrays.asList(nums[i],nums[left],nums[right]));
                    while (nums[right] == nums[right - 1] && left < right) {
                        right--;
                    }
                    while (nums[left] == nums[left + 1] && left < right) {
                        left++;
                    }
                    left++;
                    right--;
                }
            }
    }
    return list;
}
~~~

### 四数之和

给你一个由 `n` 个整数组成的数组 `nums` ，和一个目标值 `target` 。请你找出并返回满足下述全部条件且**不重复**的四元组 `[nums[a], nums[b], nums[c], nums[d]]` （若两个四元组元素一一对应，则认为两个四元组重复）：

- `0 <= a, b, c, d < n`
- `a`、`b`、`c` 和 `d` **互不相同**
- `nums[a] + nums[b] + nums[c] + nums[d] == target`

**示例 1：**

```
输入：nums = [1,0,-1,0,-2,2], target = 0
输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]
```

**示例 2：**

```
输入：nums = [2,2,2,2,2], target = 8
输出：[[2,2,2,2]]
```

这题目和上一道题三数之和是一个思路，只不过四数之和是四个数，多了一个数，都是用的双指针的思路，只不过原来是for循环里面套双指针，现在是for循环，再套for循环，再用双指针。

首先，当然是先排序，然后先用一个for循环来遍历第一个数i，这里我们要做一步剪枝，这与三数之和一致，但是if里面的判断条件要变化，因为target有小于0的情况，所以向判断**nums[i]>0 && nums[i] > target**，这说明确实没戏了，后面不需要遍历了，永远都得不到target的值，直接return。然后就要做去重的步骤，这和三数之和一致，**i > 0 && nums[i] == nums[i - 1]**

接下来，用第二个for循环，来遍历j，这里的**j的初始值等于i+1**，在这个第二个for循环里面，只用对j进行去重操作，**j > i + 1 && nums[j] == nums[j - 1]**

再就是，在第二个for循环里面定义双指针的遍历，这个和三数之和一模一样

~~~java
public List<List<Integer>> fourSum(int[] nums, int target) {
    List<List<Integer>> list = new ArrayList<>();
    Arrays.sort(nums);


    for (int i = 0; i < nums.length; i++) {
        //一级剪枝
        if (nums[i] > 0 && nums[i] > target) {
            return list;
        }
        //一级去重
        if (i > 0 && nums[i] == nums[i - 1]) {
            continue;
        }
        for (int j = i + 1; j < nums.length; j++) {
            //二级去重
            if (j > i + 1 && nums[j] == nums[j - 1]) {
                continue;
            }

            int left = j + 1;
            int right = nums.length - 1;
            while (right > left) {
                int temp = nums[i] + nums[j] + nums[left] + nums[right];
                if (temp > target) {
                    right--;
                } else if (temp < target) {
                    left++;
                } else {
                    list.add(Arrays.asList(nums[i],nums[j],nums[left],nums[right]));
                    while (right > left && nums[right] == nums[right - 1]) {
                        right--;
                    }
                    while (right > left && nums[left] == nums[left + 1]) {
                        left++;
                    }
                    right--;
                    left++;
                }
            }
        }
    }
    return list;
}
~~~

## 字符串专项

### 反转字符串II

给定一个字符串 `s` 和一个整数 `k`，从字符串开头算起，每计数至 `2k` 个字符，就反转这 `2k` 字符中的前 `k` 个字符。

- 如果剩余字符少于 `k` 个，则将剩余字符全部反转。
- 如果剩余字符小于 `2k` 但大于或等于 `k` 个，则反转前 `k` 个字符，其余字符保持原样。

**示例 1：**

```
输入：s = "abcdefg", k = 2
输出："bacdfeg"
```

这个题目有坑，要仔细审题才行呀，第一次做的时候，我没有把一个公用的操作放入一个函数中，导致后期写代码的时候发现自己写的代码很杂乱，这是一个点。然后这个题目有坑，它题目里面没有说剩余字符大于2k的情况，实际上测试代码里面有剩余字符数大于2k的情况，这时候，就要用while循环来解决，而不是用if，这是第二个点。然后就是题目里面也没有说k大于或等于s的长度的情况，当k大于或等于s的长度的时候，则把整个字符串反转。

以上就是这个题的大致思路，这题没有考察什么算法，但是它的逻辑步骤有些复杂，你就要去模拟它的逻辑，一步一步走不要出错

**反转指定位置的【start，end）字符串数组：**

~~~java
public static void reverseString(char[] s, int start, int end) {
    char temp;
    for (int i = start; i < start + (end - start) / 2; i++) {
        temp = s[i];
        int rightIndex = end - 1 - (i - start);
        s[i] = s[rightIndex];
        s[rightIndex] = temp;
    }
}
~~~

**将字符串数组转换为字符串：**

~~~java
public static String gainString(char[] c) {
    String result = "";
    for (char s : c) {
        result += s;
    }
    return result;
}
~~~

**反转字符串II方法：**

~~~java
public static String reverseStr(String s, int k) {
    char[] charArray = new char[s.length()];
    for (int i = 0; i < s.length(); i++) {
        charArray[i] = s.charAt(i);
    }

    //如果k大于或等于s的长度，则全部反转,并直接返回
    if (k >= s.length()) {
        reverseString(charArray,0,charArray.length);
        return gainString(charArray);
    }

    int start = 0;
    int end = k;
    int residualLength = s.length();
    do {
        //反转这 2k 字符中的前 k 个字符
        reverseString(charArray,start,end);

        //剩余的长度
        residualLength -= 2 * k;

        //如果剩余字符少于 k 个，则将剩余字符全部反转
        if (residualLength < k) {
            reverseString(charArray,s.length() - residualLength,s.length());
            return gainString(charArray);
        }

        //如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。
        if (residualLength < 2 * k && residualLength >= k) {
            reverseString(charArray,s.length() - residualLength,s.length() - residualLength + k);
            return gainString(charArray);
        }

        start += 2 * k;
        end += 2 * k;

    } while (true);
}
~~~















