# 后端笔记

## java SE

### 02：Java概述

#### Java 重要特点

1. Java 语言是面向对象的(oop)

2. Java 语言是健壮的。Java 的强类型机制、异常处理、垃圾的自动收集等是 Java 程序健壮性的重要保证
3. Java 语言是跨平台性的。[即: 一个编译好的.class 文件可以在多个系统下运行，这种特性称为跨平台]

3) Java 语言是解释型的[了解] 。

   解释性语言：javascript,PHP, java 

   编译性语言: c / c++ 

   区别是：解释性语言，编译后的代码，不能直接被机器执行,需要解释器来执行, 编译性语言, 编译后的代码, 可以直接被机器执行, c /c+

#### 什么是 JDK，JRE，JVM

1. JDK 的全称（Java Development Kit） Java 开发工具包。JDK 是提供给 Java 开发人员使用的，其中包含了 java 的开发工具，也包括了 JRE。所以安装了 JDK，就不用在单独 安装 JRE 了。

   **JDK = JRE + java 的开发工具** [java, javac,javadoc,javap 等]

2. JRE的全称（Java Runtime Environment） Java 运行环境。包括 Java 虚拟机(**JVM** Java Virtual Machine)和 Java 程序所需的核心类库等，如果想要运行一个开发好的 Java 程序， 计算机中只需要安装 JRE 即可。

   **JRE = JVM +Java 的核心类库**

####  Java 开发注意事项和细节说明

![image-20240224162718902](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240224162718902.png)

####  Java 转义字符

![image-20240224162905093](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240224162905093.png)

#### 注释(comment)

用于注解说明解释程序的文字就是注释，注释提高了代码的阅读性（可读性）；注释是一个程序员必须要具有的良 好编程习惯。将自己的思想通过注释先整理出来，再用代码去体现。

```java
//单行注释

/*
多行注释

多行注释
*/

/**
	*文档注释
	*author 陈俊宇
	*version 1.0
	*	
	*见下图
*/
```

![image-20240224163254806](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240224163254806.png)

####  Java 代码规范

![image-20240224163415535](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240224163415535.png)

#### Java编写步骤

1. 编写java的源代码

2. javac编译，得到对应的.class字节码文件

3. java运行，本质就是把.class加载到JVM运行

#### 本章作业

![image-20240224163527124](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240224163527124.png)

### 03：变量

#### 概念

变量相当于内存中一个数据存储空间的表示，你可以把变量看做是一个房间的门牌号，通过门牌号我们可以找到房间，而通过变量名可以访问到变量(值)

**变量 = 变量名 + 值 + 数据类型**

#### 程序中 +号的使用

1. 当左右两边都是数值型时，则做加法运算

2. 当左右两边有一方为字符串,则做拼接运算

![image-20240225113717741](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225113717741.png)

#### 数据类型

每一种数据都定义了明确的数据类型，在内存中分配了不同大小的内存空间(字节)。

![image-20240225145443035](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225145443035.png)

 基本数据类型有 8 中 数值型 byte , short , int , long , float ,double，char , boolean；引用类型有三种：类，接口， 数组。

##### 整型

Java 的整数类型就是用于存放整数值的，比如 12 , 30, 3456 等等。

![image-20240225145649044](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225145649044.png) 

![image-20240225145807635](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225145807635.png) 

**注意：byte a = 10;**

**看似是将默认的int类型转换成了更小的byte类型应该会报错，但是表达式是正确的。因为这里程序所做的事是：判断10这个值是否在-128~127之间，根据这个来看是否符合要求，注意：这里的10一定是一个具体的值，而不能是变量，或者是大于这个范围的值。short类型同样适用。**

##### 浮点型

Java 的浮点类型可以表示一个小数，比如 123.4 ，7.8 ，0.12 等等。

![image-20240225145919616](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225145919616.png) 

![image-20240225150023292](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150023292.png) 

##### 字符型

字符类型可以表示单个字符,字符类型是 char，char 是两个字节(可以存放汉字)，多个字符我们用字符串 String。

![image-20240225150238229](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150238229.png) 

![image-20240225150345863](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150345863.png) 

##### 布尔型

![image-20240225150439440](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150439440.png) 

#### 基本数据类型转换

##### 自动类型转换

![image-20240225150544626](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150544626.png) 

![image-20240225150650565](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150650565.png) 

##### 强制类型转换

自动类型转换的逆过程，将容量大的数据类型转换为容量小的数据类型。使用时要加上强制转换符 ( )，但可能造成
精度降低或溢出,格外要注意。

![image-20240225150803240](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150803240.png) 

![image-20240225150850098](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225150850098.png) 

#### 基本数据类型和 String 类型的转换

![image-20240225151001328](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225151001328.png) 

1. 在将 String 类型转成 基本数据类型时， 要确保String类型能够转成有效的数据，比如 我们可以把 "123" , 转成一个整数，但是不能把 "hello" 转成一个整数

2. 如果格式不正确，就会抛出异常，程序就会终止，

#### 本章作业

![image-20240225151148714](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225151148714.png)

### 04：运算符

运算符是一种特殊的符号，用以表示数据的运算、赋值和比较等

#### 算术运算符

算术运算符是对数值类型的变量进行运算的，在 Java 程序中使用的非常多

![image-20240227145701670](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227145701670.png)

![image-20240227145728090](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227145728090.png)

![image-20240227145749356](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227145749356.png)

#### 比较运算符

关系运算符的结果都是 boolean 型，也就是要么是 true，要么是 false

![image-20240227145853553](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227145853553.png)

关系运算符组成的表达式，我们称为**关系表达式**。 a > b

#### 逻辑运算符

用于连接多个条件（多个关系表达式），最终的结果也是一个 boolean 

![image-20240227150124179](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227150124179.png)

1. **a&b** : & 叫**逻辑与**：规则：当 a 和 b 同时为 true ,则结果为 true, 否则为 false 

2. **a&&b** : && 叫**短路与**：规则：当 a 和 b 同时为 true ,则结果为 true,否则为 false 

3. **a|b** : | 叫**逻辑或**，规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false 

4. **a||b** : || 叫**短路或**，规则：当 a 和 b ，有一个为 true ,则结果为 true,否则为 false

5. **!a** : 叫**取反**。当 a 为 true, 则结果为 false, 当 a 为 false 是，结果为 true 

6. **a^b**: 叫**逻辑异或**，当 a 和 b 不同时，则结果为 true, 否则为 false

**&& 和 & 使用区别（||和|同）:**

1. &&短路与：**如果第一个条件为 false，则第二个条件不会判断**，最终结果为 false，效率高 
2. & 逻辑与：**不管第一个条件是否为 false，第二个条件都要判断**，效率低

#### 赋值运算符

赋值运算符就是将某个运算后的值，赋给指定的变量。

赋值运算符分为两类：

1. 基本赋值运算符 **=** ：int a = 10
2.  复合赋值运算符**+= ，-= ，*= ， /= ，%=** ：
   a += b  ====》  等价 a = a + b; 

#### 三元运算符

条件表达式    ?     表达式 1    :     表达式2

运算规则： 

1. 如果条件表达式为 true，运算后的结果是表达式 1； 
2. 如果条件表达式为 false，运算后的结果是表达式 2

细节：

表达式 1 和表达式 2 要为可以赋给接收变量的类型(或可以自动转换)

#### 标识符的命名规则和规范

规则：

![image-20240227151129934](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227151129934.png)

规范：

1. 包名：多单词组成时所有字母都小写：aaa.bbb.ccc //比如 com.hsp.crm 
2. 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz [大驼峰] 比如： TankShotGame 
3. 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz [小 驼峰， 简称 驼峰法] 比如： tankShotGame 
4. 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ 比如 ：定义一个所得税率 TAX_RATE 

#### 键盘输入语句

在编程中，需要接收用户输入的数据，就可以使用键盘输入语句来获取。Input.java , 需要一个 扫描器(对象), 就是 Scanner

步骤：

1.  引入/导入 Scanner 类所在的包
   **import java.util.Scanner;**
2. 创建 Scanner 对象 , new 创建一个对象
   **Scanner myScanner = new Scanner(System.in)；**
3. 调用里面的功能
   **String name = myScanner.next(); //接收用户输入字符串**
   int age = myScanner.nextInt(); //接收用户输入 int
   double sal = myScanner.nextDouble(); //接收用户输入 doubl

```java
import java.util.Scanner;
public class Input {
    Scanner myScanner = new Scanner(System.in);
    String name = myScanner.next();
}
```



#### 原码、反码、补码

**进制:**

二进制：0,1 ，满 2 进 1.以 0b 或 0B 开头。 

十进制：0-9 ，满 10 进 1。 

八进制：0-7 ，满 8 进 1. 以数字 0 开头表示。 

十六进制：0-9 及 A(10)-F(15)，满 16 进 1. 以 0x 或 0X

**原码、反码、补码：**

![image-20240227152037830](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227152037830.png)

为什么计算机的计算都是采用补码的方式？

因为可以统一正数和负数的运算

#### 位运算符

java 中有 **7 个**位运算(**&、|、 ^ 、~、>>、<<和 >>>**)

![image-20240227152230556](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227152230556.png)

1. 算术右移 >>：低位溢出,符号位不变,并用符号位补溢出的高位 
2. 算术左移 <<: 符号位不变,低位补 0 
3. **>>>**逻辑右移也叫无符号右移,运算规则是: 低位溢出，高位补 0 
4. 特别说明：没有 <<< 符号

本章作业：

![image-20240227152554047](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227152554047.png)

![image-20240227152604098](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227152604098.png)

### 05：程序控制结构

在程序中，程序运行的流程控制决定程序是如何执行的，是我们必须掌握的，主要有三大流程控制语句：

1. 顺序控制
2. 分支控制 
3. 循环控制

####  顺序控制

![image-20240227184158551](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227184158551.png)

#### 分支控制 

让程序有选择的的执行,分支控制有三种 

1. 单分支 if 
2. 双分支 if-else 
3. 多分支 if-else if -....-else

##### 单分支

![image-20240227184323395](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227184323395.png)

![image-20240227190203640](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227190203640.png) 

##### 双分支

![image-20240227190255856](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227190255856.png)

![image-20240227190411393](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227190411393.png) 

##### 多分支

![image-20240227191732315](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227191732315.png) 

![image-20240227191751330](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227191751330.png) 

##### 嵌套分支

在一个分支结构中又完整的嵌套了另一个完整的分支结构，里面的分支的结构称为内层分支外面的分支结构称为外 层分支。

老师建议: 不要超过 3层（可读性不好）

##### switch 分支结构

![image-20240227193344488](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227193344488.png)

![image-20240227193358043](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227193358043.png)

![image-20240227193956153](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227193956153.png)

##### switch 和 if 的比较

1. 如果判断的具体数值不多，而且符合 byte、 short 、int、 char, enum[枚举], String 这 6 种类型。虽然两个语句都可 以使用，建议使用 swtich 语句。 
2. 其他情况：对区间判断，对结果为 boolean 类型判断，使用 if，if 的使用范围更广

#### 循环控制

##### for 循环

![image-20240227194619183](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227194619183.png)

![image-20240227194634788](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227194634788.png)

1.  循环条件是返回一个布尔值的表达式 
2. for(;循环判断条件;) 中的初始化和变量迭代可以写到其它地方，但是两边的分号不能省略。 
3. 循环初始值**可以有多条初始化语句，但要求类型一样，并且中间用逗号隔开**，循环变量迭代也可以有多条变量迭代 语句，中间用逗号隔开。

##### while 循环

![image-20240227195208401](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227195208401.png) 

![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227195217459.png) 

1. 循环条件是返回一个布尔值的表达式 
2. while 循环是先判断再执行语句

#####  do..while 循环

![image-20240227195605308](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227195605308.png) 

![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227195722863.png) 

1. 先执行，再判断，也就是说，一定会至少执行一次 
2. **最后 有一个 分号 ;** 

##### 多重循环

1. 将一个循环放在另一个循环体内，就形成了嵌套循环。其中，for ,while ,do…while 均可以作为外层循环和内层循环。 【**建议一般使用两层，最多不要超过 3 层**, 否则，代码的可读性很差】 
2. 实质上，**嵌套循环就是把内层循环当成外层循环的循环体**。当只有内层循环的循环条件为 false 时，才会完全跳出内 层循环，才可结束外层的当次循环，开始下一次的循环

3. 设外层循环次数为 m 次，内层为 n 次，则内层循环体实际上需要执行 m*n 次。

![image-20240227200302757](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227200302757.png) 

#### 跳转控制

##### break

break 语句用于终止某个语句块的执行，一般使用在 switch 或者循环[for , while , do-while]中

![image-20240227202403904](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227202403904.png) 

![image-20240227202419529](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227202419529.png)

##### continue

1. continue 语句用于结束本次循环，继续执行下一次循环。 
2. continue 语句出现在多层嵌套的循环语句体中时，可以通过标签指明要跳过的是哪一层循环 , 这个和前面的标签的 使用的规则一样

![image-20240227202548239](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227202548239.png) 

##### return

return 使用在方法，表示跳出所在的方法。如果 return 写在 main 方法中，则退出程序。

![image-20240227202706376](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227202706376.png) 

#### 本章作业

![image-20240227202734212](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227202734212.png)

![image-20240227202741313](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240227202741313.png) 

### 06：数组、排序和查找

数组可以存放多个同一类型的数据。数组也是一种数据类型，是引用类型。

**数(数据)组(一组)就是一组数据**

#### 数组的使用

```java
//**使用方式一：动态初始化**
int a[] = new int[3];

//**使用方式二：动态初始化**
//先申明数组、再创建数组
int a[];
a = new int[3];

//**使用方式三：静态初始化**
int a[] = {2,3,4};
```

![image-20240228162344823](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228162344823.png) 

#### 数组的细节

1. 数组是多个**相同类型数据的组合**，实现对这些数据的统一管理

2) 数组中的元素可以是任何数据类型，包括基本类型和引用类型，但是不能混用。
3) 数组创建后，**如果没有赋值，有默认值**
   int 0，short 0, byte 0, long 0, float 0.0,double 0.0，char \u0000，boolean false，String null

4) 使用数组的步骤 
   1) 声明数组并开辟空间 
   2) 给数组各个元素赋值 
   3) 使用数组
5) 数组的**下标是从** **0** **开始的**
6) 数组下标必须在指定范围内使用，否则报错：下标越界异常
7) 数组属**引用类型**，数组型数据是对象(object)

#### 数组赋值机制

1. 基本数据类型赋值，这个值就是具体的数据，而且相互不影响。int n1 = 2; int n2 = n1;

2) 数组在**默认情况下是引用传递，赋的值是地址**。

![image-20240228162932571](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228162932571.png) 

#### 排序

排序是将多个数据，依指定的顺序进行排列的过程。

排序分为：内部排序和外部排序

1. 内部排序：指将需要处理的所有数据都加载到内部存储器中进行排序。包括(交换式排序法、选择式排序法和插入式排序法)
2. 外部排序：数据量过大，无法全部加载到内存中，需要借助外部存储进行排序。包括(合并排序法和直接合并排序法)

#### 冒泡排序法

冒泡排序（Bubble Sorting）的基本思想是：通过对待排序序列从后向前（从下标较大的元素开始），依次比较相邻元素的值，若发现逆序则交换，使值较大的元素逐渐从前移向后部，就象水底下的气泡一样逐渐向上冒。

**思路：**

![image-20240228163400974](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228163400974.png) 

#### 二维数组

```java
//**使用方式1：动态初始化**
int a[3][3] = new int[3][3];

//**使用方式2：动态初始化**
//先声明、再开辟空间
int a[][];
a = new int[3][3]
    
//**使用方式 3: 动态初始化-列数不确定**
/**
0
00
000
*/
int a[][] = new a[10][];//先开辟行数的空间
for(int i = 0; i < a.length; i++) {
    a[i] = new int[i+1]; //再动态开辟列数的空间
}

int a[][];
a

//**使用方式 4: 静态初始化**
int a[][] = {{1,2,3},{4,5,6},{7,8,9}};
```

**储存细节：**

![image-20240228163846781](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228163846781.png) 

#### 二维数组细节

1) 一维数组的声明方式有:
   int[] x 或者 int x[]

2) 二维数组的声明方式有:
   ![image-20240228164437857](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228164437857.png)

3. 二维数组实际上是由多个一维数组组成的，它的各个一维数组的长度可以相同，也可以不相同。
4. 还是要注意数据类型的自动转换

![image-20240228164546217](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228164546217.png) 

#### 本章作业

![image-20240228164725724](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228164725724.png) 

![image-20240228164742609](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240228164742609.png) 

### 07：面向对象编程

#### 类与对象

```java
Cat cat1 = new Cat();

class Cat {
	String name; 
	int age; 
	String color; 
}
```

##### 类和对象的区别和联系

1. 类是抽象的，概念的，代表一类事物,比如人类,猫类.., 即它是数据类型
2. 对象是具体的，实际的，代表一个具体事物, 即 是实例
3. 类是对象的模板，对象是类的一个个体，对应一个实例

##### 对象在内存中存在形式

![image-20240229150533210](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229150533210.png)

##### 属性/成员变量

从概念或叫法上看： 成员变量 = 属性 = field(字段)

属性是类的一个组成部分，一般是基本数据类型,也可是引用类型(对象，数组)。

**属性细节：**

1. 属性的定义语法同变量，
   示例：访问修饰符 属性类型 属性名(**public int name**); 
2. 访问修饰符： 控制属性的访问范围 有四种访问修饰符 public, proctected, 默认, private 
3. 属性的定义类型可以为任意类型，包含基本类型或引用类型 
4. 属性如果不赋值，有默认值，规则和数组一致。
   具体说: int 0，short 0, byte 0, long 0, float 0.0,
   double 0.0，char \u0000， boolean false，String null

##### 创建对象

```java
//1. 先声明再创建
Cat cat; //声明对象 cat
cat = new Cat(); //创建

//1. 直接创建
Cat cat = new Cat();
```

##### 访问属性

```java
cat.name;
cat.age;
cat.color;
```

##### 类和对象的内存分配机制

**Java 内存的结构分析:** 

1. 栈： 一般存放基本数据类型(局部变量) 
2. 堆： 存放对象(Cat cat , 数组等) 
3. 方法区：常量池(常量，比如字符串)， 类加载信息

```java
//简单流程分析
Person p = new Person();
p.name = “jack”;
p.age = 1

/**
1) 先加载 Person 类信息(属性和方法信息, 只会加载一次)
2) 在堆中分配空间, 进行默认初始化(看规则)
3) 把地址赋给 p , p 就指向对象
4) 进行指定初始化，比如 p.name =”jack” p.age = 10  
*/

```

![image-20240229152024847](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229152024847.png)

#### 成员方法

在某些情况下，我们要需要定义成员方法(简称方法)。比如人类:除了有一些属性外( 年龄，姓名..),我们人类还有一 些行为比如:可以说话、跑步..,通过学习。这时就要用成员方法才能完成。

##### 基本使用

```java
//1. 方法写好后，如果不去调用(使用)，不会输出
//2. 先创建对象 ,然后调用方法即可
Person p1 = new Person();
p1.speak(); //调用方法

class Person {
	String name;
	int age;
    
    public void speak() {
        System.out.println("我是一个好人");
    }
    
    public int getSum(int num1, int num2) {
        int res = num1 + num2;
        return res;
    }
}
```

##### 方法的调用机制原理

![image-20240229152600039](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229152600039.png)

##### 成员方法的定义

![image-20240229152732957](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229152732957.png) 

1. **访问修饰符**： (作用是控制 方法使用的范围) 如果不写默认访问，[有四种: public, protected, 默认, private]

2.  **返回数据类型**：

   1. 一个方法最多有一个返回值 [如果返回多个结果 **返回数组** ]
   2. 返回类型可以为任意类型，包含基本类型或引用类型(数组，对象)
   3.  如果方法要求有返回数据类型，则方法体中最后的执行语句必须为 return 值; 而且要求返回值类型必须和 return 的 值类型一致或兼容
   4. 如果方法是 void，则方法体中可以没有 return 语句，或者 只写 **return ;**

3. **方法名**：遵循驼峰命名法，最好见名知义，表达出该功能的意思即可

4. **参数列表**：

   ![image-20240229153308376](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229153308376.png) 

##### 方法调用细节

![image-20240229153450642](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229153450642.png)

#### 成员方法传参机制

**基本数据类型的传参机制**

![image-20240229153624402](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229153624402.png) 

**引用数据类型的传参机制**

引用类型传递的是地址（传递也是值，但是值是地址），可以通过形参影响实参

#### 方法递归调用

递归就是方法**自己调用自己**,每次调用时传入不同的变量.递归有助于编程者解决复杂问题,同时可以让代码变 得简洁

**递归重要规则**

![image-20240229153906120](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229153906120.png)

![image-20240229154053516](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240229154053516.png)

#### 方法重载

java 中允许同一个类中，多个同名方法的存在，但要求 形参列表不一致！

**好处：**

1) 减轻了起名的麻烦 
2) 减轻了记名的麻烦

```java
class MyCalculator {
    //一个整数，一个 double 的和
    public double calculate(int n1, double n2) {
    	return n1 + n2;
    }
    //一个 double ,一个 Int 和
    public double calculate(double n1, int n2) {
        System.out.println("calculate(double n1, int n2) 被调用..");
        return n1 + n2;
    }
}
```

**细节:**

![image-20240301084526792](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301084526792.png) 

![image-20240301084546628](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301084546628.png) 

####  可变参数

java 允许将**同一个类中多个同名同功能但参数个数不同**的方法，封装成一个方法。 就可以通过可变参数实现。

**基本语法：**

![image-20240301084725289](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301084725289.png) 

```java
public int sum(int... nums) {
    //System.out.println("接收的参数个数=" + nums.length);
    int res = 0;
    for(int i = 0; i < nums.length; i++) {
    	res += nums[i];
    }
    return res;
}
```

**细节：**

![image-20240301084907686](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301084907686.png) 

```java
//细节: 可变参数可以和普通类型的参数一起放在形参列表，但必须保证可变参数在最后
public void f2(String str, double... nums) {
}

//细节: 一个形参列表中只能出现一个可变参数
//下面的写法是错的. 
public void f3(int... nums1, double... nums2) {
}
```

#### 作用域

![image-20240301085201052](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301085201052.png) 

**注意事项和细节使用:**

![image-20240301085248768](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301085248768.png) 

#### 构造方法

构造方法又叫构造器(constructor)，是类的一种特殊的方法，它的主要作用是完成对新对象的初始化。它有几个特点：

1) 方法名和类名相同 
2) 没有返回值 
3) 在创建对象时，系统会自动的调用该类的构造器完成对象的初始化。

**基本语法：**

![image-20240301085351515](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301085351515.png) 

1) 构造器的修饰符可以默认， 也可以是 public protected private 
2) 构造器没有返回值 
3) 方法名 和类名字必须一样 
4) 参数列表 和 成员方法一样的规则 
5) 构造器的调用, 由系统完成

**注意事项和使用细节：**

![image-20240301085756408](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301085756408.png) 

```java
public class ConstructorDetail {
	//编写一个 main 方法
    public static void main(String[] args) {
        Person p1 = new Person("king", 40);//第 1 个构造器
        Person p2 = new Person("tom");//第 2 个构造器
        Dog dog1 = new Dog();//使用的是默认的无参构造器
    }
}

class Dog {
    //如果程序员没有定义构造器，系统会自动给类生成一个默认无参构造器(也叫默认构造器)
}

class Person {
    String name;
    int age; //默认0
    
    //第 1 个构造器
	public Person(String pName, int pAge) {
        name = pName;
        age = pAge;
	}
    
   //第 2 个构造器, 只指定人名，不需要指定年龄
    public Person(String pName) {
    	name = pName;
    }
}
    
```

#### 对象创建的流程分析

![image-20240301090245190](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301090245190.png) 

####  this 关键字

简单的说，那个对象调用，this就代表那个对象。

1. this 关键字可以用来访问本类的属性、方法、构造器 
2. this 用于区分当前类的属性和局部变量 
3. **访问成员方法的语法：this.方法名(参数列表)**
4. **访问构造器语法：this(参数列表)**; 注意:只能在构造器中使用(即**只能在构造器中**访问另外一个构造器, **必须放在第一 条语句**)
5. this 不能在类定义的外部使用，只能在类定义的方法中使用

#### 本章作业

![image-20240301090818873](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301090818873.png) 

![image-20240301090832365](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301090832365.png) 

![image-20240301090848648](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301090848648.png) 

![image-20240301090904456](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301090904456.png) 

![image-20240301090915425](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301090915425.png) 

### 08：面向对象编程(中级)

#### 包

**作用：**

![image-20240302082554681](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302082554681.png) 

**语法：**

![image-20240302082641790](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302082641790.png) 

**本质：**

![image-20240302082724253](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302082724253.png) 

**命名：**

![image-20240302082824346](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302082824346.png) 

**细节：**

![image-20240302083016432](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302083016432.png) 

![image-20240302082932774](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302082932774.png) 

#### 访问修饰符

java 提供四种访问控制修饰符号，用于控制方法和属性(成员变量)的访问权限（范围）：

1) 公开级别:用 **public** 修饰,对外公开 
2) 受保护级别:用 **protected** 修饰,对子类和同一个包中的类公开 
3) 默认级别:**没有修饰符号**,向同一个包的类公开
4) 私有级别:用 **private** 修饰,只有类本身可以访问,不对外公开

![image-20240302094024820](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302094024820.png) 

**注意事项：**

![image-20240302083342543](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302083342543.png) 

#### 封装

![image-20240302103331943](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302103331943.png) 

**好处：**

![image-20240302103402079](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302103402079.png) 

**实现步骤：**

![image-20240302103503236](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302103503236.png) 

**将构造器和 setXxx 结合：**

![image-20240302103609067](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302103609067.png) 

#### 继承

继承可以解决代码复用,让我们的编程更加靠近人类思维.**当多个类存在相同的属性(变量)和方法时,可以从这些类中 抽象出父类**,在父类中定义这些相同的属性和方法，所有的子类不需要重新定义这些属性和方法，只需要通过 **extends 来 声明**继承父类即可。

![image-20240302103743228](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302103743228.png) 

**继承的基本语法：**

![image-20240302103821353](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302103821353.png) 

**好处：**

1) 代码的复用性提高了 
2) 代码的扩展性和维护性提高了

**继承细节：**

1. 子类继承了所有的属性和方法，非私有的属性和方法可以在子类直接访问, 但是私有属性和方法不能在子类直接访 问，要通过父类提供公共的方法去访问
2. 子类**必须调用父类的构造器**， 完成父类的初始化
3. 当创建子类对象时，不管使用子类的哪个构造器，**默认情况下总会去调用父类的无参构造器**，如果**父类没有提供无参构造器，则必须在子类的构造器中用 super 去指定**使用父类的哪个构造器完成对父类的初始化工作，否则，编译不会通过
4. 如果希望指定去调用父类的某个构造器，则显式的调用一下 : **super(参数列表）**
5. super 在使用时，**必须放在构造器第一行(super 只能在构造器中使用)**
6. super() 和 this() 都只能放在构造器第一行，因此这**两个方法不能共存在一个构造器**
7. java 所有类都是 Object 类的子类, Object 是所有类的基类
8. 父类构造器的调用不限于直接父类，将一直往上追溯直到 Object 类(顶级父类）
9. 子类最多只能继承一个父类(指直接继承)，即 **java 中是单继承机制**
10. 不能滥用继承，**子类和父类之间必须满足 is-a 的逻辑关系**

**继承的本质分析：**

![image-20240302104358566](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302104358566.png) 

**查找关系：**

1. 首先看子类是否有该属性
2. 如果子类有这个属性，并且可以访问，则返回信息
3. 如果子类没有这个属性，就看父类有没有这个属性(如果父类有该属性，并且可以访问，就返回信息..)
4. 如果父类没有就按照(3)的规则，继续找上级父类，直到 Object..

**内存布局：**

![image-20240302104638634](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302104638634.png) 

#### super关键字

super 代表父类的引用，用于访问**父类的属性、方法、构造器**

**语法：**

![image-20240302113723098](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302113723098.png) 

```java
System.out.println(n1);
System.out.println(this.n1);
//n1 和 this.n1 查找的规则是
//(1) 先找本类，如果有，则调用
//(2) 如果没有，则找父类(如果有，并可以调用，则调用)
//(3) 如果父类没有，则继续找父类的父类,整个规则，就是一样的,直到 Object 类
// 提示：如果查找属性的过程中，找到了，但是不能访问， 则报错, cannot access
// 如果查找属性的过程中，没有找到，则提示属性不存在
    
System.out.println(super.n1);
//找 n1 (super.n1) 的顺序是直接查找父类属性，其他的规则一样
```

**细节：**

![image-20240302114122709](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302114122709.png) 

#### super 和 this 的比较

![image-20240302114230453](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302114230453.png) 

#### 方法重写

![image-20240302114331887](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302114331887.png) 

**细节：**

![image-20240302114413515](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302114413515.png) 

**方法重写与方法重载区别：**

![image-20240302134050595](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302134050595.png) 

#### 多态

方法或对象具有多种形态。是面向对象的第三大特征，多态是建立在封装和继承基础之上的。

##### 多态的具体体现

1. 方法的多态：重写和重载体现多态
2. 对象的多态：

 ![image-20240302161158753](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302161158753.png)

##### 多态注意事项和细节

1. 多态的前提是：两个对象(类)存在继承关系

2. 多态的**向上转型**
   ![image-20240302161318650](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302161318650.png)

   为什么不能调用子类的特有成员？因为在编译阶段，能调用哪些成员,是由编译类型来决定的。

   最终运行效果看子类(运行类型)的具体实现, 即调用方法时，按照从子类(运行类型)开始查找方法，然后调用规则我前面我们讲的方法调用规则一致

3. 多态**向下转型**
   ![image-20240302161406048](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302161406048.png)

4. **instanceOf 比较操作符**，用于判断对象的**运行类型**是否为 XX 类型或 XX 类型的子类型

![image-20240302161851944](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302161851944.png) 

##### java 的动态绑定机制

![image-20240302162152620](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302162152620.png) 

##### 多态的应用

1. 多态数组：数组的定义类型为父类类型，里面保存的实际元素类型为子类类型
   应用实例:现有一个继承结构如下，要求创建 1 个 Person 对象、2 个 Student 对象和 2 个 Teacher 对象, 统一放在数组 中，并调用每个对象 say 方法

   ```java
   Person[] persons = new Person[5];
   
   persons[0] = new Person("jack", 20);
   persons[1] = new Student("mary", 18, 100);
   persons[2] = new Student("smith", 19, 30.1);
   persons[3] = new Teacher("scott", 30, 20000);
   persons[4] = new Teacher("king", 50, 25000);
   ```

2. 多态参数
   ![image-20240302162658189](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302162658189.png)

#### Object 类详解

##### equals 方法

==和 equals 的对比：

![image-20240302190357187](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302190357187.png) 

![image-20240303155917455](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303155917455.png)

##### hashCode 方法

![image-20240302190736043](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240302190736043.png) 

1. 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的
2. 两个引用，如果指向的是不同对象，则哈希值是不一样的 
3. 哈希值主要根据地址号来的，不能完全将哈希值等价于地址

##### toString 方法

1. 基本介绍：

   默认返回：全类名+@+哈希值的十六进制，【查看 Object 的 toString 方法】

   子类往往重写 toString 方法，用于返回对象的属性信息

2. 重写 toString 方法，打印对象或拼接对象时，都会自动调用该对象的 toString 形式

3. **当直接输出一个对象时，toString 方法会被默认的调用**, 比如 System.out.println(monster)； 就会默认调用 monster.toString()

##### finalize 方法

1. 当对象被回收时，系统自动调用该对象的 finalize 方法。子类可以重写该方法，做一些释放资源的操作
2. 什么时候被回收：当某个对象没有任何引用时，则 jvm 就认为这个对象是一个垃圾对象，就会使用垃圾回收机制来 销毁该对象，在销毁该对象前，会先调用 finalize 方法。 
3. 垃圾回收机制的调用，是由系统来决定(即有自己的 GC 算法), 也可以通过 **System.gc()** 主动触发垃圾回收机制
4.  **我们在实际开发中，几乎不会运用 finalize , 所以更多就是为了应付面试.**

#### 本章作业：

![image-20240303111746815](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303111746815.png) 

![image-20240303111800007](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303111800007.png) 

![image-20240303151844489](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303151844489.png) 

![image-20240303111843504](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303111843504.png) 

![image-20240303111906766](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303111906766.png) 

### 10：面向对象编程(高级)

#### 类变量和类方法

##### 类变量

![image-20240305155410347](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305155410347.png) 

**定义：**

![image-20240305155451552](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305155451552.png) 

**访问类变量:**

![image-20240305155627145](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305155627145.png) 

```java
class AA {
    public static void num;
}

AA.num;
//或者
new AA().num;
```

**细节：**

![image-20240305155841863](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305155841863.png) 

##### 类方法

![image-20240305160024564](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305160024564.png) 

![image-20240305160055714](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305160055714.png) 

如果我们希望不创建实例，也可以调用某个方法(即当做工具来使用），这时，把方法做成静态方法时非常合适。

**类方法经典的使用场景：**

![image-20240305160248348](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305160248348.png) 

**细节：**

![image-20240305160332732](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305160332732.png) 

#### main方法

**理解 main 方法：**

![image-20240305160726592](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305160726592.png) 

**特别提示：**

1) 在 main()方法中，我们可以直接调用 main 方法所在类的静态方法或静态属性。 
2) 但是，不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员

**在idea中传递参数：**

![image-20240305160928734](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305160928734.png) 

#### 代码块

##### 基本介绍

![image-20240305161018264](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305161018264.png) 

##### 基本语法

![image-20240305161102528](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305161102528.png) 

##### 代码块的好处

 ![image-20240305161233498](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305161233498.png) 

##### 代码块的细节讨论

![image-20240305161346185](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305161346185.png) 

![image-20240305161525158](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305161525158.png) 

![image-20240305161643324](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305161643324.png) 

![image-20240305161710575](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305161710575.png) 

#### 单例模式

**什么是设计模式：**

![image-20240305200508550](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305200508550.png) 

**什么是单例模式：**

![image-20240305200419112](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305200419112.png) 

##### **饿汉式：**

```java
//步骤[单例模式-饿汉式]
//1. 将构造器私有化
//2. 在类的内部直接创建对象(该对象是 static)
//3. 提供一个公共的 static 方法，返回 gf 对象
class GirlFriend {
	private String name;
    //2. 在类的内部直接创建对象(该对象是 static)
    private static GirlFriend gf = new GirlFriend("小红红");
    //1. 将构造器私有化
    private GirlFriend(String name) {
		System.out.println("構造器被調用.");
		this.name = name;
	}
    //3. 提供一个公共的 static 方法，返回 gf 对象
    public static GirlFriend getInstance() {
		return gf;
    }
}
```

##### **懒汉式：**

```java
//步骤[单例模式-懒式]
//1. 将构造器私有化
//2. 在类的内部定义一个对象(该对象是 static)
//3. 提供一个公共的 static 方法，返回 Cat 对象
//4. 只有当用户调用getInstance这个公用方法时，才会真正创建Cat对象
class Cat {
    private String name;
    public static int n1 = 999;
    //2. 在类的内部定义一个对象(该对象是 static)
    private static Cat cat ; //默认是 null
    //1. 将构造器私有化
    private Cat(String name) {
        this.name = name;
    }
    //3. 提供一个公共的 static 方法，返回 Cat 对象
    public static Cat getInstance() {
        if(cat == null) {//如果还没有创建cat对象，就创建一个
        	cat = new Cat("小可愛");
        }
        return cat;
   	}
}
```

##### 饿汉式 VS 懒汉式

![image-20240305201445529](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305201445529.png) 

#### final关键字

**基本介绍：**

![image-20240305205312151](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305205312151.png) 

**细节：**

![image-20240305205404737](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305205404737.png) 

![image-20240305205506115](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240305205506115.png) 

#### 抽象类

**理解：**

![image-20240306085546788](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306085546788.png) 

父类方法不确定性的问题 ===> 考虑将该方法设计为抽象(abstract)方法 ===> 所谓抽象方法就是没有实现的方法 ===> 所谓没有实现就是指，没有方法体 ===> 当一个类中存在抽象方法时，需要将该类声明为 abstract 类 ==> 一般来说，抽象类会被继承，有其子类来实现抽象方法

**介绍：**

![image-20240306085841810](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306085841810.png) 

**细节：**

![image-20240306085933576](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306085933576.png) 

![image-20240306090007586](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306090007586.png) 

![image-20240306090038794](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306090038794.png) 

不能用static是因为static声明的静态成员可以直接被类调用，而抽象类就只有被继承的能力。

#### 模板设计模式

**基本介绍：**

![image-20240306093306421](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306093306421.png) 

**模板设计模式能解决的问题：**

![image-20240306093354767](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306093354767.png) 

```java
abstract public class Template { //抽象类-模板设计模式
    public abstract void job();//抽象方法
    
    public void calculateTime() {//实现方法，调用 job 方法
        //得到开始的时间
        long start = System.currentTimeMillis();
        job(); //动态绑定机制
        //得的结束的时间
        long end = System.currentTimeMillis();
        System.out.println("任务执行时间 " + (end - start));
  	}
}
 
class AA extends Template {
    @Override
    public void job() { //实现 Template 的抽象方法 job
        long num = 0;
        for (long i = 1; i <= 800000; i++) {
        	num += i;
        }
    }
}

class BB extends Template {
    @Override
    public void job() { //实现 Template 的抽象方法 job
        long num = 0;
        for (long i = 1; i <= 600000; i++) {
        	num += i;
        }
    }
}      
```

#### 接口

##### 为什么有接口

![image-20240306105841413](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306105841413.png) 

##### 基本介绍

![image-20240306105933451](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306105933451.png) 

##### 注意事项和细节

![image-20240306110040799](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306110040799.png) 

![image-20240306110118438](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306110118438.png) 

##### 实现接口 vs 继承

![image-20240306110244415](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306110244415.png) 

小结: 

1. 当子类继承了父类，就自动的拥有父类的功能

2. 如果子类需要扩展功能，可以通过实现接口的方式扩展.（可以理解 实现接口 是 对 java 单继承机制的一种补充）

```java
//猴子
class Monkey {
    public String name;
    public Monkey(String name) {
    	this.name = name;
    }
    public void climbing() {
    System.out.println(name + " 会爬树...");
    }
}
//鱼
interface Fishable {
	void swimming();
}
//鸟
interface Birdable {
	void flying();
} 

//小猴子继承了猴子的爬树，小猴子实现了与鱼的游泳和鸟的飞翔
class LittleMonkey extends Monkey implements Fishable,Birdable {
    public LittleMonkey(String name) {
		super(name);
	}
    @Override
    public void swimming() {
    	System.out.println(getName() + " 通过学习，可以像鱼儿一样游泳...");
    }
    @Override
    public void flying() {
    	System.out.println(getName() + " 通过学习，可以像鸟儿一样飞翔...");
    }
}
```

![image-20240306110811731](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306110811731.png) 

##### 接口的多态特性

![image-20240306110901095](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306110901095.png) 

##### 接口练习

```java
interface A {
	int x = 0;
}
class B {
	int x = 1;
}
class C extends B implements A {
    public void pX() {
		System.out.println(x); //错误，x是A的还是B的，模糊
        // 改
        System.out.println(A.x + " " + super.x);
        //可以明确的指定 x
        //访问接口的 x 就使用 A.x
        //访问父类的 x 就使用 super.x
    }
}
```

#### 内部类

1. 如果**定义在局部位置**(方法中/代码块) :
   1. 局部内部类（有类名）
   2. 匿名内部类（**没有类名，重点！！！**）

2. 定义在成员位置
   1. 成员内部类
   2. 静态内部类（有static修饰）

##### 基本介绍

![image-20240306143853579](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306143853579.png) 

##### 基本语法

![image-20240306143954630](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306143954630.png) 

##### 局部内部类

![image-20240306144054269](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306144054269.png) 

```java
class Outer02 {//外部类
    private int n1 = 100;
    private void m2() {
    	System.out.println("Outer02 m2()");
	}//私有方法
    public void m1() {//方法
        ////2.不能添加访问修饰符,但是可以使用 final 修饰
        final class Inner02 {//局部内部类(本质仍然是一个类)
            private int n1 = 800;
            public void f1() {
                //7.如果外部类和局部内部类的成员重名时,使用 外部类名.this.成员去访问
                System.out.println("n1=" + n1 + " 外部类的 n1=" + Outer02.this.n1);
                //4.局部内部类可以直接访问外部类的成员
                m2();
            }
            //5.外部类在方法中，可以创建 Inner02 对象，然后调用方法即可
            Inner02 inner02 = new Inner02;
            inner02.f1();
        }
    }
}     
```

##### 匿名内部类

![image-20240306145355085](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306145355085.png) 

![image-20240306145446514](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306145446514.png) 

```java
//需求是Tiger类只是使用一次，后面再不使用,可以使用匿名内部类来简化开发

class Outer04 { //外部类
	private int n1 = 10;//属性
    public void method() {//方法
        //基于接口的匿名内部类
        IA tiger = new IA() {
        //tiger 的编译类型 是 IA，
        //tiger 的运行类型是匿名内部类 Outer04$1(系统自动生成的)
            @Override
            public void cry() {
            	System.out.println("老虎叫唤...");
            }
        }
        //jdk 底层在创建匿名内部类 Outer04$1,然后立即马上就创建了 Outer04$1,并把地址返回给tiger
      	//**********************************************
        //类似于
        class Outer04$1 implements IA {
            @Override
            public void cry() {
            	System.out.println("老虎叫唤...");
            }
     	}
        //**********************************************
        System.out.println("tiger 的运行类型=" + tiger.getClass())
    	tiger.cry();
    }
}
   
interface IA {//接口
	public void cry();
} 
```

**最佳实践：当做实参直接传递，简洁高效。**

```java
public class InnerClassExercise01 {
	public static void main(String[] args) {
        //当做实参直接传递，简洁高效
        f1(new IL() {
        	@Override
        	public void show() {
       			System.out.println("这是一副名画~~...");
        	}
		});
    }
}
//接口
interface IL {
	void show();
}
```

##### 成员内部类

![image-20240306151747626](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306151747626.png) 

![image-20240306151802370](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306151802370.png) 

![image-20240306151831810](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306151831810.png) 

**外部其他类 使用成员内部类：**

```java
class Outer08 { //外部类
	public class Inner08 {//成员内部类
        public void say() {
            System.out.println("你好");
        }
    }
}
public class Test {//外部类其他类
    public static void main(String[] args) {
        //方式 1
		//outer08.new Inner08(); 相当于把 new Inner08()当成outer08的成员
        // 这就是一个语法，不要特别的纠结
        Outer08.Inner08 inner08 = outer08.new Inner08();
        inner08.say();
        //方式 2
		//编写一个方法，可以返回成员内部类的对象实例.
    }
}
```

##### 静态内部类

![image-20240306151901882](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240306151901882.png) 

**外部其他类 使用静态内部类：**

```java
class Outer10 { //外部类
    static class Inner10 {
        public void say() {
            System.out.println("你好");
        }
    }
}
public class Test {//外部类其他类
    public static void main(String[] args) {
        //方式 1
		//因为静态内部类，是可以通过类名直接访问(前提是满足访问权限)
        Outer10.Inner10 inner10 = new Outer10.Inner10();
        inner10.say();
        //方式 2
		//编写一个方法，可以返回静态内部类的对象实例.
    }
}
```

### 11：枚举和注解

#### 枚举

1) 枚举对应英文(enumeration, 简写 enum) 
2) 枚举是一组常量的集合
3) 可以这里理解：枚举属于一种特殊的类，里面只包含一组有限的特定的对象。

**枚举的二种实现方式：**

1) 自定义类实现枚举 
2) 使用 enum 关键字实现枚举

##### 增强for循环

```java
int[] nums = {1,2,3,4,5,6};

//执行流程是 依次从 nums 数组中取出数据，赋给 i, 如果取出完毕，则退出 for
for (int i : nums) {
    System.out.println("i=" + i);
}
```

##### 自定义枚举

![image-20240307101028951](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307101028951.png) 

**步骤：**

1. 将构造器私有化,目的防止 直接 new 
2. 去掉 setXxx 方法, 防止属性被修该
3. 在 Season 内部，直接创建固定的对象 
4. 优化，可以加入 final 修饰符

```java
class Season {
    private String name;
    private String desc;//描述
    
    //3.在 Season 内部，直接创建固定的对象 
    //4.优化，可以加入 final 修饰符
    public static final Season SPRING = new Season("春天", "温暖");
    public static final Season WINTER = new Season("冬天", "寒冷");
    public static final Season AUTUMN = new Season("秋天", "凉爽");
    public static final Season SUMMER = new Season("夏天", "炎热");
    
    //1.将构造器私有化,目的防止 直接 new 
    private Season(String name, String desc) {
        this.name = name;
        this.desc = desc;
	}
```

**进行自定义类实现枚举，有如下特点：**

1) 构造器私有化 
2) 本类内部创建一组对象[四个 春夏秋冬]
3) 对外暴露对象（通过为对象添加 public final static 修饰符）
4) 可以提供 get 方法，但是不要提供 set

##### enum 枚举

###### enum 来实现枚举

1. 使用关键字 enum 替代 class
2. public static final Season SPRING = new Season("春天", "温暖")   ====》**SPRING("春天", "温暖")** 解读 常量名(实参列表) 
3. **如果有多个常量(对象)， 使用 ,号间隔即可**
4.  **常量对象的定义要写在最前面** 
5. 如果我们使用的是无参构造器，创建常量对象，则可以省略 **括号（）**

```java
//1.使用关键字 enum 替代 class
enum Season2 {
    //2.public static final Season SPRING = new Season("春天", "温暖")   ====》SPRING("春天", "温暖")
    //解读 常量名(实参列表) 
	SPRING("春天", "温暖"), 
    WINTER("冬天", "寒冷"), //3.如果有多个常量(对象)， 使用 ,号间隔
    AUTUMN("秋天", "凉爽"),
    SUMMER("夏天", "炎热");
    //4. 常量对象的定义要写在最前面
    
    //What() ==> what;  5.如果我们使用的是无参构造器，创建常量对象，则可以省略 括号（）
    
    private String name;
	private String desc;//描述
    
    //默认是私有的
    Season2(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }
    
    private Season2() {//无参构造器
	}
}
```

###### **注意事项**

1. 当我们使用 enum 关键字开发一个枚举类时，**默认会继承 Enum 类**, **而且是一个 final 类**,可以使用 javap 工 具来演示 
2. 传统的 public static final Season2 SPRING = new Season2("春天", "温暖"); **简化成 SPRING("春天", "温暖")**， 这里必须知道，它调用的是哪个构造器. 
3. 如果使用无参构造器 创建 枚举对象，则实参列表和小括号都可以省略
4. 当有多个枚举对象时，使用,间隔，**最后有一个分号结尾** 
5. **枚举对象必须放在枚举类的行首**

![image-20240307102849743](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307102849743.png) 

###### enum 常用方法

说明：使用关键字 enum 时，会隐式继承 Enum 类, 这样我们就可以使用 Enum 类相关的方法。

1) **toString**:Enum 类已经重写过了，返回的是当前对象 名,子类可以重写该方法，用于返回对象的属性信息 
2) **name**：返回当前对象名（常量名），子类中不能重写
   System.out.println(==autumn.name()==);
3) **ordinal**：返回当前对象的位置号，默认从 0 开始
   System.out.println(==autumn.ordinal()==);
4) **values**：返回当前枚举类中所有的常量
   Season2[] values = ==Season2.values()==;
5) **valueOf**：将字符串转换成枚举对象，要求字符串必须 为已有的常量名，否则报异常！
   Season2 autumn1 = ==Season2.valueOf("AUTUMN")==;
6) **compareTo**：比较两个枚举常量，比较的就是编号！
   System.out.println(==Season2.AUTUMN.compareTo(Season2.SUMMER)==)

###### enum 实现接口

1. 使用 enum 关键字后，就不能再继承其它类了，**因为 enum 会隐式继承 Enum，而 Java 是单继承机制**。 

2. 枚举类和普通类一样，可以实现接口，如下形式。 
   **enum 类名 implements 接口 1，接口 2{}**

   ```java
   interface IPlaying {//接口
   	public void playing();
   }
   
   enum Music implements IPlaying {//枚举类实现接口
       CLASSICMUSIC;
       @Override
       public void playing() {
       	System.out.println("播放好听的音乐...");
       }
   }
   ```

#### 注解

##### 注解的理解

1) 注解(Annotation)也被称为元数据(Metadata)，**用于修饰解释** 包、类、方法、属性、构造器、局部变量等数据信息。
2) 和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，**相当于嵌入在代码中的补充信息**。
3) 在 JavaSE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。
4) 在 JavaEE 中注解占据了更重要的角 色，例如用来配置应用程序的任何切面，代替 java EE 旧版中所遗留的繁冗代码和 XML 配置等。

##### Annotation 分类

使用 Annotation 时要在其前面增加 @ 符号, 并把该 Annotation 当成一个修饰符使用。用于修饰它支持的程序元素

三个基本的 Annotation: 

1. **@Override**: 限定某个方法，是重写父类方法, 该注解只能用于方法
2. **@Deprecated**: 用于表示某个程序元素(类, 方法等)已过时
3. **@SuppressWarnings**: 抑制编译器警告

##### @Override

![image-20240307105801970](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307105801970.png) 

![image-20240307105835684](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307105835684.png) 

##### @Deprecated

@Deprecated: 用于表示某个程序元素(类, 方法等)已过时

![image-20240307105919709](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307105919709.png) 

##### @SuppressWarnings

@SuppressWarnings: 抑制编译器警告

![image-20240307110004803](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307110004803.png) 

##### 元注解的基本介绍

**JDK 的元 Annotation 用于修饰其他 Annotation** 

元注解： 本身作用不大，讲这个原因希望同学们，看源码时，可以知道他是干什么.

1) Retention //指定注解的作用范围，三种 SOURCE,CLASS,RUNTIME 
2) Target // 指定注解可以在哪些地方使用 
3) Documented //指定该注解是否会在 javadoc 体现 
4) Inherited //子类会继承父类注解

#### 本章作业

![image-20240307110345574](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307110345574.png) 

![image-20240307110359777](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307110359777.png) 

### 12：异常

#### 异常介绍

![image-20240307174052378](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307174052378.png) 

#### 异常体系图

![image-20240307174200505](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307174200505.png) 

![image-20240307174225877](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307174225877.png) 

#### 运行时异常

对于运行时异常，可以不作处理，因为这类异常很普遍，若全处理可能会对程序的可读性和运行效率产生影响。

**常见的运行时异常：**

1) NullPointerException 空指针异常 
   当应用程序试图在**需要对象的地方使用null时**，抛出该异常
2) ArithmeticException 数学运算异常 
   当出现异常的运算条件时，抛出此异常。例如，**一个整数“除以零”**时，抛出此类的一个实例
3) ArrayIndexOutOfBoundsException 数组下标越界异常
   **用非法索引访问数组时抛出的异常**。如果索引为负或大于等于数组大小，则该索引为非法索引
4) ClassCastException 类型转换异常 
   当**试图将对象强制转换为不是实例的子类时**，抛出该异常，例如：在向上转型和向下转型的时候
5) NumberFormatException 数字格式不正确异常
   当应用程序**试图将字符串转换成一种数值类型**，但该字符串不能转换为适当格式时，抛出该异常

#### 编译异常

编译异常是指在编译期间，就必须处理的异常，否则代码不能通过编译。

**常见的编译异常：**

![image-20240307175609545](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307175609545.png) 

#### 异常处理

异常处理就是当异常发生时，对异常处理的方式。

**异常处理的方式：**

1. try-catch-finally

2. throws

   ![image-20240307175805347](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307175805347.png) 

##### try-catch 异常处理

![image-20240307175857673](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307175857673.png) 

**try-catch 方式处理异常说明：**

![image-20240307180020062](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180020062.png) 

**try-catch 方式处理异常-注意事项：**

![image-20240307180104995](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180104995.png) 

![image-20240307180120345](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180120345.png) 

![image-20240307180148754](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180148754.png) 

##### throws异常处理

**介绍：**

![image-20240307180240788](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180240788.png) 

![image-20240307175938523](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307175938523.png) 

**使用细节：**

![image-20240307180330439](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180330439.png) 

#### 自定义异常

**基本概念：**

![image-20240307180428334](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180428334.png) 

**步骤：**

![image-20240307180446022](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180446022.png) 

```java
class AgeException extends RuntimeException {
    public AgeException(String message) {//构造器
		super(message);
	}
}

throw new AgeException("年龄需要在 18~120 之间");
```

#### throw 和 throws 区别

![image-20240307180635727](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180635727.png) 

#### 本章作业

![image-20240307180731664](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180731664.png) 

![image-20240307180748657](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240307180748657.png) 

### 13：常用类

#### 包装类

##### 包装类的分类

1) 针对八种基本数据类型相应的引用类型—包装类 
2) 有了类的特点，就可以调用类中的方法。

![image-20240308170618202](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308170618202.png) 

##### 包装类和基本数据

![image-20240308170741778](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308170741778.png) 

**手动装箱：**

```java
//手动装箱 int->Integer
int n1 = 100;
Integer integer = new Integer(n1);
Integer integer1 = Integer.valueOf(n1);

//手动拆箱 Integer -> int
int i = integer.intValue();
```

**自动装箱：**

```java
//jdk5 后，就可以自动装箱和自动拆箱
//自动装箱 int->Intege
int n2 = 200;
Integer integer2 = n2;//底层使用的是 Integer.valueOf(n2)

//自动拆箱 Integer->int
int n3 = integer2; //底层仍然使用的是 intValue()方法
```

##### 包装类和 String 类

```java
//包装类(Integer)->String
Integer i = 100;//自动装箱
//方式 1
String str1 = i + "";
//方式 2
String str2 = i.toString();
//方式 3
String str3 = String.valueOf(i);

//String -> 包装类(Integer)
String str4 = "12345";
Integer i2 = Integer.parseInt(str4);//使用到自动装箱
Integer i3 = new Integer(str4);//构造
```

####  String 类

##### String 类的理解

![image-20240308171619508](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308171619508.png) 

![image-20240308171701632](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308171701632.png) 

```java
//1.String 对象用于保存字符串，也就是一组字符序列

//2. "jack" 字符串常量, 双引号括起的字符序列

//3. 字符串的字符使用 Unicode 字符编码，一个字符(不区分字母还是汉字)占两个字节

//4. String 类有很多构造器，构造器的重载
// 常用的有 String s1 = new String(); //
//String s2 = new String(String original);
//String s3 = new String(char[] a);
//String s4 = new String(char[] a,int startIndex,int count)
//String s5 = new String(byte[] b)

//5. String 类实现了接口 Serializable【String 可以串行化:可以在网络传输】，接口 Comparable [String 对象可以比较大小]

//6. String 是 final 类，不能被其他的类继承

//7. String 有属性 private final char value[]; 用于存放字符串内容

//8. 一定要注意：value 是一个 final 类型， 不可以修改(需要功力)：即 value 不能指向新的地址，但是单个字符内容是可以变
```

##### 创建 String 对象

![image-20240308172017598](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172017598.png) 

**两种创建 String 对象的区别：**

![image-20240308172052241](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172052241.png) 

![image-20240308172114853](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172114853.png) 

##### String 类的常见方法

**String缺点：**

![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172216821.png) 

**String 类的常见方法一览：**

![image-20240308172255299](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172255299.png) 

![image-20240308172331604](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172331604.png) 

#####  StringBuffer 类

###### **基本介绍：**

![image-20240308172504823](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172504823.png) 

```java
//1. StringBuffer 的直接父类 是 AbstractStringBuilder

//2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化

//3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final该 value 数组存放 字符串内容，引出存放在堆中的

//4. StringBuffer 是一个 final 类，不能被继承

//5. 因为 StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除)

// 不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String
StringBuffer stringBuffer = new StringBuffer("hello");
```

######  **String VS StringBuffer：**

![image-20240308172848918](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172848918.png) 

###### **String 和 StringBuffer 相互转换：**

![image-20240308172914816](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308172914816.png) 

```java
//看 String——>StringBuffer
String str = "hello tom";
//方式 1 使用构造器
//注意： 返回的才是 StringBuffer 对象，对 str 本身没有影响
StringBuffer stringBuffer = new StringBuffer(str);
//方式 2 使用的是 append 方法
StringBuffer stringBuffer1 = new StringBuffer();
stringBuffer1 = stringBuffer1.append(str);

//看 StringBuffer ->String
StringBuffer stringBuffer3 = new StringBuffer("韩顺平教育");
//方式 1 使用 StringBuffer 提供的 toString 方法
String s = stringBuffer3.toString();
//方式 2: 使用构造器来搞定
String s1 = new String(stringBuffer3)
```

######  StringBuffer 类常见方法

```java
StringBuffer s = new StringBuffer("hello");
//增
s.append(',');// "hello,
s.append("张三丰");//"hello,张三丰"
s.append("赵敏").append(100).append(true).append(10.5);//"hello,张三丰赵敏 100true10.5"

//删
s.delete(11, 14);//"hello,张三丰赵敏 true10.5

//改
s.replace(9, 11, "周芷若");//"hello,张三丰周芷若 true10.5

//插
s.insert(9, "赵敏");//"hello,张三丰赵敏周芷若 true10.5

//长度
s.length()
```

##### StringBuilder 类

###### **基本介绍**

![image-20240308174956149](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308174956149.png) 

```java
//1. StringBuffer 的直接父类 是 AbstractStringBuilder

//2. StringBuffer 实现了 Serializable, 即 StringBuffer 的对象可以串行化

//3. 在父类中 AbstractStringBuilder 有属性 char[] value,不是 final该 value 数组存放 字符串内容，引出存放在堆中的

//4. StringBuffer 是一个 final 类，不能被继承

//5. 因为 StringBuffer 字符内容是存在 char[] value, 所有在变化(增加/删除),不用每次都更换地址(即不是每次创建新对象)， 所以效率高于 String

StringBuffer stringBuffer = new StringBuffer("hello");

//6. StringBuilder 的方法，没有做互斥的处理,即没有 synchronized 关键字,因此在单线程的情况下使用
```

######  String、StringBuffer 和 StringBuilder 的比较

![image-20240308175326835](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308175326835.png) 

###### String、StringBuffer 和 StringBuilder 的选择

![image-20240308175436067](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240308175436067.png) 

####  Math 类

Math 类包含用于执行基本数学运算的方法，如初等指数、对数、平方根和三角函数。

**方法一览(均为静态方法)：**

```java
//1.abs 绝对值
int abs = Math.abs(-9);
System.out.println(abs);//9
//2.pow 求幂
double pow = Math.pow(2, 4);//2 的 4 次方
System.out.println(pow);//16
//3.ceil 向上取整,返回>=该参数的最小整数(转成 double);
double ceil = Math.ceil(3.9);
System.out.println(ceil);//4.0
//4.floor 向下取整，返回<=该参数的最大整数(转成 double)
double floor = Math.floor(4.001);
System.out.println(floor);//4.0
//5.round 四舍五入 Math.floor(该参数+0.5)
long round = Math.round(5.51);
System.out.println(round);//6
//6.sqrt 求开方
double sqrt = Math.sqrt(9.0);
System.out.println(sqrt);//3.0

//7.random 求随机数
// random 返回的是 0 <= x < 1 之间的一个随机小数
// 思考：请写出获取 a-b 之间的一个随机整数,a,b 均为整数 ，比如 a = 2, b=7
// 即返回一个数 x 2 <= x <= 7
// 老韩解读 Math.random() * (b-a) 返回的就是 0 <= 数 <= b-a
// (1) (int)(a) <= x <= (int)(a + Math.random() * (b-a +1) )
// (2) 使用具体的数给小伙伴介绍 a = 2 b = 7
// (int)(a + Math.random() * (b-a +1) ) = (int)( 2 + Math.random()*6)
// Math.random()*6 返回的是 0 <= x < 6 小数
// 2 + Math.random()*6 返回的就是 2<= x < 8 小数

//8.max , min 返回最大值和最小值
int min = Math.min(1, 9);
int max = Math.max(45, 90);
System.out.println("min=" + min);
System.out.println("max=" + max);
```

####  Arrays 类

**Arrays 类常见方法：**

![image-20240309110000976](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309110000976.png) 

![image-20240309110031519](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309110031519.png) 

```java
3)binarySearch 通过二分搜索法进行查找，要求必须排好
//1. 使用 binarySearch 二叉查找
//2. 要求该数组是有序的. 如果该数组是无序的，不能使用 binarySearch
//3. 如果数组中不存在该元素，就返回 return -(low + 1) // key not found.
```



#### System 类

![image-20240309110213285](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309110213285.png) 

```java
2）arraycopy()
// srcPos： 从源数组的哪个索引位置开始拷贝
// dest : 目标数组，即把源数组的数据拷贝到哪个数组
// destPos: 把源数组的数据拷贝到 目标数组的哪个索引
// length: 从源数组拷贝多少个数据到目标数组
```

#### 大数类

**BigInteger 、BigDecimal 类：**

![image-20240309110808224](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309110808224.png) 

**常见方法：**注意这些大数类不能直接+-*/哦，要调用方法

![image-20240309110839015](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309110839015.png) 

```java
long l = 23788888899999999999999999999l; // 编译会报错
BigInteger bigInteger = new BigInteger("23788888899999999999999999999");
System.out.println(bigInteger);

//1. 在对 BigInteger 进行加减乘除的时候，需要使用对应的方法，不能直接进行 + - * /
//2. 可以创建一个 要操作的 BigInteger 然后进行相应操作
BigInteger add = bigInteger.add(bigInteger2);

//当我们需要保存一个精度很高的数时，double 不够
double d = 1999.11111111111999999999999977788d; //输出时，会截断后面的很多小数
BigDecimal bigDecimal = new BigDecimal("1999.11111111111999999999999977788");

//1. 如果对 BigDecimal 进行运算，比如加减乘除，也需要使用对应的方法
//2. 创建一个需要操作的 BigDecimal 然后调用相应的方法即可
System.out.println(bigDecimal.divide(bigDecimal2));//可能抛出异常 ArithmeticExceptio
//在调用 divide 方法时，指定精度即可. BigDecimal.ROUND_CEILING
//如果有无限循环小数，就会保留 分子 的精度
System.out.println(bigDecimal.divide(bigDecimal2, BigDecimal.ROUND_CEILING))
```

#### 日期类

#####  第一代日期类

![image-20240309111356647](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309111356647.png) 

```java
//1. 获取当前系统时间
//2. 这里的 Date 类是在 java.util 包
//3. 默认输出的日期格式是国外的方式, 因此通常需要对格式进行转换

Date d1 = new Date(); 
Date d2 = new Date(9234567);  //通过指定毫秒数得到时间

//1. 创建 SimpleDateFormat 对象，可以指定相应的格式
//2. 这里的格式使用的字母是规定好，不能乱写
SimpleDateFormat sdf = new SimpleDateFormat("yyyy 年 MM 月 dd 日 hh:mm:ss E");
String format = sdf.format(d1); // format:将日期转换成指定格式的字符串
System.out.println("当前日期=" + format);
```



#####  第二代日期类

![image-20240309111430624](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309111430624.png) 

```java
//1. Calendar 是一个抽象类， 并且构造器是 private
//2. 可以通过 getInstance()
//3. 提供大量的方法和字段提供给程序员
//4. Calendar 没有提供对应的格式化的类，因此需要程序员自己组合来输出(灵活)
//5. 如果我们需要按照 24 小时进制来获取时间， Calendar.HOUR ==改成=> Calendar.HOUR_OF_DAY

Calendar c = Calendar.getInstance();
System.out.println("c=" + c);

System.out.println("年：" + c.get(Calendar.YEAR));
// 这里为什么要 + 1, 因为 Calendar 返回月时候，是按照 0 开始编号
System.out.println("月：" + (c.get(Calendar.MONTH) + 1));
//Calender 没有专门的格式化方法，所以需要程序员自己来组合显示
System.out.println(c.get(Calendar.YEAR) + "-" + (c.get(Calendar.MONTH) + 1) + "-" +
					c.get(Calendar.DAY_OF_MONTH) +" " + c.get(Calendar.HOUR_OF_DAY) + ":" + 									c.get(Calendar.MINUTE) + ":" + c.get(Calendar.SECOND) )
```

#####  第三代日期类

**前两代的不足：**

![image-20240309112129814](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309112129814.png) 

**第三代日期类：**

![image-20240309112237443](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309112237443.png) 

```java
//1. 使用 now() 返回表示当前日期时间的 对象
LocalDateTime ldt = LocalDateTime.now(); //LocalDate.now();//LocalTime.now()
System.out.println(ldt);

//2. 使用 DateTimeFormatter 对象来进行格式化
// 创建 DateTimeFormatter 对象
DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
String format = dateTimeFormatter.format(ldt);
System.out.println("格式化的日期=" + format);

System.out.println("年=" + ldt.getYear());
System.out.println("月=" + ldt.getMonth());
System.out.println("月=" + ldt.getMonthValue());
System.out.println("日=" + ldt.getDayOfMonth());
System.out.println("时=" + ldt.getHour());
System.out.println("分=" + ldt.getMinute());
System.out.println("秒=" + ldt.getSecond());

//3.提供 plus 和 minus 方法可以对当前时间进行加或者减
//看看 890 天后，是什么时候 把 年月日-时分秒
LocalDateTime localDateTime = ldt.plusDays(890);
//看看在 3456 分钟前是什么时候，把 年月日-时分秒
LocalDateTime localDateTime2 = ldt.minusMinutes(3456);
```

#####  DateTimeFormatter

![image-20240309112551648](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309112551648.png) 

#####  Instant 时间戳

![image-20240309112619261](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309112619261.png) 

#### 本章作业

![image-20240309112659936](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309112659936.png) 

![image-20240309112726941](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309112726941.png)  

### 14：集合

#### 数组的缺点

前面我们保存多个数据使用的是数组，而数组有不足的地方

![image-20240309162809195](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309162809195.png) 

#### 集合

**介绍：**

![image-20240309162853015](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309162853015.png) 

**集合框架体系：**

Java 的集合类很多，主要分为两大类，集合主要是两组(**单列集合** , **双列集合**），Collection 接口有两个重要的子接口 **List** 和**Set** , 他们的实现子类都是单列集；Map 接口的实现子类 是双列集合，存放的 **K-V**

1. **Collection**

   ![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309162947303.png) 

2. **Map**

   ![image-20240309163045641](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309163045641.png) 

#### Collection 接口

#####  **特点**

![image-20240309163352481](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309163352481.png) 

##### 使用 Iterator遍历

![image-20240309163614699](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309163614699.png) 

![image-20240309163647889](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309163647889.png) 

![image-20240309163713779](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309163713779.png) 

```java
Collection col = new ArrayList();
col.add(new Book("三国演义", "罗贯中", 10.1));
col.add(new Book("小李飞刀", "古龙", 5.1));
col.add(new Book("红楼梦", "曹雪芹", 34.6));

//1. 先得到 col 对应的 迭代器
Iterator iterator = col.iterator();
//2. 使用 while 循环遍历
while (iterator.hasNext()) {//判断是否还有数据
    Object obj = iterator.next();    //返回下一个元素，类型是 Object
    System.out.println("obj=" + obj);
}

//3. 当退出 while 循环后 , 这时 iterator 迭代器，指向最后的元素
iterator.next();//NoSuchElementException

//4. 如果希望再次遍历，需要重置我们的迭代器
iterator = col.iterator();
```

##### 使用增强for 遍历

![image-20240309164237070](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309164237070.png) 

#### List 接口

 **List 接口基本介绍：**

![image-20240309164428358](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309164428358.png) 

**List 的三种遍历方式：**

![image-20240309164555204](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309164555204.png) 

#### ArrayList类

#####  ArrayList 注意事项

![image-20240309164720678](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309164720678.png) 

##### 底层操作机制

![image-20240309164804936](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309164804936.png) 

##### 源码分析

![image-20240309165014622](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309165014622.png)

#### Vector类

**Vector 的基本介绍:**

![image-20240309165133485](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309165133485.png) 

**Vector 和 ArrayList 的比较:**

![image-20240309165240707](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309165240707.png) 

#### LinkedList类

 **LinkedList说明：**

![image-20240309165344385](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309165344385.png) 

**LinkedList 的底层操作机制：**

![image-20240309165456367](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309165456367.png) 

**ArrayList 和 LinkedList 比较：**

![image-20240309165557406](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240309165557406.png) 























## IDE（集成开发环境）—IDEA

1. IDEA 全称 IntelliJ IDEA 
2. 在业界被公认为最好的 Java 开发工具 
3. IDEA 是 JetBrains 公司的产品，总部位于捷克的首都布拉格 
4. 除了支持 Java 开发，还支持 HTML，CSS，PHP，MySQL，Python 等

![image-20240301181316349](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301181316349.png) 

**版本：**IDEA 2020.2

### IDEA 常用快捷键

1. 删除当前行：默认是Ctrl + Y，改为**Ctrl + D**

2. 复制当前行：（搜索duplicate），改为**Ctrl + Alt + 向下箭头**

3. 代码补全：**Alt + /**

4. 添加注释和取消注释： **Ctrl + /** 

5. 导入该行需要的类：**Alt+Enter** 

6. 快速格式化代码： **Ctrl + Alt + L**

7. 快速运行程序：默认是Shift + F10 ，改为**Alt + R**
8. 生成构造器等：**Alt + Insert**
9. 查看一个类的层级关系： **Ctrl + H**
10. 将光标放在一个方法上，输入 **Ctrl + B** （或者**Ctrl + 鼠标左键**）, 可以定位到方法 
11. 自动的分配变量名 , 通过 在后面加 **.var** 
12. 异常处理快捷键：**Ctrl + Alt + t**
13. 查看快捷键的快捷键
14. ：**Ctrl + J**
15. 快速生成迭代器的while：**i t i t**
16. 增强for循环： **I（大写）**

### 自定义模板

![image-20240301183836222](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240301183836222.png) 

### 断点调试

**断点调试介绍：**

![image-20240303090429018](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303090429018.png) 

**断点调试的快捷键：**

**F7(跳入)** 

**F8(跳过)** 

**shift+F8(跳出)** 

**F9(resume,执行到下一个断点)**

（断点可以在 debug 过程中，动态的下断点）

# **前端笔记**

## HTML

##### 描述：

用于定义网络结构的基本技术

##### 基本语法：

<开始标签>	内容	<结束标签>

![image-20240115105017529](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115105017529.png)

##### 标签：

+ ###### **分区div**

  div是一个纯粹的容器，<div>元素在语义上不表示任何特定类型的内容。然而，其可以将内容分组，从而可以使用**class**或是**id**属性方便的定义内容的格式。

+ ###### **标题h1~h6**

  HTML `<h1>`–`<h6>` 标题 (Heading) 元素呈现了六个不同的级别的标题，`<h1>` 级别最高，而 `<h6>` 级别最低。

+ ###### **段落p**

   **`<p>`** 元素表示文本的一个段落。段落是块级元素。

+ ###### **图像img**

  <img> 元素将一张图像嵌入文档

  ![image-20240115110304202](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115110304202.png) 

  - `src` 属性是**必须的**，它包含了你想嵌入的图片的路径。
  - `alt` 属性包含一条对图像的文本描述，这不是强制性的。如果由于某种原因无法加载图像，普通浏览器也会在页面上显示 `alt` 属性中的备用文本：例如，网络错误、内容被屏蔽或链接过期。

+ ###### **列表ul/ol**

  **`<ul>`** 元素表示一系列无序的列表项目，通常渲染为项目符号列表。

  ![image-20240115110519215](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115110519215.png) 

  **`<ol>` **元素表示有序列表，通常渲染为一个带编号的列表。

  ![image-20240115110655736](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115110655736.png) 

+ ###### **超链接a**

  <a> 元素（或称锚元素）可以通过它的 href 属性创建通向其他网页、文件、电子邮件地址、同一页面内的位置或任何其他 URL 的超链接。

  <a> 中的内容应该指明链接的目标。如果存在 href 属性，当 <a> 元素聚焦时按下回车键就会激活它。

  <a>中的href属性可以使用**文本片段**链接到某一段文字：这时点击a标签会直接跳转到相应的标签

  ![image-20240115111039304](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115111039304.png) 

+ ###### **表单form**

  **`<form>` 元素**表示文档中的一个区域，此区域包含交互控件，用于向 Web 服务器提交信息。

  ```html
  action:处理表单提交的 URL。这个值可被 <button>、<input type="submit"> 或 <input type="image"> 元素上的 formaction 属性覆盖。
  method:浏览器使用这种 HTTP 方式来提交 表单。可能的值有：
  	post：指的是 HTTP POST 方法；表单数据会包含在表单体内然后发送给服务器。
      get：指的是 HTTP GET 方法；表单数据会附加在 action 属性的 URL 中，并以 '?' 作为分隔符，没有副作用 时使用这个方法。
  <form action="" method="get" class="form-example">
    <div class="form-example">
      <label for="name">Enter your name: </label>
      <input type="text" name="name" id="name" required />
    </div>
    <div class="form-example">
      <label for="email">Enter your email: </label>
      <input type="email" name="email" id="email" required />
    </div>
    <div class="form-example">
      <input type="submit" value="Subscribe!" />
    </div>
  </form>
  ```

   ![image-20240115111322271](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115111322271.png)

+ ###### **表格table**

  **table**元素表示表格数据——即在一个由包含数据的行和列组成的二维表格中呈现的信息。

  ```html
  <table>
    <thead>
      <tr>
        <th colspan="2">The table header</th>
      </tr>
    </thead>
    <tbody>
      <tr>
        <td>The table body</td>
        <td>with two columns</td>
      </tr>
    </tbody>
  </table>
  ```

  ![image-20240115111909442](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240115111909442.png) 

+ ###### **框架iframe**

​	**HTML 内联框架元素 (`<iframe>`)** ,它能够将另一个 HTML 页面嵌入到当前页面中。目前我还没有用到这个。

##### HTML5特性：

###### 语义化标签：

当接近要使用的标记时，问问自己，“什么元素最能描述/表示我要填充的数据？”例如，它是数据列表吗？有序或无序？是否是一篇具有章节和相关信息旁注的文章？它是否列出了定义？它是需要标题的图形还是图像？除了全局网站范围的页眉和页脚之外，它还应该有页眉和页脚吗？等等。

写语义标记的一些好处如下：

- 搜索引擎将其内容视为影响页面搜索排名的重要关键字。

- 比起搜索无休止的带有或不带有语义/命名空间类的 `div`，找到有意义的代码块显然容易得多。

- 语义命名反映了正确的自定义元素/组件命名。

- 常见的语义化元素

  ```html
  <article>
  <aside>
  <detiales>
  <figcaption>
  <figure>
  <footer>
  <header>
  <main>
  <mark>
  <nav>
  <section>
  <summary>
  <time>
  ```



## 前端基础知识

##### 互联网：

互联网（[internet](https://baike.baidu.com/item/internet/272794?fromModule=lemma_inlink)），又称国际网络，指的是[网络](https://baike.baidu.com/item/网络/143243?fromModule=lemma_inlink)与网络之间所串连成的庞大网络，这些网络以一组通用的[协议](https://baike.baidu.com/item/协议/13020269?fromModule=lemma_inlink)相连，形成逻辑上的单一巨大国际网络。

互联网始于1969年[美国](https://baike.baidu.com/item/美国/125486?fromModule=lemma_inlink)的[阿帕网](https://baike.baidu.com/item/阿帕网/1950726?fromModule=lemma_inlink)。通常[internet](https://baike.baidu.com/item/internet/272794?fromModule=lemma_inlink)泛指互联网，而Internet则特指[因特网](https://baike.baidu.com/item/因特网/114119?fromModule=lemma_inlink)。这种将[计算机网络](https://baike.baidu.com/item/计算机网络/18763?fromModule=lemma_inlink)互相联接在一起的方法可称作“网络互联”，在这基础上发展出覆盖全世界的全球性互联网络称互联网，即是互相连接一起的[网络结构](https://baike.baidu.com/item/网络结构/8259917?fromModule=lemma_inlink)。

##### 域名：

域名（英语：Domain Name），又称网域，是由一串用点分隔的名字组成的[互联网](https://baike.baidu.com/item/互联网/199186?fromModule=lemma_inlink)上某一台[计算机](https://baike.baidu.com/item/计算机/140338?fromModule=lemma_inlink)或计算机组的名称，用于在[数据传输](https://baike.baidu.com/item/数据传输/2987565?fromModule=lemma_inlink)时对计算机的定位标识（有时也指地理位置）。 [1]

由于[IP地址](https://baike.baidu.com/item/IP地址/150859?fromModule=lemma_inlink)不方便记忆并且不能显示地址组织的名称和性质，人们设计出了域名，并通过[域名系统](https://baike.baidu.com/item/域名系统/2251573?fromModule=lemma_inlink)（DNS，Domain Name System）来将域名和IP地址相互[映射](https://baike.baidu.com/item/映射/20402621?fromModule=lemma_inlink)，使人更方便地访问互联网，而不用去记住能够被机器直接读取的IP地址数串。

##### DNS：

DNS（Domain Name System）域名系统，是一个层次化、分散化的互联网连接资源命名系统。DNS 维护着一个[域名](https://developer.mozilla.org/zh-CN/docs/Glossary/Domain_name)列表以及与之相关联的资源（例如 IP 地址）。

DNS 最突出的功能是将易于记忆的域名（例如 mozilla.org）翻译成为数字化的 [IP 地址](https://developer.mozilla.org/zh-CN/docs/Glossary/IP_Address)（例如 151.106.5.172）；这一从域名到 IP 地址的映射过程被称为**DNS 查询**（DNS lookup）。与之对应，**DNS 反向查询**（rDNS）用来找到与 IP 地址对应的域名。

##### 服务器：

服务器是为用户（通常称为客户端）提供服务的软件或硬件。硬件而言的服务器是互联网上的共享计算机，通常性能强劲且位于数据中心。软件而言的服务器（一般是运行在硬件服务器上）是一种向客户端程序或向[用户界面](https://developer.mozilla.org/zh-CN/docs/Glossary/UI)提供服务的程序。

我们一般在局域网或广域网（如互联网）提供服务。传统上，客户端程序和服务器程序通过 [API](https://developer.mozilla.org/zh-CN/docs/Glossary/API) 传递信息进行连接，这种信息使用[协议](https://developer.mozilla.org/zh-CN/docs/Glossary/Protocol)编码。

举个例子：

- 连接到互联网的 Web 服务器向你的浏览器发送一个 [HTML](https://developer.mozilla.org/zh-CN/docs/Glossary/HTML) 文件，这样你就可以浏览页面。
- 用于文件、域名、邮件、打印机和传真机的局域网服务器。
- 数据中心的小型机、大型机和超算。

##### 浏览器：

**浏览器**是一种从 [Web](https://developer.mozilla.org/zh-CN/docs/Glossary/World_Wide_Web) 获取和显示页面的程序，并且让用户通过[超链接](https://developer.mozilla.org/zh-CN/docs/Glossary/Hyperlink)访问更多页面。浏览器是最常见的一种用户代理。

###### DOM事件流：

DOM(文档对象模型)结构是一个树型结构，当一个[HTML元素](https://baike.baidu.com/item/HTML元素/5983313?fromModule=lemma_inlink)产生一个事件时，该事件会在元素节点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为DOM事件流。

DOM同时支持两种事件模型：[捕获型事件](https://baike.baidu.com/item/捕获型事件/0?fromModule=lemma_inlink)和[冒泡型事件](https://baike.baidu.com/item/冒泡型事件/7508003?fromModule=lemma_inlink)，但是，捕获型事件先发生，冒泡型事件后发生。两种事件流会触发DOM中的所有对象，从[document对象](https://baike.baidu.com/item/document对象/6553996?fromModule=lemma_inlink)开始，也在document对象结束。

![image-20240225131301937](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240225131301937.png) 

###### 事件委托：

当冒泡和捕获同时存在时，事件触发顺序为：捕获->目标（small就是目标）->冒泡。事件委托，也叫事件代理，一般指的是利用事件冒泡，将一个或者一组DOM的事件处理程序，委托给其父级元素或者更外层元素。**可以通过只指定一个事件处理程序，就可以管理一批同类型的事件处理程序**。

例如：如果需要给列表项添加事件，当列表项数量过多时，会存在频繁操作DOM的情况；并且函数是引用类型, 需要堆内存来存储，占用大量空间。**通过事件委托，可以将事件绑定到其父级元素ul上，这样只需要操作一次DOM，不会引起频繁的重绘。**也不会占用大量的空间。

```html
<!-- 通过事件的具体属性实现通过事件委托也和直接绑定在li上一样的效果--><!DOCTYPE html>
<html lang="en">
<body>
  <ul id='father'>
    <li id="a">A</li>
    <li id="b">B</li>
    <li id="c">C</li>
    <li id="d">D</li>
  </ul>
  <script>
  father.addEventListener('click', function(e) {
    const event = e；
    const target = event.target；
    // 根据事件属性判断当前所在的DOM节点，不同节点处理不同的程序（主要通过e.target,在父节点上定义的事件，可以处理子节点）
    switch(target.id) {
      case "a":
        console.log('a');
        break;
      case "b":
        console.log('b');
        break;
      case "c":
        console.log("c");
        break;
      case "d":
        console.log("d");
        break;
      default:
        console.log('default');
    }
  })
  </script>
</body>
</html>
```

###### 浏览器加载顺序：

1. HTML解析完毕

2. 外部脚本和样式加载完毕

3. 脚本在文档内解析并执行

4. HTML DOM完全构造起来

5. 图片个外部内容加载

6. 网页完全加载

**1-4执行是很快的，5很慢**

###### 浏览器渲染过程：

渲染流程大致可以划分为五个过程：

1. 构建DOM

   <img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240121114811031.png" alt="image-20240121114811031" style="zoom:50%;" /> 

2. 构建CSSOM

   <img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240121114842031.png" alt="image-20240121114842031" style="zoom:50%;" /> 

3. 构建渲染（render）树

   ![image-20240121114959429](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240121114959429.png) 

4. 布局

   获取渲染树的结构，节点位置和大小，然后依据盒子模型来进行布局

5. 绘制

   把渲染树以像素的形式绘制在页面上

![image-20240121114521130](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240121114521130.png) 

**（如果构建DOM的过程中，碰见js，则下载js，如果js没有额外的设置则需要等到CSSOM构建完成后才能执行js文件，js既可以对DOM做修改，也可以对CSSOM做修改）**



##### HTTP：

HTTP（Hyper Text Transformer Protocol，超文本传输协议）是一种通信协议，它允许将超文本标记语言（HTML）文档从Web服务器传送到客户端的浏览器。

它是一个应用层协议，承载于TCP协议之上。

###### HTTP1.0

HTTP/1.0是第一个在通讯中指定版本号的HTTP协议版本，至今仍被广泛采用，特别是在代理服务器中。默认采用短连接。

HTTP1.0规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）。这种无状态性可以借助cookie/session机制来做身份认证和状态记录。

缺点，无连接的特性导致最大的性能缺陷就是无法复用连接。每次发送请求的时候，都需要进行一次TCP的连接，而TCP的连接释放过程又是比较费事的。这种无连接的特性会使得网络的利用率非常低。

###### HTTP1.1

HTTP/1.1版本，持久连接/长连接被默认采用（默认模式使用带流水线的持久连接），并能很好地配合代理服务器工作，还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。

###### HTTP请求方法

1. GET

   请求指定的页面信息，并返回实体主体。

   注：GET也可以将数据提交到服务器，不过一般都是使用POST提交数据到服务器.

2. POST

   POST请求方法的作用：向服务器发送数据。

   POST和GET请求方法的本质区别：

   ​    1、GET用于信息获取，它是安全的（这里安全的含义是指非修改信息），而POST是用于修改服务器上资源的请求；

   ​    2、GET请求的数据会附在URL之后（然后提交到服务器），而POST把提交的数据则放置在HTTP实体的主体里，所以，POST的安全性要比GET的安全性高；

   ​    3、GET方式提交数据和POST方法提交数据并没有限制数据大小。

3. HEAD

   HEAD请求方法作用：只请求头部，允许客户端在未获取资源实体的情况下，对资源的头部检查，了解资源的基本情况，比如类型，是否被修改过等。

   HEAD和GET请求方法的区别：GET请求回来的报文有实体的主体部分，而HEAD请求回来的报文没有实体的主体部分。

###### 状态码

2xx 成功

3xx 重定向

4xx 客户端报错

5xx 服务端报错

###### Cookie

是某些网站为了辨别用户身份，进行[Session](https://baike.baidu.com/item/Session/479100?fromModule=lemma_inlink)跟踪而储存在用户本地终端上的数据（通常经过加密），由用户[客户端](https://baike.baidu.com/item/客户端/101081?fromModule=lemma_inlink)计算机暂时或永久保存的[信息](https://baike.baidu.com/item/信息/111163?fromModule=lemma_inlink) 。

###### HTTPS

HTTPS （全称：Hypertext Transfer Protocol Secure [5]），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和[身份认证](https://baike.baidu.com/item/身份认证/5294713?fromModule=lemma_inlink)保证了传输过程的安全性 。HTTPS 在HTTP 的基础下加入[SSL](https://baike.baidu.com/item/SSL/320778?fromModule=lemma_inlink)，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。

## Git

#### git基础命令笔记：

git remote -v查看配置了的远程连接的名称

git remote add origin https://github.com/RJrowlling/ExerciseProject.git 配置远程连接，连接本地仓库和远程仓库

git remote rm origin 删除配置了的远程连接



git branch 查看分支名称

git branch issue1 新建分支

git branch -d issue1 删除分支

git checkout mian 切换分支



git add README.md 将READNE.md文件添加到索引暂存区

git commit -m "将暂存区里的索引同步到本地数据库上，并设置了message"

git push origin main 将本地仓库的数据推送到远程仓库的main分支中



git revert HEAD撤消上一次提交的更改。

1. 注意这里只是从本地仓库中还原了上一次提交的更改，如果你已经push到远程仓库，则远程仓库不变，除非你再次push
2. Git revert 命令将一个提交作为参数，并**创建一个新的提交来撤消该提交所做的更改**。

#### 把本地项目上传到github上出现了问题？

![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240127160257601.png) 

![image-20240127160239654](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240127160239654.png) 

##### 1. 没有在github上面关联公钥

基础的内容已经配置好了（用户名，电子邮箱，本地钥匙都有），首先进入C:\Users\cjy\\.ssh目录文件下找到id_rsa.pub公钥，打开记事本复制内容到下图（配置好后，github会给你发电子邮件）

![image-20240127160036193](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240127160036193.png) 

##### 2.网络连接问题

ping github.com时，会显示超时，这就是网络连接问题。通过ip查询https://ipaddress.com/website/github.com找到github.com的ip地址，例如（140.82.113.4）

![image-20240127160751778](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240127160751778.png)

此时修改本地 DNS 文件 C:\Windows\System32\drivers\etc 目录下的 hosts 文件，由于该文件在 C 盘中，无法直接打开进行修改，需要使用管理员权限，此处操作方式为，搜索 记事本 软件，右键以管理员身份运行，选择上述 hosts 文件打开，在文件内容最下方加入一行

```
140.82.113.4    github.com
```

## Node.js

定义：node.js是一个开源的，跨平台的JavaScript运行环境

安装：https://blog.csdn.net/zxy15974062965/article/details/121117803

### 包管理工具

包：package，代表了一组功能的源码集合

包管理工具：管理【包】的应用软件，进行下载安装、更新、删除操作

#### npm

npm全称node package Manage【node的包管理工具】

npm是node.js官方**内置的**包管理工具

##### npm 全局安装 ：

```
npm i -g <包名>

npm root -g
```

全局安装的命令不受工作目录位置的影响，**而且安装的位置不是在当前工作目录的node_module，而是在全局安装包的位置**，可以通过**npm root -g** 可以查看全局安装包的位置；而且并不是所有包都适合全局安装。

##### **windows会对全局安装的脚本进行约束，不让它运行？**

可以通过修改windows的执行策略来解决这个问题，具体：输入：set-ExecutionPolicy remoteSigned

![image-20240201094202340](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240201094202340.png)

##### **npm 安装所有依赖**：

```
npm i
npm install
```

通过该命令可以依据package.json和package-lock.json的依赖声明，安装项目所有依赖（**node-modules文件夹大多数情况是不会存入版本库的**），只有安装完所有依赖才能够正常启动项目

##### 安装指定版本的包：

```
npm i <包名@版本号>
例子：
npm i jquery@1.11.2
```

##### 删除依赖：

```
局部删除：
npm remove unip
全局删除：
npm remove -g nodemon
```

##### npm 配置命名别名：

可以通过命名别名可以更简单的执行命令，具体来说，配置package.json中的scripts属性

![image-20240201100222985](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240201100222985.png)

##### cnpm：

cnpm是淘宝构建的npmjs.com的完整镜像，也称为**淘宝镜像**，cnpm服务部署在国内阿里云服务器上，可以提高包的下载速度。

**淘宝镜像源官网：**https://www.npmmirror.com/，这里可以获得第一手的镜像网站

**官方也提供了一个全局工具包cnpm**（不是内置的），操作命令与npm大体相同。

**安装cnpm：**

```
npm install -g cnpm --registry=https://registry.npmmirror.com
```

##### npm配置淘宝镜像：

npm 也可以使用淘宝镜像源，直接配置：



```
 npm config set registry https://registry.npmmirror.com

在配置之前，先 npm config list查看，并保存一下原来的registry，方便后面改回来
"https://registry.npmjs.org/"这是npm原有的数源
```

**使用了淘宝镜像源之后，就不要搭梯子了，关掉梯子，yarn才能正常运行。**

#### Yarn

介绍：yarn是由Facebook推出的JavaScript包管理工具

特点：速度超快，会缓存包，所以下次下载无需重复下载。并行下载

安装：

```
npm i -g yarn
```

##### yarn常用命令

![image-20240201103854636](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240201103854636.png)

##### yarn全局安装

查询 yarn 安装依赖的全局路径 

```
yarn global bin
```

修改 yarn 全局 bin 位置 ，这个就是yarn之后安装全局依赖的位置，**但是注意，要修改环境变量，才能使yarn全局安装的包正常运行**

```
yarn config set prefix "D:\nodejs\node_modules\yarn\bin"
```

##### yarn配置淘宝镜像

```
yarn config set registry https://registry.npmmirror.com

在配置之前，先 yarn config list查看，并保存一下原来的registry，方便后面改回来
```

**使用了淘宝镜像源之后，就不要搭梯子了，关掉梯子，yarn才能正常运行。**

## React



## VScode使用

##### VScode怎么运行js文件？

+ **使用内置终端**

  首先，我们需要打开一个JS文件，然后按下“Ctrl+Shift+`”键，打开终端界面，可以在其中输入“**node 文件名.js**”命令来运行JS文件。

+ **使用Code Runner插件**

​	安装Code Runner插件，打开一个JS文件，然后按下**“Ctrl+Alt+N”键**，Code Runner会自动运行当前打开的JS文件，并在底部显示输出结果。

+ **使用Live Server插件**

​	在VSCode中安装Live Server插件，打开一个HTML文件，然后按下**“Alt+L”键**，此时，Live Server会自动启动一个本地服务器，并在浏览器中打开我们的HTML文件。如果HTML文件中引用了JS文件，Live Server也会自动运行这些JS文件。

##### VScode怎样调试js文件？

1. 首先要加断点

   ![image-20240117163505090](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117163505090.png) 

2. 点击JavaScript调试终端

   ![image-20240117163526777](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117163526777.png) 

3. 在终端里面输入node 文件名.js，回车

​	![image-20240117163613470](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117163613470.png) 

4. 在左侧进行调试

​	<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117163831404.png" alt="image-20240117163831404" style="zoom:50%;" /> 

# 项目笔记 

### 留言板项目：

![image-20240126133325443](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240126133325443.png)

1、在设置点赞的时候，你要用到<button onclick="点赞函数（this）">，这里面的this就是button按钮本身，通过**this.parentNode**,来访问到父级的容器节点，通过在**父级的容器节点.querySelect("点赞数")**，来获取到点赞按钮对应的点赞数。

2、设置了每一次在刷新或是发布评论时，随机更换头像。

### todolist项目：

要求：用前端三件套去实现todolist的基本功能，并结合git实现版本管理

成果图：

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E6%88%90%E6%9E%9C1.png" alt="image-20240128113121971" style="zoom: 80%;" /> 

<img src="https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/%E9%A1%B9%E7%9B%AE%E6%88%90%E6%9E%9C2.png" alt="image-20240128113225760" style="zoom:80%;" /> 

心得：

1. 对于每一项任务的删除或完成操作，借鉴了留言板项目的点赞功能，通过this.parentNode找到父级容器，然后运用node.remove()操作进行删除操作
2. 批量操作师根据复选框的checked属性进行if判断的，勾选则checked属性为true，用forEach进行批量操作
3. 不完善的点，每一次计算待办任务和已完成任务的数量，都要重新计算类数组的长度，我觉得可以用监听来实现这一点，只要类数组的长度有变化，就会立即更新待办任务和已完成任务的数量，而不用在每一个需要删除和完成操作的函数最后面进行更新

### 零钱通项目：

 使用 Java 开发 零钱通项目 , 完成收益入账，消费，查看明细，退出系统等功能。面向过程编程、面向对象编程两种方式

![image-20240303110648477](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303110648477.png) 

### 房屋出租系统

实现基于文本界面的《房屋出租软件》。

 能够实现对房屋信息的添加、修改和删除（用数组实现），并能够打印房屋明细表

![image-20240303164142160](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303164142160.png) 

![image-20240303164216502](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303164216502.png) 

**退出系统**

![](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303164243311.png) 

**设计分析**

![image-20240303165520739](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240303165520739.png) 

### VForm表单自定义组件创建

1. **创建组件**，在src/components/form-designer/form-widget/field-widget中，注意文件名和name属性的键值相对应

![image-20240117183611890](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117183611890.png) 

```vue
<template>
	<container-wrapper :designer="designer" :widget="widget" :parent-widget="parentWidget" :parent-list="parentList"
					   :index-of-parent-list="indexOfParentList">
		<div :key="widget.id" class="tree-container"
			 :class="{'selected': selected}" @click.stop="selectWidget(widget)">
			<el-input v-if="widget.options.filter" v-model="filterText" placeholder="输入关键字进行过滤"/>
			<el-row class="padding5-top-bottom" v-if="widget.options.expandRetractAllNode || widget.options.selectClearAllNode">
				<el-col>
					<el-button-group>
						<el-button v-if="widget.options.expandRetractAllNode" type="primary" plain round @click="expandAll">展开/收缩</el-button>
						<el-button v-if="widget.options.selectClearAllNode" type="primary" plain round @click="selectAll">选中/取消选中</el-button>
					</el-button-group>
				</el-col>
			</el-row>
			<el-tree
				ref="tree"
				node-key="id"
				:props="defaultProps"
				:data="widget.options.treeData"
				:show-checkbox="widget.options.showCheckBox"
				:default-expand-all="widget.options.defaultExpandAllNode"
				:expand-on-click-node="widget.options.expandOnClickNode"
				:draggable="widget.options.draggable"
				:filter-node-method="filterNode"
				@node-click="handleTreeNodeClick"
				@check="handleTreeNodeCheck"
				@node-contextmenu="handleTreeContextmenu"
				@check-change="handleTreeCheckChange"
			>
				<template #default="{ node, data }">
					<span class="custom-tree-node">
						  <span>{{ node.label }}</span>
						  <span v-if="widget.options.nodeEdit">
							  <el-button size="small" type="primary" link @click.stop="handleAppend(data)">添加</el-button>
							  <el-button size="small" type="primary" link @click.stop="handleRemove(node, data)">删除</el-button>
						  </span>
					</span>
				</template>
			</el-tree>
		</div>
	</container-wrapper>
</template>

<script>
import i18n from "@/utils/i18n";
import containerMixin from "@/components/form-designer/form-widget/container-widget/containerMixin";
import refMixinDesign from "@/components/form-designer/refMixinDesign";
import ContainerWrapper from "@/components/form-designer/form-widget/container-widget/container-wrapper.vue";
import FieldComponents from "@/components/form-designer/form-widget/field-widget";
import {toRaw} from "vue";
import {treeToArray} from "@/utils/util";

export default {
	name: "tree-widget",
	componentName: 'ContainerWidget',
	mixins: [i18n, containerMixin, refMixinDesign],
	inject: ['refList'],
	components: {
		ContainerWrapper,
		...FieldComponents,
	},
	props: {
		widget: Object,
		parentWidget: Object,
		parentList: Array,
		indexOfParentList: Number,
		designer: Object,
	},
	data() {
		return {
			filterText: '',
			isExpanded: true,
			isChecked: false,
			defaultProps: {
				children: 'children',
				label: 'label'
			},
			id: 1000
		}
	},
	computed: {
		selected() {
			return this.widget.id === this.designer.selectedId
		},

		customClass() {
			return this.widget.options.customClass || ''
		},
	},
	watch: {
		filterText(val) {
			this.$refs.tree.filter(val)
		}
	},
	methods: {
		filterNode(value, data) {
			if (!value) return true
			return data.label.includes(value)
		},
		expandAll() {
			this.isExpanded =!this.isExpanded
			const list = treeToArray(toRaw(this.widget.options.treeData));
			list.forEach((item, index) => {
				this.$refs.tree.store.nodesMap[list[index].id].expanded = this.isExpanded;
			})
		},
		selectAll() {
			this.isChecked =!this.isChecked
			const list = toRaw(this.widget.options.treeData);
			this.$refs.tree.setCheckedNodes(this.isChecked ? list : [])
		},
		handleRemove(node, data) {
			const parent = node.parent
			const children = parent.data.children || parent.data
			const index = children.findIndex((d) => d.id === data.id)
			children.splice(index, 1)
			this.widget.options.treeData = [...this.widget.options.treeData]
		},
		handleAppend(data) {
			const newChild = { id: this.id++, label: 'testNode', children: [] }
			if (!data.children) {
				data.children = []
			}
			data.children.push(newChild)
			this.widget.options.treeData = [...this.widget.options.treeData]
		}
	}
}
</script>

<style lang="scss" scoped>
div.tree-container {
	padding: 5px;
	border: 1px dashed #336699;
	box-sizing: border-box;
}

.tree-container.selected {
	outline: 2px solid $--color-primary !important;
}
.custom-tree-node {
	flex: 1;
	display: flex;
	align-items: center;
	justify-content: space-between;
	font-size: 14px;
	padding-right: 8px;
}
</style>

```

2. **配置组件参数**，在src/components/form-designer/widget-panel/widgetsConfig.js中，主要有三个基础的数组（containers，basicFields，advancedFields），我们的组件参数放到basicFields中

![image-20240117184232396](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117184232396.png) 

```js
{
        type: "tree",
        icon: "tree",
        category: "container",
        widgetList: [],
        options: {
            name: "tree42275",
            label: "tree",
            size: "default",
            disabled: false,
            hidden: false,
            parentChildLinkAble: true,
            customClass: [],
            dsEnabled: false,
            dsName: "",
            dataSetName: "",
            showCheckBox: true,
            filter: true,
            defaultExpandAllNode: true,
            expandRetractAllNode: true,
            selectClearAllNode: true,
            expandOnClickNode: true,
            nodeEdit: true,
            draggable: false,
            lazy: false,
            treeDataEdit: true,
            onCreated: "",
            onMounted: "",
            onNodeClick: "",
            onNodeCheck: "",
            onNodeContextmenu: "",
            onCheckChange: "",
            treeData: [
                {
                    id: 1,
                    label: "一级 1",
                    children: [
                        {
                            id: 2,
                            label: "二级 1-1",
                            children: [
                                {
                                    id: 3,
                                    label: "三级 1-1-1"
                                }
                            ]
                        }
                    ]
                },
                {
                    id: 4,
                    label: "一级 2",
                    children: [
                        {
                            id: 5,
                            label: "二级 2-1",
                            children: [
                                {
                                    id: 6,
                                    label: "三级 2-1-1"
                                }
                            ]
                        },
                        {
                            id: 7,
                            label: "二级 2-2",
                            children: [
                                {
                                    id: 8,
                                    label: "三级 2-2-1"
                                }
                            ]
                        }
                    ]
                },
                {
                    id: 9,
                    label: "一级 3",
                    children: [
                        {
                            id: 10,
                            label: "二级 3-1",
                            children: [
                                {
                                    id: 11,
                                    label: "三级 3-1-1"
                                }
                            ]
                        },
                        {
                            id: 12,
                            label: "二级 3-2",
                            children: [
                                {
                                    id: '3-2-1',
                                    label: "三级 3-2-1"
                                }
                            ]
                        }
                    ]
                }
            ]
        }
    }

```

3. 设置中文映射，目的是把名称添加到组件上去，在src/lang/zh-CN.js中，**designer——>widgetLabel——>tree:           '树',**这里的tree要与第一步中的name属性值相对应（tree-widget——>tree）

![image-20240117185905735](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117185905735.png)

经过以上三步就可以简单创建一个VForm的自定义属性“树”，组件的样式基于第二步配置的组件参数

![image-20240117190327017](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240117190327017.png)

### 用户中心项目：

完整了解做项目的思路，接触一些企业级的开发技术（尽量少写代码）

#### 企业做项目流程

需求分析=>设计（概要设计，详细设计）=> 技术选型=>初始化项目/引入需要的技术=>写Demo=>写代码（实现业务逻辑）=>测试（单元测试）=>代码提交/代码评审=>部署=>发布

#### 需求分析

1. 登录/注册

2. 数据库设计：

   id（主键）bigint

   username 昵称 varchar

   userAccount 登录账号 

   avatarUrl 头像 varchar

   gender 性别 tinyint

   userPassword 密码 varchar

   phone 电话 varchar

   email 邮箱 varchar

   isValid 是否有效 (比如被封号)tinyint 0 1

   ------

   createTime 创建时间（数据插入时间）datetime

   updateTime 更新时间（数据更新时间）datetime

   isDelete 是否删除0 1（逻辑删除）tinyint

3. 用户管理（仅管理员可见）对用户的查询、修改

4. 用户校验（仅星球用户）

   

   

#### 技术选型

前端：三件套+React+组件库Ant Design+Umi+Ant Design Pro（现成的管理系统）

后端：java + spring + springmvc + mybatis + mybatis-plus+springboot+mysql

部署：服务器+容器（平台）

#### 计划

1. 初始化项目
   1. 前端初始化
      1. 初始化项目
      2. 引入一些组件
      3. 框架介绍/项目瘦身
   2. 后端初始化
      1. 准备环境（MySql之类的）
      2. 引入框架（整合框架）
2. 登录/注册
   1. 前端
   2. 后端
3. 用户管理（仅管理员可见）
   1. 前端
   2. 后端

#### 注册逻辑

1. 用户在前端输入账号和密码，以及校验码
2. 校验用户的账户、密码、验证密码是否符合要求
   1. 非空
   2. 账户的话**不小于**4位
   3. 密码**不小于**8位
   4. 账户不能重复
   5. 账户不包含特殊字符
   6. 密码和验证密码相同
3. 对密码进行加密（密码千万不能直接以明文储存到数据库中）
4. 向数据库插入用户数据

#### 登录接口

接受参数： 用户账户、密码

请求类型：POST

请求体：JSON格式的数据

> 请求参数很长时，不建议用get

返回值：用户信息（**脱敏**） 

#### 登录逻辑

1. 校验用户账户密码是否合法 
   1. 非空
   2. 账户的话**不小于**4位
   3. 密码**不小于**8位
   4. 账户不包含特殊字符
2. 校验密码是否输入正确，要和数据库中的密文密码去比对
3. 返回用户信息（脱敏），隐藏敏感信息，防止数据库中的字段泄露
4. 记录用户的登录态（session），将其存到服务器上（用后端springboot框架封装的服务器tomcat去记录）
5. 返回脱敏后的用户信息

#### 用户管理接口

！！！必须鉴权

1. 查询用户
   1. 允许根据用户名查询
2. 删除用户

#### 如何知道那个用户登录了？（javaweb）

1. 连接服务器端后，得到一个session状态（匿名会话），返回给前端

2. 登陆成功后，得到一个登录成功的session，并给该session设置一些值，比如说用户信息，返回给前端一个设置cookie的命令。

   **session => cookie **

3. 前端接受到后端命令后，奢姿cookie，保存到浏览器内

4. 前端再次请求后端的时候（相同的域名），在请求头带上cookie去请求

5. 后端拿到前端传来的cookie，找到对应的session

6. 后端从session中可以取出基于该session存储的变量（用户的登录信息、登录名）


#### 前后端交互

前端需要向后端发送请求

前端ajax来请求后端

axious封装了ajax

request是ant design项目有封装了一次

#### 代理

正向代理：替客户端向服务器发送请求，

反向代理：替服务器接受请求，

怎么搞代理？

Nginx服务器

node.js服务器

![image-20240207144306714](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240207144306714.png)

#### 问题解决：

1. 前端初始化，在使用官网命令时，没有umi3选项？

   在cmd输入yarn global add create-umi@0.27.0，建个myapp文件夹，在这个文件夹的cmd下输入create-umi。如果在输入create-umi显示是外部命令（这是yarn的小毛病，yarn全局安装的包确实用不了），需要先**yarn global bin**找到yarn的bin目录，然后再把此目录添加进环境变量。

   总结：没有使用官方的命令，而是通过全局下载的create-umi



2. 前端初始化，yarn global add create-umi@0.27.0网络一直ping不通报？

   yarn和npm一样都可以配置淘宝镜像源，配置之后可以通过yarn config list检查。配置成功之后要关掉梯子。



3. 后端初始化，在配置java版本时，最低也只能到java17版本，需要java8？

   原因是springboot官方停止了对springboot2的维护，解决办法就是在IDEA里更改Server URL即可，用阿里云的镜像。

![image-20240202090502436](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240202090502436.png)

4. 连接数据库时，mysql连接不了，经过查找发现是Mysql服务无法启动的问题？

![image-20240202094357389](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240202094357389.png)

![image-20240202100104008](https://typora2442972980.oss-cn-wuhan-lr.aliyuncs.com/image-20240202100104008.png) 

直接专业卸载

5. 打开金师播放器后，复制粘连键用不了了？

   win + r 打开命令框，输入 cmd.exe /c echo off | clip （每次打开播放器观看都需要输入）

#### 
